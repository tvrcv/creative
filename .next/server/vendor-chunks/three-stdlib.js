"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\n\n//# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdG9tYXNcXFByb2plY3RzXFxjcmVhdGl2ZVxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXF9wb2x5ZmlsbFxcTG9hZGVyVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlVGV4dChhcnJheSkge1xuICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheSk7XG4gIH1cbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVUZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyVXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst version = /* @__PURE__ */ (() => parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsZ0RBQWdELDJDQUFRO0FBR3REO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdG9tYXNcXFByb2plY3RzXFxjcmVhdGl2ZVxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXF9wb2x5ZmlsbFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCB2ZXJzaW9uID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKSkoKTtcbmV4cG9ydCB7XG4gIHZlcnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/uv1.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UV1: () => (/* binding */ UV1)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\nconst UV1 = _constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 125 ? \"uv1\" : \"uv2\";\n\n//# sourceMappingURL=uv1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC91djEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUM7QUFDekMsWUFBWSxrREFBTztBQUdqQjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxfcG9seWZpbGxcXHV2MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5jb25zdCBVVjEgPSB2ZXJzaW9uID49IDEyNSA/IFwidXYxXCIgOiBcInV2MlwiO1xuZXhwb3J0IHtcbiAgVVYxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXYxLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\n\n//# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdG9tYXNcXFByb2plY3RzXFxjcmVhdGl2ZVxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXGxpYnNcXE1lc2hvcHREZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBnZW5lcmF0ZWQ7XG5jb25zdCBNZXNob3B0RGVjb2RlciA9ICgpID0+IHtcbiAgaWYgKGdlbmVyYXRlZClcbiAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICBjb25zdCB3YXNtX2Jhc2UgPSBcIkI5aDl6OXRGQkJCRjhmTDlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYTlnRWFhYUZhRU1jQkZGRkdHR0VJSUlMRjl3RkZGTEVGQkZLTkZhRkN4L0lGTU8vTEZWSzl0djl0OXZxOTVHQnQ5ZjlmOTM5aDl6OXQ5ZjlqOWg5czlzOWY5alc5dnE5ekJCcDl0djl6OW85djl3VzlmOWt2OWo5djlrdjlXdnFXdjk0aDkxOW05bXZxQkY4Wjl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NGg5MTltOW12cUJHeTl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NDlUdlo5MXY5dTlqdkJFbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVA5aldCSWk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlSOTE5aFdCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlGOTQ5d0JLSTl6OWlxbEJPYyt4OHljR0JNL3FRRlRhOGpVVVVVQkNVL0VCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUdUa1VVVUJSTkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJWQUVDRkpSSUNCUmNHWEVYQWNBRjlQUUZBVkFGQWNsQWNBVkpBRjlKeVJNR1hHWEFHOUZRQkFNQ2JKSEtDOXdaUlNBS0NJckNFSkNHclJRQU5DVUdKUmZDQlJiQUlSVEVYR1hBT0FUbEFROVBRQkNCUklTRU1BVEFRSlJJR1hBUzlGUUJDQlJ0Q0JSRUVYR1hBT0FJbENpOVBRQkNCUklTTE1BTkNVL0NCSkFFSlJLR1hHWEdYR1hHWEFUQUVDS3JKMkJCQXRDS1pyQ0VaZklCRkdFQk1BS2hCODNFQkFLQ05KaEI4M0VCU0VNQUtBSTJCSUFJMkJCSG1DS3JIWUFZQ0U2SFl5ODZCQkFLQ0ZKQUlDSUpBWUpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NHSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDRUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ0lKQVlBbUpIWTJCQkFJMkJGSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ0xKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NLSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDT0pBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ05KQVlBbUpIWTJCQkFJMkJHSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ1ZKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NjSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDTUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ1NKQVlBbUpIbTJCQkFJMkJFSElDS3JIWUFZQ0U2SFl5ODZCQkFLQ1FKQW1BWUpIbTJCQkFJQ0lyQ0VaSFlBWUNFNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSUNHckNFWkhZQVlDRTZIWXk4NkJCQUtDYkpBbUFZSkhLMkJCQUlDRVpISUFJQ0U2SEl5ODZCQkFLQUlKUklTR01BS0FJMkJOQUkyQkJIbUNJckhZQVlDYjZIWXk4NkJCQUtDRkpBSUNOSkFZSkhZMkJCQW1DYlpIbUFtQ2I2SG15ODZCQkFLQ0dKQVlBbUpIbTJCQkFJMkJGSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ0VKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NJSkFtQVlKSG0yQkJBSTJCR0hZQ0lySFBBUENiNkhQeTg2QkJBS0NMSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDS0pBbUFZSkhtMkJCQUkyQkVIWUNJckhQQVBDYjZIUHk4NkJCQUtDT0pBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ05KQW1BWUpIbTJCQkFJMkJJSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1ZKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NjSkFtQVlKSG0yQkJBSTJCTEhZQ0lySFBBUENiNkhQeTg2QkJBS0NNSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDU0pBbUFZSkhtMkJCQUkyQktIWUNJckhQQVBDYjZIUHk4NkJCQUtDUUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ2ZKQW1BWUpIbTJCQkFJMkJPSElDSXJIWUFZQ2I2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ2JaSElBSUNiNkhJeTg2QkJBS0FJSlJJU0ZNQUtBSThwQkI4M0JCQUtDTkpBSUNOSjhwQkI4M0JCQUlDVEpSSU1BdENHSlJ0QUVDVEpIRUFTOUpRQk1NR1hBSVFCQ0JSSVNFTUdYQU05RlFCQU5BYkoyQkJSdENCUktBZlJFRVhBRUFOQ1UvQ0JKQUtKMkJCSFRDRnJDQkFUQ0ZabDl6QXRKSHQ4NkJCQUVBR0pSRUFLQ0ZKSEtBTTlIUUJNTUFmQ0ZKUmZBSVJUQWJDRkpIYkFHOUhRQk1NQUJBY0FHOXNKQU5DVUdKQU1BRzlzVGtVVVVCcEFOQU5DVUdKQU1DYUpBRzlzSkFHVGtVVVVCcE1BTUNCQUl5QWNKUmNBSVFCTUM5K1JLU0ZNQ0JDOTlBT0FJbEFHQ0FBR0NBOUx5NnlSS01BTENVL0VCSjhrVVVVVUJBS00rT21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUZUK0pVVVVCcEFMQzg0SmhhODNFQkFMQzh3SmhhODNFQkFMQzhvSmhhODNFQkFMQ0FKaGE4M0VCQUxDaUpoYTgzRUJBTENUSmhhODNFQkFMaGE4M0VOQUxoYTgzRUJBRUFJSkM5d0pSY0FFQ0ZKSE5BT0pSTUdYQUY5RlFCQ1FDYkFWQ0Y2eVJTQUJSRUNCUlZDQlJRQ0JSZkNCUklDQlJLRVhHWEFNQWN1UUJDOStSS1NFTUdYR1hBTjJCQkhPQy92RjlMUUJBTENvQkpBT0NJckNhOXpBS0pDYlpDRVdKSGI4b0dJUlRBYjhvR0JSdEdYQU9DYlpIYkFTOVBRQkFMQU9DYTl6QUlKQ2JaQ0dXSjhvR0JBVkFieVJPQWI5RlJiR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFPODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQU9qR0JBRUNJSkFUakdCTUFWQWJKUlZBTENvQkpBS0NFV0pIbUFPakdCQW1BVGpHSUFMQUlDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhUQXRqR0JBVEFPakdJQUlBYkpSSUFLQ0ZKUktTR01HWEdYQWJDYjZRQkFRQWJKQWJDOTg5ekpDRkpSUVNGTUFNMUJCSGJDZ0ZaUk9HWEdYQWJDYTlNUUJBTUNGSlJNU0ZNQU0xQkZIYkNnQlpDT1dBT0NnQlpxUk9HWEFiQ2E5TVFCQU1DR0pSTVNGTUFNMUJHSGJDZ0JaQ2ZXQU9xUk9HWEFiQ2E5TVFCQU1DRUpSTVNGTUFNMUJFSGJDZ0JaQ2RXQU9xUk9HWEFiQ2E5TVFCQU1DSUpSTVNGTUFNMkJJQzhjV0FPcVJPQU1DTEpSTU1BT0NGckNCQU9DRlpsOXpBUUpSUU1HWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQVE4N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBUWpHQkFFQ0lKQVRqR0JNQUxDb0JKQUtDRVdKSE9BUWpHQkFPQVRqR0lBTEFJQ0dXSkFRakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIT0F0akdCQU9BUWpHSUFJQ0ZKUklBS0NGSlJLU0ZNR1hBT0NERjlMUUJBTEFJQWNBT0NiWkoyQkJIYkNJckhUbENiWkNHV0o4b0dCQVZDRkpIdEFUeVJPQUxBSUFibENiWkNHV0o4b0dCQXRBVDlGSG1KSHRBYkNiWkhUeVJiQVQ5RlJUR1hHWEFHQ0c5SFFCQUJBVjg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVmpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQUlDR1dKQVZqR0JBTENvQkpBS0NFV0pIWUFPakdCQVlBVmpHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUFtSkNiWkhJQ0dXSkFiakdCQUxDb0JKQUtDR0pDYlpIS0NFV0pIT0FWakdCQU9BYmpHSUFLQ0ZKUktBSUFUSlJJQXRBVEpSVlNGTUFWQ0JBTTJCQkhZeUhUQU9DLytGNkhQSlJPQVlDYlpSdEdYR1hBWUNJckhtUUJBT0NGSlJiU0ZNQU9SYkFMQUlBbWxDYlpDR1dKOG9HQlJPTUdYR1hBdFFCQWJDRkpSVlNGTUFiUlZBTEFJQVlsQ2JaQ0dXSjhvR0JSYk1HWEdYQVA5RlFCQU1DRkpSWVNGTUFNMUJGSFlDZ0ZaUlRHWEdYQVlDYTlNUUJBTUNHSlJZU0ZNQU0xQkdIWUNnQlpDT1dBVENnQlpxUlRHWEFZQ2E5TVFCQU1DRUpSWVNGTUFNMUJFSFlDZ0JaQ2ZXQVRxUlRHWEFZQ2E5TVFCQU1DSUpSWVNGTUFNMUJJSFlDZ0JaQ2RXQVRxUlRHWEFZQ2E5TVFCQU1DTEpSWVNGTUFNQ0tKUllBTTJCTEM4Y1dBVHFSVE1BVENGckNCQVRDRlpsOXpBUUpIUVJUTUdYR1hBbUNiNlFCQVlSUFNGTUFZMUJCSE1DZ0ZaUk9HWEdYQU1DYTlNUUJBWUNGSlJQU0ZNQVkxQkZITUNnQlpDT1dBT0NnQlpxUk9HWEFNQ2E5TVFCQVlDR0pSUFNGTUFZMUJHSE1DZ0JaQ2ZXQU9xUk9HWEFNQ2E5TVFCQVlDRUpSUFNGTUFZMUJFSE1DZ0JaQ2RXQU9xUk9HWEFNQ2E5TVFCQVlDSUpSUFNGTUFZQ0xKUlBBWTJCSUM4Y1dBT3FST01BT0NGckNCQU9DRlpsOXpBUUpIUVJPTUdYR1hBdENiNlFCQVBSTVNGTUFQMUJCSE1DZ0ZaUmJHWEdYQU1DYTlNUUJBUENGSlJNU0ZNQVAxQkZITUNnQlpDT1dBYkNnQlpxUmJHWEFNQ2E5TVFCQVBDR0pSTVNGTUFQMUJHSE1DZ0JaQ2ZXQWJxUmJHWEFNQ2E5TVFCQVBDRUpSTVNGTUFQMUJFSE1DZ0JaQ2RXQWJxUmJHWEFNQ2E5TVFCQVBDSUpSTVNGTUFQQ0xKUk1BUDJCSUM4Y1dBYnFSYk1BYkNGckNCQWJDRlpsOXpBUUpIUVJiTUdYR1hBR0NHOUhRQkFCQVQ4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVRqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTENvQkpBS0NFV0pIWUFPakdCQVlBVGpHSUFMQUlDR1dKQVRqR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0dKQ2JaQ0VXSkhPQVRqR0JBT0FiakdJQUxBSUFtOUZBbUNiNnFKSElDYlpDR1dKQWJqR0JBSUF0OUZBdENiNnFKUklBS0NFSlJLTUFOQ0ZKUk5BQkNLSlJCQUVDU0pSRUFLQ2JaUktBSUNiWlJJQWZDRUpIZkFGOUpRQk1NQ0JDOTlBTUFjNnlSS01BTENvRko4a1VVVVVCQUtNL3RJRkdhOGpVVVVVQkNUbFJMQzkrUktHWEFGQ0xKQUk5TFFCQ2FSS0FFMkJCQy8rRlpDL1FGOUhRQkFMaEI4M0VOQUVDRkpSS0FFQUlKQzk4SlJFR1hBRjlGUUJHWEFHQ0c2UUJFWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BTENOSkFJQ0ZaQ0dXcUhHQUlDR3JDQkFJQ0ZyQ0ZabDl6QUc4b0dCSkhJakdCQUJBSWpHQkFCQ0lKUkJBRkNhSkhGUUJTR01NRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUJBSUNHckNCQUlDRnJDRlpsOXpBTENOSkFJQ0ZaQ0dXcUhJOG9HQkpIRzg3RkJBSUFHakdCQUJDR0pSQkFGQ2FKSEZRQk1NQ0JDOTlBS0FFNnlSS01BS00rbExLRmFGOTlHYUc5OUZhRzk5R1hHWEFHQ0k5SFFCQUY5RlFGRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNHSkhHMUJCK3lBQjFCQkhFK3lISStMK1RBQkNGSkhMMUJCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQkIvK2hBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODZCQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODZCQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODZCQkFCQ0lKUkJBRkNhSkhGUUJTR01NQUY5RlFCRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNJSkhHOHVGQit5QUI4dUZCSEUreUhJK0wrVEFCQ0dKSEw4dUZCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQi8rZzZBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODdGQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODdGQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODdGQkFCQ05KUkJBRkNhSkhGUUJNTU0vU0VJRWFFOTlFYUY5OUdYQUY5RlFCQ0JSRUFCUklFWEdYR1g5RC96STgxOC9BSUNLSjh1RkJITENFcSt5K1ZIS0FJOHVGQit5K1VITzlEQi8rZzYrVTlEQkJCOC85REJCQisvQU85REJCQkI5Z3krU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JWU0ZNQ1VVVVU5NFJWTUFJQ0lKOHVGQlJjQUlDR0o4dUZCUk1BQkFMQ0ZKQ0VaQUVxQ0ZXSkFWODdGQkdYR1hBS0FNK3krVUhOOURCLytnNitVOURCQkI4LzlEQkJCKy9BTjlEQkJCQjlneStTSFMrTDlEQkJCOVA5ZDlGUUJBUytvUk1TRk1DVVVVVTk0Uk1NQUJBTENHSkNFWkFFcUNGV0pBTTg3RkJHWEdYQUtBYyt5K1VISzlEQi8rZzYrVTlEQkJCOC85REJCQisvQUs5REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JjU0ZNQ1VVVVU5NFJjTUFCQUxDYUpDRVpBRXFDRldKQWM4N0ZCR1hHWDlEQkJVOC9BT0FPK1UrVEFOQU4rVStUQUtBSytVK1RITzlEQkJCQkFPOURCQkJCOWd5K1I5REIvK2c2K1U5REJCQjgvK1NITytMOURCQkI5UDlkOUZRQkFPK29SY1NGTUNVVVVVOTRSY01BQkFMQ0VaQUVxQ0ZXSkFjODdGQkFJQ05KUklBRUNJSlJFQUZDYUpIRlFCTU1NOUpCR1hBR0NHckFGOXNIRjlGUUJFWEFCQUI4b0dCSEdDTldDTjkxK3lBR0NpOTFDbldDVVVVLzhFSisrK1U4NEdCQUJDSUpSQkFGQ2FKSEZRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU0vbEZGRmFHWEdYQUZBQnFDRVo5RlFCQUJSRVNGTUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFGOG9HQmpHQkFFQ0lKQUZDSUo4b0dCakdCQUVDTkpBRkNOSjhvR0JqR0JBRUNTSkFGQ1NKOG9HQmpHQkFFQ1RKUkVBRkNUSlJGQUdDOXdKSEdDYjlMUUJNTUFHQ0k5SlFCRVhBRUFGOG9HQmpHQkFGQ0lKUkZBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGMkJCODZCQkFFQ0ZKUkVBRkNGSlJGQUdDYUpIR1FCTU1BQk1vRkZHYUdYR1hBQkNFWjlGUUJBQlJFU0ZNQUZDZ0ZaQytCd3NOOXNSSUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFJakdCQUVDU0pBSWpHQkFFQ05KQUlqR0JBRUNJSkFJakdCQUVDVEpSRUFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBSWpHQkFFQ0lKUkVBR0M5OEpIR0NFOUxRQk1NR1hBRzlGUUJFWEFFQUY4NkJCQUVDRkpSRUFHQ2FKSEdRQk1NQUJNTU1GQkNVTk1JVDlrQkJcIjtcbiAgY29uc3Qgd2FzbV9zaW1kID0gXCJCOWg5ejl0RkJCQkZpSTlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYUVNY0JCRkJGRkdHR0VJTEY5d0ZGRkxFRkJGS05GYUZDeC9hRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJHOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCSXk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQktpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQk9uOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCTkk5ejlpcWxCVmMrTjlJY0lCVEVNOStGTGE4alVVVVVCQ1RsUkJDQlJGRVhDQlJHQ0JSRUVYQUJDTkpBR0pBRUNVYUFGQUdyQ0ZaSEl5ODZCQkFFQUlKUkVBR0NGSkhHQ045SFFCTUFGQ3grWVVVQkpBRTg2QkJBRkNFV0N4a1VVQkpBQjhwRU44M0VCQUZDRkpIRkNVRzlIUUJNTWs4bExiYUU5N0Y5K0ZhTDk3OGpVVVVVQkNVL0tCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUcvOGNCQkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJOQUVDRkpSS0NCUlZHWEVYQVZBRjlQUUZBTkFGQVZsQVZBTkpBRjlKeVJjR1hHWEFHOUZRQkFjQ2JKSElDOXdaSE1DRTlzUlNBTUNGV1JRQUlDSXJDRUpDR3JSZkNCUmJFWEFLUlRDQlJ0R1hFWEdYQU9BVGxBZjlQUUJDQlJLU0xNQUxDVS9DQkpBdEFNOXNKUm1BVEFmSlJLQ0JSRUdYQU1Db0I5SlFCQU9BS2xDL2dCOUpRQkNCUklFWEFtQUlKUkVHWEdYR1hHWEdYQVRBSUNLckoyQkJIWUNFWmZJQkZHRUJNQUVDQkR0RE1JQlNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUJBS0NUSlJLTUdYR1hHWEdYR1hBWUNHckNFWmZJQkZHRUJNQUVDQkR0RE1JVFNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSVRBS0NUSlJLTUdYR1hHWEdYR1hBWUNJckNFWmZJQkZHRUJNQUVDQkR0RE1JQVNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUFBS0NUSlJLTUdYR1hHWEdYR1hBWUNLcmZJQkZHRUJNQUVDQkR0RE1JOHdTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIWUNFV0N4a1VVQkpEQkVCQVlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ0lKQWVEZUJKQVlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NOSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSTh3QUtDVEpSS01BSUNvQkpSRUFJQ1VGSkFNOUxRRkFFUklBT0FLbEMvZkI5TFFCTU1HWEFFQU05UFFCQUVDRXJSSUVYR1hBT0FLbENpOVBRQkNCUktTT01BbUFFSlJZR1hHWEdYR1hHWEFUQUVDS3JKMkJCQUlDS1pyQ0VaZklCRkdFQk1BWUNCRHRETUlCU0VNQVlBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFZQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFZQUtEQkJCRE1JQkFLQ1RKUktNQUlDR0pSSUFFQ1RKSEVBTTlKUUJNTUdYQUs5RlFCQUtSVEF0Q0ZKSHRDSTZRR1NGTU1DQlJLU0VNR1hBTTlGUUJBTENVR0pBYkpSRUFMQWJKREJHQlJlQ0JSWUVYQUVBTENVL0NCSkFZSkhJREJJQkhkQ0ZEOXRBZENGRGJIUEQ5T0Q5aEQ5UkhkQUlBTUpEQklCSDhaQ0ZEOXRBOFpBUEQ5T0Q5aEQ5Ukg4WkRRQlRGdEdtRVlJUExkS2VPbkhwQUlBUUpEQklCSHlDRkQ5dEF5QVBEOU9EOWhEOVJIeUFJQVNKREJJQkg4Y0NGRDl0QThjQVBEOU9EOWhEOVJIOGNEUUJURnRHbUVZSVBMZEtlT25IOGREUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFQWVEOXVIZUR5QmpHQkFFQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFwQThkRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBZEE4WkRRTmlWOFpjcE15UzhjUThkZjhlYjhmSGRBeUE4Y0RRTmlWOFpjcE15UzhjUThkZjhlYjhmSDhaRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKUkVBWUNUSkhZQU05SlFCTU1BYkNJSkhiQUc5SlFCTU1BQkFWQUc5c0pBTENVR0pBY0FHOXMvOGNCQkFMQUxDVUdKQWNDYUpBRzlzSkFHLzhjQkJNQWNDQkFLeUFWSlJWQUtRQk1DOStSS1NGTUNCQzk5QU9BS2xBR0NBQUdDQTlMeTZ5UktNQUxDVS9LQko4a1VVVVVCQUtNTkJUK0JVVVVCTStLbUZUYThqVVVVVUJDb0ZsSEw4a1VVVVVCQzkrUktHWEFGQ0U5dUhPQ3RKQUk5TFFCQ2FSS0FFMkJCSE5DL3dGWkMvZ0Y5SFFCQU5DYlpIVkNGOUxRQkFMQ29CSkNnRkNVRi84TUJBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNL2RMRUs5N0ZhRjk3R1hHWEFHQ0k5SFFCQUY5RlFGQ0JSR0VYQUJBQkRCQkJIRUNpRCtyRkNpRCtzRkQvNkZISUFFQ05EK3JGQ2lEK3NGRC82RkFJRC9nRkFFQ1REK3JGQ2lEK3NGRC82RkhMRC9nRkQva0ZEL2xGSEtDQkR0RCsyRkhPQUlDVVVVVTk0RHRITkQ5T0Q5UkQva0ZISTlEQkIvK2hEWUFJQUlEL21GQUtBS0QvbUZBTEFPQUxBTkQ5T0Q5UkQva0ZISUFJRC9tRkQva0ZEL2tGRC9qRkQvbkZITEQvbUY5REJCWDlMRFlIT0Qva0ZDZ0ZEdEQ5T0FFQ1VVVTk0RHREOU9EOVFBSUFMRC9tRkFPRC9rRkNORCtyRkNVLytFRHREOU9EOVFBS0FMRC9tRkFPRC9rRkNURCtyRkNVVS84T0R0RDlPRDlRRE1CQkFCQ1RKUkJBR0NJSkhHQUY5SlFCU0dNTUFGOUZRQkNCUkdFWEFCQ1RKSFZBVkRCQkJIRUNCRHRIT0NVVTk4RDhjRkNVVTk4RDhjRUhORDlPQUJEQkJCSEtBRURRSUxLT1NRZmJQZGVuOGM4ZDhlOGZDZ2dGRHREOU9ELzZGQUtBRURRQkZHRU5WY01UdG1ZaThacHlIRUNURCtzRkQvNkZISUQvZ0ZBRUNURCtyRkNURCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhFOURCLytnNkRZQUxBRUFPRCsyRkhPQUxDVVVVVTk0RHRIY0Q5T0Q5UkQva0ZITEFMRC9tRkFFQUVEL21GQUlBT0FJQWNEOU9EOVJEL2tGSEVBRUQvbUZEL2tGRC9rRkQvakZEL25GSElEL21GOURCQlg5TERZSE9EL2tGQ1REK3JGQUxBSUQvbUZBT0Qva0ZDZ2dFRHREOU9EOVFITEFFQUlEL21GQU9EL2tGQ2FEYkNCRG5HQ0JEbkVDQkRuS0NCRG5PQ0JEbmNDQkRuTUNCRG5mQ0JEbmJEOU9IRURRTlZpOFpjTXB5U1E4YzhkZmI4ZThmRDlRRE1CQkFCQUtBTkQ5T0FMQUVEUUJGVHRHRW1ZSUxQZEtPZW5EOVFETUJCQUJDQUpSQkFHQ0lKSEdBRjlKUUJNTU0vaEVJR2FGOTdGYUw5NzhqVVVVVUJDVGxSRUdYQUY5RlFCQ0JSSUVYQUVBQkRCQkJITEFCQ1RKSEtEQkJCSE9EUUlMS09TUWZiUGRlbjhjOGQ4ZThmSE5DVEQrc0ZIVkNJRCtyRkRNSUJBQjlEQkJVOC9EWTlEL3pJODE4L0RZQVZDRUR0RDlRRC82RkQvbkZIVkFMQU9EUUJGR0VOVmNNVHRtWWk4WnB5SExDVEQrckZDVEQrc0ZELzZGRC9tRkhPQU9EL21GQVZBTENURCtzRkQvNkZEL21GSGNBY0QvbUZBVkFOQ1REK3JGQ1REK3NGRC82RkQvbUZITkFORC9tRkQva0ZEL2tGRC9sRkNCRHREKzRGRC9qRjlEQi8rZzZEWUhWRC9tRjlEQkJYOUxEWUhMRC9rRkNnZ0VEdEhNRDlPQWNBVkQvbUZBTEQva0ZDVEQrckZEOVFIY0FOQVZEL21GQUxEL2tGQ1REK3JGQU9BVkQvbUZBTEQva0ZBTUQ5T0Q5UUhWRFFCRlR0R0VtWUlMUGRLT2VuSExEOGRCQUVEQklCRHlCK3QrSjgzRUJBQkNOSkFMRDhkRkFFREJJQkR5Rit0K0o4M0VCQUtBY0FWRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIVkQ4ZEJBRURCSUJEeUcrdCtKODNFQkFCQ2lKQVZEOGRGQUVEQklCRHlFK3QrSjgzRUJBQkNBSlJCQUlDSUpISUFGOUpRQk1NTTlqRkY5N0dYQUdDR3JBRjlzSEc5RlFCQ0JSRkVYQUJBQkRCQkJIRUNORCtyRkNORCtzRkQvNkZBRUNpRCtzRkNuRCtyRkNVVVUvOEVEdEQrdUZEL21GRE1CQkFCQ1RKUkJBRkNJSkhGQUc5SlFCTU1NOVRGRWFDQkNCOG9HVWtVVUJIRkFCQ0VKQzk4WkpIQmpHVWtVVUJHWEdYQUI4L0JDVFdIR3VRQkNhUkVBQkFHbENnZ0VKQ1RyWEJDYTZRRk1BRlJFTUFFTU1NRkJDVU5NSVQ5dEJCXCI7XG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgOTcsXG4gICAgMTE1LFxuICAgIDEwOSxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDEsXG4gICAgNCxcbiAgICAxLFxuICAgIDk2LFxuICAgIDAsXG4gICAgMCxcbiAgICAzLFxuICAgIDMsXG4gICAgMixcbiAgICAwLFxuICAgIDAsXG4gICAgNSxcbiAgICAzLFxuICAgIDEsXG4gICAgMCxcbiAgICAxLFxuICAgIDEyLFxuICAgIDEsXG4gICAgMCxcbiAgICAxMCxcbiAgICAyMixcbiAgICAyLFxuICAgIDEyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUyLFxuICAgIDEwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxMSxcbiAgICA3LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICAyNTMsXG4gICAgMTUsXG4gICAgMjYsXG4gICAgMTFcbiAgXSk7XG4gIGNvbnN0IHdhc21wYWNrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDMyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMjUzLFxuICAgIDMsXG4gICAgMSxcbiAgICAyLFxuICAgIDM0LFxuICAgIDQsXG4gICAgMTA2LFxuICAgIDYsXG4gICAgNSxcbiAgICAxMSxcbiAgICA4LFxuICAgIDcsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMzMsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTI4LFxuICAgIDksXG4gICAgMTE2LFxuICAgIDY0LFxuICAgIDE5LFxuICAgIDExMyxcbiAgICAxMjcsXG4gICAgMTUsXG4gICAgMTAsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMTQsXG4gICAgMjU1LFxuICAgIDY2LFxuICAgIDI0LFxuICAgIDU0LFxuICAgIDEzNixcbiAgICAxMDcsXG4gICAgMTgsXG4gICAgMjMsXG4gICAgMTkyLFxuICAgIDI2LFxuICAgIDExNCxcbiAgICAxMTgsXG4gICAgMTMyLFxuICAgIDE3LFxuICAgIDc3LFxuICAgIDEwMSxcbiAgICAxMzAsXG4gICAgMTQ0LFxuICAgIDI3LFxuICAgIDg3LFxuICAgIDEzMSxcbiAgICA0NCxcbiAgICA0NSxcbiAgICA3NCxcbiAgICAxNTYsXG4gICAgMTU0LFxuICAgIDcwLFxuICAgIDE2N1xuICBdKTtcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB7XG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBsZXQgd2FzbSA9IHdhc21fYmFzZTtcbiAgaWYgKFdlYkFzc2VtYmx5LnZhbGlkYXRlKGRldGVjdG9yKSkge1xuICAgIHdhc20gPSB3YXNtX3NpbWQ7XG4gIH1cbiAgbGV0IGluc3RhbmNlO1xuICBjb25zdCBwcm9taXNlID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodW5wYWNrKHdhc20pLCB7fSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaW5zdGFuY2UgPSByZXN1bHQuaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZXhwb3J0cy5fX3dhc21fY2FsbF9jdG9ycygpO1xuICB9KTtcbiAgZnVuY3Rpb24gdW5wYWNrKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHJlc3VsdFtpXSA9IGNoID4gOTYgPyBjaCAtIDcxIDogY2ggPiA2NCA/IGNoIC0gNjUgOiBjaCA+IDQ3ID8gY2ggKyA0IDogY2ggPiA0NiA/IDYzIDogNjI7XG4gICAgfVxuICAgIGxldCB3cml0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbd3JpdGUrK10gPSByZXN1bHRbaV0gPCA2MCA/IHdhc21wYWNrW3Jlc3VsdFtpXV0gOiAocmVzdWx0W2ldIC0gNjApICogNjQgKyByZXN1bHRbKytpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXIuc2xpY2UoMCwgd3JpdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShmdW4sIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc2JyayA9IGluc3RhbmNlLmV4cG9ydHMuc2JyaztcbiAgICBjb25zdCBjb3VudDQgPSBjb3VudCArIDMgJiB+MztcbiAgICBjb25zdCB0cCA9IHNicmsoY291bnQ0ICogc2l6ZSk7XG4gICAgY29uc3Qgc3AgPSBzYnJrKHNvdXJjZS5sZW5ndGgpO1xuICAgIGNvbnN0IGhlYXAgPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgIGhlYXAuc2V0KHNvdXJjZSwgc3ApO1xuICAgIGNvbnN0IHJlcyA9IGZ1bih0cCwgY291bnQsIHNpemUsIHNwLCBzb3VyY2UubGVuZ3RoKTtcbiAgICBpZiAocmVzID09PSAwICYmIGZpbHRlcikge1xuICAgICAgZmlsdGVyKHRwLCBjb3VudDQsIHNpemUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2V0KGhlYXAuc3ViYXJyYXkodHAsIHRwICsgY291bnQgKiBzaXplKSk7XG4gICAgc2Jyayh0cCAtIHNicmsoMCkpO1xuICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGJ1ZmZlciBkYXRhOiAke3Jlc31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmlsdGVycyA9IHtcbiAgICAvLyBsZWdhY3kgaW5kZXgtYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICAwOiBcIlwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIDM6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHBcIixcbiAgICAvLyBzdHJpbmctYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICBOT05FOiBcIlwiLFxuICAgIE9DVEFIRURSQUw6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICBRVUFURVJOSU9OOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIEVYUE9ORU5USUFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCJcbiAgfTtcbiAgY29uc3QgZGVjb2RlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIDI6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgQVRUUklCVVRFUzogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIFRSSUFOR0xFUzogXCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyXCIsXG4gICAgSU5ESUNFUzogXCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2VcIlxuICB9O1xuICBnZW5lcmF0ZWQgPSB7XG4gICAgcmVhZHk6IHByb21pc2UsXG4gICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgIGRlY29kZVZlcnRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4QnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlciwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4U2VxdWVuY2UodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gICAgICBkZWNvZGUoaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2UsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVHbHRmQnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgbW9kZSwgZmlsdGVyKSB7XG4gICAgICBkZWNvZGUoXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZGVjb2RlcnNbbW9kZV1dLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBnZW5lcmF0ZWQ7XG59O1xuZXhwb3J0IHtcbiAgTWVzaG9wdERlY29kZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNob3B0RGVjb2Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/Line2.js":
/*!**************************************************!*\
  !*** ./node_modules/three-stdlib/lines/Line2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line2: () => (/* binding */ Line2)\n/* harmony export */ });\n/* harmony import */ var _LineSegments2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegments2.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js\");\n/* harmony import */ var _LineGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js\");\n/* harmony import */ var _LineMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineMaterial.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\");\n\n\n\nclass Line2 extends _LineSegments2_js__WEBPACK_IMPORTED_MODULE_0__.LineSegments2 {\n  constructor(geometry = new _LineGeometry_js__WEBPACK_IMPORTED_MODULE_1__.LineGeometry(), material = new _LineMaterial_js__WEBPACK_IMPORTED_MODULE_2__.LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLine2 = true;\n    this.type = \"Line2\";\n  }\n}\n\n//# sourceMappingURL=Line2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmUyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUQ7QUFDRjtBQUNBO0FBQ2pELG9CQUFvQiw0REFBYTtBQUNqQyw2QkFBNkIsMERBQVksbUJBQW1CLDBEQUFZLEdBQUcsaUNBQWlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsaW5lc1xcTGluZTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGluZVNlZ21lbnRzMiB9IGZyb20gXCIuL0xpbmVTZWdtZW50czIuanNcIjtcbmltcG9ydCB7IExpbmVHZW9tZXRyeSB9IGZyb20gXCIuL0xpbmVHZW9tZXRyeS5qc1wiO1xuaW1wb3J0IHsgTGluZU1hdGVyaWFsIH0gZnJvbSBcIi4vTGluZU1hdGVyaWFsLmpzXCI7XG5jbGFzcyBMaW5lMiBleHRlbmRzIExpbmVTZWdtZW50czIge1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG5ldyBMaW5lR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgTGluZU1hdGVyaWFsKHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSB9KSkge1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdGhpcy5pc0xpbmUyID0gdHJ1ZTtcbiAgICB0aGlzLnR5cGUgPSBcIkxpbmUyXCI7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIExpbmUyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZTIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/Line2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineGeometry.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineGeometry: () => (/* binding */ LineGeometry)\n/* harmony export */ });\n/* harmony import */ var _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegmentsGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\");\n\nclass LineGeometry extends _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_0__.LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.isLineGeometry = true;\n    this.type = \"LineGeometry\";\n  }\n  setPositions(array) {\n    const length = array.length - 3;\n    const points = new Float32Array(2 * length);\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n    super.setPositions(points);\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    const length = array.length - itemSize;\n    const colors = new Float32Array(2 * length);\n    if (itemSize === 3) {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n      }\n    } else {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n        colors[2 * i + 6] = array[i + 6];\n        colors[2 * i + 7] = array[i + 7];\n      }\n    }\n    super.setColors(colors, itemSize);\n    return this;\n  }\n  fromLine(line) {\n    const geometry = line.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n}\n\n//# sourceMappingURL=LineGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVHZW9tZXRyeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTtBQUNqRSwyQkFBMkIsMEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsaW5lc1xcTGluZUdlb21ldHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmVTZWdtZW50c0dlb21ldHJ5IH0gZnJvbSBcIi4vTGluZVNlZ21lbnRzR2VvbWV0cnkuanNcIjtcbmNsYXNzIExpbmVHZW9tZXRyeSBleHRlbmRzIExpbmVTZWdtZW50c0dlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzTGluZUdlb21ldHJ5ID0gdHJ1ZTtcbiAgICB0aGlzLnR5cGUgPSBcIkxpbmVHZW9tZXRyeVwiO1xuICB9XG4gIHNldFBvc2l0aW9ucyhhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCAtIDM7XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgyICogbGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBwb2ludHNbMiAqIGldID0gYXJyYXlbaV07XG4gICAgICBwb2ludHNbMiAqIGkgKyAxXSA9IGFycmF5W2kgKyAxXTtcbiAgICAgIHBvaW50c1syICogaSArIDJdID0gYXJyYXlbaSArIDJdO1xuICAgICAgcG9pbnRzWzIgKiBpICsgM10gPSBhcnJheVtpICsgM107XG4gICAgICBwb2ludHNbMiAqIGkgKyA0XSA9IGFycmF5W2kgKyA0XTtcbiAgICAgIHBvaW50c1syICogaSArIDVdID0gYXJyYXlbaSArIDVdO1xuICAgIH1cbiAgICBzdXBlci5zZXRQb3NpdGlvbnMocG9pbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRDb2xvcnMoYXJyYXksIGl0ZW1TaXplID0gMykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCAtIGl0ZW1TaXplO1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGxlbmd0aCk7XG4gICAgaWYgKGl0ZW1TaXplID09PSAzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBpdGVtU2l6ZSkge1xuICAgICAgICBjb2xvcnNbMiAqIGldID0gYXJyYXlbaV07XG4gICAgICAgIGNvbG9yc1syICogaSArIDFdID0gYXJyYXlbaSArIDFdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyAyXSA9IGFycmF5W2kgKyAyXTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgM10gPSBhcnJheVtpICsgM107XG4gICAgICAgIGNvbG9yc1syICogaSArIDRdID0gYXJyYXlbaSArIDRdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyA1XSA9IGFycmF5W2kgKyA1XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaXRlbVNpemUpIHtcbiAgICAgICAgY29sb3JzWzIgKiBpXSA9IGFycmF5W2ldO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyAxXSA9IGFycmF5W2kgKyAxXTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgMl0gPSBhcnJheVtpICsgMl07XG4gICAgICAgIGNvbG9yc1syICogaSArIDNdID0gYXJyYXlbaSArIDNdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyA0XSA9IGFycmF5W2kgKyA0XTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgNV0gPSBhcnJheVtpICsgNV07XG4gICAgICAgIGNvbG9yc1syICogaSArIDZdID0gYXJyYXlbaSArIDZdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyA3XSA9IGFycmF5W2kgKyA3XTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuc2V0Q29sb3JzKGNvbG9ycywgaXRlbVNpemUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21MaW5lKGxpbmUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGxpbmUuZ2VvbWV0cnk7XG4gICAgdGhpcy5zZXRQb3NpdGlvbnMoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIExpbmVHZW9tZXRyeVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVHZW9tZXRyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineMaterial.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineMaterial: () => (/* binding */ LineMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nclass LineMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: \"LineMaterial\",\n      uniforms: three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(\n        three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.merge([\n          three__WEBPACK_IMPORTED_MODULE_1__.UniformsLib.common,\n          three__WEBPACK_IMPORTED_MODULE_1__.UniformsLib.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }\n            // todo FIX - maybe change to totalSize\n          }\n        ])\n      ),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      clipping: true\n      // required for clipping support\n    });\n    this.isLineMaterial = true;\n    this.onBeforeCompile = function() {\n      if (this.transparent) {\n        this.defines.USE_LINE_COLOR_ALPHA = \"1\";\n      } else {\n        delete this.defines.USE_LINE_COLOR_ALPHA;\n      }\n    };\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function(value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function() {\n          return \"WORLD_UNITS\" in this.defines;\n        },\n        set: function(value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = \"\";\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function() {\n          return Boolean(\"USE_DASH\" in this.defines);\n        },\n        set(value) {\n          if (Boolean(value) !== Boolean(\"USE_DASH\" in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_DASH = \"\";\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.resolution.value;\n        },\n        set: function(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function() {\n          return Boolean(\"USE_ALPHA_TO_COVERAGE\" in this.defines);\n        },\n        set: function(value) {\n          if (Boolean(value) !== Boolean(\"USE_ALPHA_TO_COVERAGE\" in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = \"\";\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\n\n//# sourceMappingURL=LineMaterial.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRFO0FBQ3hCO0FBQ3BELDJCQUEyQixpREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWE7QUFDN0IsUUFBUSxnREFBYTtBQUNyQixVQUFVLDhDQUFXO0FBQ3JCLFVBQVUsOENBQVc7QUFDckI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQyx5QkFBeUIsVUFBVTtBQUNuQywwQkFBMEIsV0FBVywwQ0FBTyxRQUFRO0FBQ3BELDBCQUEwQixVQUFVO0FBQ3BDLHlCQUF5QixVQUFVO0FBQ25DLHdCQUF3QixVQUFVO0FBQ2xDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1EOztBQUVuRCx1RkFBdUY7O0FBRXZGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLDJEQUFPLHVEQUF1RDtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdG9tYXNcXFByb2plY3RzXFxjcmVhdGl2ZVxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXGxpbmVzXFxMaW5lTWF0ZXJpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm1zVXRpbHMsIFVuaWZvcm1zTGliLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9jb25zdGFudHMuanNcIjtcbmNsYXNzIExpbmVNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6IFwiTGluZU1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3JtczogVW5pZm9ybXNVdGlscy5jbG9uZShcbiAgICAgICAgVW5pZm9ybXNVdGlscy5tZXJnZShbXG4gICAgICAgICAgVW5pZm9ybXNMaWIuY29tbW9uLFxuICAgICAgICAgIFVuaWZvcm1zTGliLmZvZyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3b3JsZFVuaXRzOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBsaW5ld2lkdGg6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgIHJlc29sdXRpb246IHsgdmFsdWU6IG5ldyBWZWN0b3IyKDEsIDEpIH0sXG4gICAgICAgICAgICBkYXNoT2Zmc2V0OiB7IHZhbHVlOiAwIH0sXG4gICAgICAgICAgICBkYXNoU2NhbGU6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgIGRhc2hTaXplOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBnYXBTaXplOiB7IHZhbHVlOiAxIH1cbiAgICAgICAgICAgIC8vIHRvZG8gRklYIC0gbWF5YmUgY2hhbmdlIHRvIHRvdGFsU2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgICksXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IChcbiAgICAgICAgLyogZ2xzbCAqL1xuICAgICAgICBgXG5cdFx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cdFx0XHRcdCNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XG5cdFx0XHRcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cblx0XHRcdFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cblxuXHRcdFx0XHR1bmlmb3JtIGZsb2F0IGxpbmV3aWR0aDtcblx0XHRcdFx0dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG5cblx0XHRcdFx0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTdGFydDtcblx0XHRcdFx0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VFbmQ7XG5cblx0XHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxuXHRcdFx0XHRcdCNpZmRlZiBVU0VfTElORV9DT0xPUl9BTFBIQVxuXHRcdFx0XHRcdFx0dmFyeWluZyB2ZWM0IHZMaW5lQ29sb3I7XG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9yU3RhcnQ7XG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9yRW5kO1xuXHRcdFx0XHRcdCNlbHNlXG5cdFx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgdkxpbmVDb2xvcjtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3JTdGFydDtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3JFbmQ7XG5cdFx0XHRcdFx0I2VuZGlmXG5cdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdCNpZmRlZiBXT1JMRF9VTklUU1xuXG5cdFx0XHRcdFx0dmFyeWluZyB2ZWM0IHdvcmxkUG9zO1xuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMyB3b3JsZFN0YXJ0O1xuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMyB3b3JsZEVuZDtcblxuXHRcdFx0XHRcdCNpZmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0I2Vsc2VcblxuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMiB2VXY7XG5cblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0XHR1bmlmb3JtIGZsb2F0IGRhc2hTY2FsZTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VEaXN0YW5jZVN0YXJ0O1xuXHRcdFx0XHRcdGF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZURpc3RhbmNlRW5kO1xuXHRcdFx0XHRcdHZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcblxuXHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHR2b2lkIHRyaW1TZWdtZW50KCBjb25zdCBpbiB2ZWM0IHN0YXJ0LCBpbm91dCB2ZWM0IGVuZCApIHtcblxuXHRcdFx0XHRcdC8vIHRyaW0gZW5kIHNlZ21lbnQgc28gaXQgdGVybWluYXRlcyBiZXR3ZWVuIHRoZSBjYW1lcmEgcGxhbmUgYW5kIHRoZSBuZWFyIHBsYW5lXG5cblx0XHRcdFx0XHQvLyBjb25zZXJ2YXRpdmUgZXN0aW1hdGUgb2YgdGhlIG5lYXIgcGxhbmVcblx0XHRcdFx0XHRmbG9hdCBhID0gcHJvamVjdGlvbk1hdHJpeFsgMiBdWyAyIF07IC8vIDNuZCBlbnRyeSBpbiAzdGggY29sdW1uXG5cdFx0XHRcdFx0ZmxvYXQgYiA9IHByb2plY3Rpb25NYXRyaXhbIDMgXVsgMiBdOyAvLyAzbmQgZW50cnkgaW4gNHRoIGNvbHVtblxuXHRcdFx0XHRcdGZsb2F0IG5lYXJFc3RpbWF0ZSA9IC0gMC41ICogYiAvIGE7XG5cblx0XHRcdFx0XHRmbG9hdCBhbHBoYSA9ICggbmVhckVzdGltYXRlIC0gc3RhcnQueiApIC8gKCBlbmQueiAtIHN0YXJ0LnogKTtcblxuXHRcdFx0XHRcdGVuZC54eXogPSBtaXgoIHN0YXJ0Lnh5eiwgZW5kLnh5eiwgYWxwaGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxuXG5cdFx0XHRcdFx0XHR2TGluZUNvbG9yID0gKCBwb3NpdGlvbi55IDwgMC41ICkgPyBpbnN0YW5jZUNvbG9yU3RhcnQgOiBpbnN0YW5jZUNvbG9yRW5kO1xuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHQjaWZkZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdFx0dkxpbmVEaXN0YW5jZSA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gZGFzaFNjYWxlICogaW5zdGFuY2VEaXN0YW5jZVN0YXJ0IDogZGFzaFNjYWxlICogaW5zdGFuY2VEaXN0YW5jZUVuZDtcblx0XHRcdFx0XHRcdHZVdiA9IHV2O1xuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHRmbG9hdCBhc3BlY3QgPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XG5cblx0XHRcdFx0XHQvLyBjYW1lcmEgc3BhY2Vcblx0XHRcdFx0XHR2ZWM0IHN0YXJ0ID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggaW5zdGFuY2VTdGFydCwgMS4wICk7XG5cdFx0XHRcdFx0dmVjNCBlbmQgPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBpbnN0YW5jZUVuZCwgMS4wICk7XG5cblx0XHRcdFx0XHQjaWZkZWYgV09STERfVU5JVFNcblxuXHRcdFx0XHRcdFx0d29ybGRTdGFydCA9IHN0YXJ0Lnh5ejtcblx0XHRcdFx0XHRcdHdvcmxkRW5kID0gZW5kLnh5ejtcblxuXHRcdFx0XHRcdCNlbHNlXG5cblx0XHRcdFx0XHRcdHZVdiA9IHV2O1xuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIHBlcnNwZWN0aXZlIHByb2plY3Rpb24sIGFuZCBzZWdtZW50cyB0aGF0IHRlcm1pbmF0ZSBlaXRoZXIgaW4sIG9yIGJlaGluZCwgdGhlIGNhbWVyYSBwbGFuZVxuXHRcdFx0XHRcdC8vIGNsZWFybHkgdGhlIGdwdSBmaXJtd2FyZSBoYXMgYSB3YXkgb2YgYWRkcmVzc2luZyB0aGlzIGlzc3VlIHdoZW4gcHJvamVjdGluZyBpbnRvIG5kYyBzcGFjZVxuXHRcdFx0XHRcdC8vIGJ1dCB3ZSBuZWVkIHRvIHBlcmZvcm0gbmRjLXNwYWNlIGNhbGN1bGF0aW9ucyBpbiB0aGUgc2hhZGVyLCBzbyB3ZSBtdXN0IGFkZHJlc3MgdGhpcyBpc3N1ZSBkaXJlY3RseVxuXHRcdFx0XHRcdC8vIHBlcmhhcHMgdGhlcmUgaXMgYSBtb3JlIGVsZWdhbnQgc29sdXRpb24gLS0gV2VzdExhbmdsZXlcblxuXHRcdFx0XHRcdGJvb2wgcGVyc3BlY3RpdmUgPSAoIHByb2plY3Rpb25NYXRyaXhbIDIgXVsgMyBdID09IC0gMS4wICk7IC8vIDR0aCBlbnRyeSBpbiB0aGUgM3JkIGNvbHVtblxuXG5cdFx0XHRcdFx0aWYgKCBwZXJzcGVjdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzdGFydC56IDwgMC4wICYmIGVuZC56ID49IDAuMCApIHtcblxuXHRcdFx0XHRcdFx0XHR0cmltU2VnbWVudCggc3RhcnQsIGVuZCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbmQueiA8IDAuMCAmJiBzdGFydC56ID49IDAuMCApIHtcblxuXHRcdFx0XHRcdFx0XHR0cmltU2VnbWVudCggZW5kLCBzdGFydCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBjbGlwIHNwYWNlXG5cdFx0XHRcdFx0dmVjNCBjbGlwU3RhcnQgPSBwcm9qZWN0aW9uTWF0cml4ICogc3RhcnQ7XG5cdFx0XHRcdFx0dmVjNCBjbGlwRW5kID0gcHJvamVjdGlvbk1hdHJpeCAqIGVuZDtcblxuXHRcdFx0XHRcdC8vIG5kYyBzcGFjZVxuXHRcdFx0XHRcdHZlYzMgbmRjU3RhcnQgPSBjbGlwU3RhcnQueHl6IC8gY2xpcFN0YXJ0Lnc7XG5cdFx0XHRcdFx0dmVjMyBuZGNFbmQgPSBjbGlwRW5kLnh5eiAvIGNsaXBFbmQudztcblxuXHRcdFx0XHRcdC8vIGRpcmVjdGlvblxuXHRcdFx0XHRcdHZlYzIgZGlyID0gbmRjRW5kLnh5IC0gbmRjU3RhcnQueHk7XG5cblx0XHRcdFx0XHQvLyBhY2NvdW50IGZvciBjbGlwLXNwYWNlIGFzcGVjdCByYXRpb1xuXHRcdFx0XHRcdGRpci54ICo9IGFzcGVjdDtcblx0XHRcdFx0XHRkaXIgPSBub3JtYWxpemUoIGRpciApO1xuXG5cdFx0XHRcdFx0I2lmZGVmIFdPUkxEX1VOSVRTXG5cblx0XHRcdFx0XHRcdC8vIGdldCB0aGUgb2Zmc2V0IGRpcmVjdGlvbiBhcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSB2aWV3IHZlY3RvclxuXHRcdFx0XHRcdFx0dmVjMyB3b3JsZERpciA9IG5vcm1hbGl6ZSggZW5kLnh5eiAtIHN0YXJ0Lnh5eiApO1xuXHRcdFx0XHRcdFx0dmVjMyBvZmZzZXQ7XG5cdFx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPCAwLjUgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gbm9ybWFsaXplKCBjcm9zcyggc3RhcnQueHl6LCB3b3JsZERpciApICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gbm9ybWFsaXplKCBjcm9zcyggZW5kLnh5eiwgd29ybGREaXIgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHNpZ24gZmxpcFxuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi54IDwgMC4wICkgb2Zmc2V0ICo9IC0gMS4wO1xuXG5cdFx0XHRcdFx0XHRmbG9hdCBmb3J3YXJkT2Zmc2V0ID0gZG90KCB3b3JsZERpciwgdmVjMyggMC4wLCAwLjAsIDEuMCApICk7XG5cblx0XHRcdFx0XHRcdC8vIGRvbid0IGV4dGVuZCB0aGUgbGluZSBpZiB3ZSdyZSByZW5kZXJpbmcgZGFzaGVzIGJlY2F1c2Ugd2Vcblx0XHRcdFx0XHRcdC8vIHdvbid0IGJlIHJlbmRlcmluZyB0aGUgZW5kY2Fwc1xuXHRcdFx0XHRcdFx0I2lmbmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0XHRcdC8vIGV4dGVuZCB0aGUgbGluZSBib3VuZHMgdG8gZW5jb21wYXNzICBlbmRjYXBzXG5cdFx0XHRcdFx0XHRcdHN0YXJ0Lnh5eiArPSAtIHdvcmxkRGlyICogbGluZXdpZHRoICogMC41O1xuXHRcdFx0XHRcdFx0XHRlbmQueHl6ICs9IHdvcmxkRGlyICogbGluZXdpZHRoICogMC41O1xuXG5cdFx0XHRcdFx0XHRcdC8vIHNoaWZ0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcXVhZCBzbyBpdCBodWdzIHRoZSBmb3J3YXJkIGVkZ2Ugb2YgdGhlIGxpbmVcblx0XHRcdFx0XHRcdFx0b2Zmc2V0Lnh5IC09IGRpciAqIGZvcndhcmRPZmZzZXQ7XG5cdFx0XHRcdFx0XHRcdG9mZnNldC56ICs9IDAuNTtcblxuXHRcdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHRcdC8vIGVuZGNhcHNcblx0XHRcdFx0XHRcdGlmICggcG9zaXRpb24ueSA+IDEuMCB8fCBwb3NpdGlvbi55IDwgMC4wICkge1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldC54eSArPSBkaXIgKiAyLjAgKiBmb3J3YXJkT2Zmc2V0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBmb3IgbGluZXdpZHRoXG5cdFx0XHRcdFx0XHRvZmZzZXQgKj0gbGluZXdpZHRoICogMC41O1xuXG5cdFx0XHRcdFx0XHQvLyBzZXQgdGhlIHdvcmxkIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHR3b3JsZFBvcyA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gc3RhcnQgOiBlbmQ7XG5cdFx0XHRcdFx0XHR3b3JsZFBvcy54eXogKz0gb2Zmc2V0O1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9qZWN0IHRoZSB3b3JsZHBvc1xuXHRcdFx0XHRcdFx0dmVjNCBjbGlwID0gcHJvamVjdGlvbk1hdHJpeCAqIHdvcmxkUG9zO1xuXG5cdFx0XHRcdFx0XHQvLyBzaGlmdCB0aGUgZGVwdGggb2YgdGhlIHByb2plY3RlZCBwb2ludHMgc28gdGhlIGxpbmVcblx0XHRcdFx0XHRcdC8vIHNlZ21lbnRzIG92ZXJsYXAgbmVhdGx5XG5cdFx0XHRcdFx0XHR2ZWMzIGNsaXBQb3NlID0gKCBwb3NpdGlvbi55IDwgMC41ICkgPyBuZGNTdGFydCA6IG5kY0VuZDtcblx0XHRcdFx0XHRcdGNsaXAueiA9IGNsaXBQb3NlLnogKiBjbGlwLnc7XG5cblx0XHRcdFx0XHQjZWxzZVxuXG5cdFx0XHRcdFx0XHR2ZWMyIG9mZnNldCA9IHZlYzIoIGRpci55LCAtIGRpci54ICk7XG5cdFx0XHRcdFx0XHQvLyB1bmRvIGFzcGVjdCByYXRpbyBhZGp1c3RtZW50XG5cdFx0XHRcdFx0XHRkaXIueCAvPSBhc3BlY3Q7XG5cdFx0XHRcdFx0XHRvZmZzZXQueCAvPSBhc3BlY3Q7XG5cblx0XHRcdFx0XHRcdC8vIHNpZ24gZmxpcFxuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi54IDwgMC4wICkgb2Zmc2V0ICo9IC0gMS4wO1xuXG5cdFx0XHRcdFx0XHQvLyBlbmRjYXBzXG5cdFx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPCAwLjAgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IC0gZGlyO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbi55ID4gMS4wICkge1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBkaXI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gYWRqdXN0IGZvciBsaW5ld2lkdGhcblx0XHRcdFx0XHRcdG9mZnNldCAqPSBsaW5ld2lkdGg7XG5cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBmb3IgY2xpcC1zcGFjZSB0byBzY3JlZW4tc3BhY2UgY29udmVyc2lvbiAvLyBtYXliZSByZXNvbHV0aW9uIHNob3VsZCBiZSBiYXNlZCBvbiB2aWV3cG9ydCAuLi5cblx0XHRcdFx0XHRcdG9mZnNldCAvPSByZXNvbHV0aW9uLnk7XG5cblx0XHRcdFx0XHRcdC8vIHNlbGVjdCBlbmRcblx0XHRcdFx0XHRcdHZlYzQgY2xpcCA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gY2xpcFN0YXJ0IDogY2xpcEVuZDtcblxuXHRcdFx0XHRcdFx0Ly8gYmFjayB0byBjbGlwIHNwYWNlXG5cdFx0XHRcdFx0XHRvZmZzZXQgKj0gY2xpcC53O1xuXG5cdFx0XHRcdFx0XHRjbGlwLnh5ICs9IG9mZnNldDtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0Z2xfUG9zaXRpb24gPSBjbGlwO1xuXG5cdFx0XHRcdFx0dmVjNCBtdlBvc2l0aW9uID0gKCBwb3NpdGlvbi55IDwgMC41ICkgPyBzdGFydCA6IGVuZDsgLy8gdGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uXG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxuXG5cdFx0XHRcdH1cblx0XHRcdGBcbiAgICAgICksXG4gICAgICBmcmFnbWVudFNoYWRlcjogKFxuICAgICAgICAvKiBnbHNsICovXG4gICAgICAgIGBcblx0XHRcdFx0dW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XG5cdFx0XHRcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcblx0XHRcdFx0dW5pZm9ybSBmbG9hdCBsaW5ld2lkdGg7XG5cblx0XHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0XHR1bmlmb3JtIGZsb2F0IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcblx0XHRcdFx0XHR1bmlmb3JtIGZsb2F0IGdhcFNpemU7XG5cblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0dmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xuXG5cdFx0XHRcdCNpZmRlZiBXT1JMRF9VTklUU1xuXG5cdFx0XHRcdFx0dmFyeWluZyB2ZWM0IHdvcmxkUG9zO1xuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMyB3b3JsZFN0YXJ0O1xuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMyB3b3JsZEVuZDtcblxuXHRcdFx0XHRcdCNpZmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0I2Vsc2VcblxuXHRcdFx0XHRcdHZhcnlpbmcgdmVjMiB2VXY7XG5cblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0I2luY2x1ZGUgPGNvbW1vbj5cblx0XHRcdFx0I2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxuXHRcdFx0XHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cblx0XHRcdFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxuXG5cdFx0XHRcdCNpZmRlZiBVU0VfQ09MT1Jcblx0XHRcdFx0XHQjaWZkZWYgVVNFX0xJTkVfQ09MT1JfQUxQSEFcblx0XHRcdFx0XHRcdHZhcnlpbmcgdmVjNCB2TGluZUNvbG9yO1xuXHRcdFx0XHRcdCNlbHNlXG5cdFx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgdkxpbmVDb2xvcjtcblx0XHRcdFx0XHQjZW5kaWZcblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0dmVjMiBjbG9zZXN0TGluZVRvTGluZSh2ZWMzIHAxLCB2ZWMzIHAyLCB2ZWMzIHAzLCB2ZWMzIHA0KSB7XG5cblx0XHRcdFx0XHRmbG9hdCBtdWE7XG5cdFx0XHRcdFx0ZmxvYXQgbXViO1xuXG5cdFx0XHRcdFx0dmVjMyBwMTMgPSBwMSAtIHAzO1xuXHRcdFx0XHRcdHZlYzMgcDQzID0gcDQgLSBwMztcblxuXHRcdFx0XHRcdHZlYzMgcDIxID0gcDIgLSBwMTtcblxuXHRcdFx0XHRcdGZsb2F0IGQxMzQzID0gZG90KCBwMTMsIHA0MyApO1xuXHRcdFx0XHRcdGZsb2F0IGQ0MzIxID0gZG90KCBwNDMsIHAyMSApO1xuXHRcdFx0XHRcdGZsb2F0IGQxMzIxID0gZG90KCBwMTMsIHAyMSApO1xuXHRcdFx0XHRcdGZsb2F0IGQ0MzQzID0gZG90KCBwNDMsIHA0MyApO1xuXHRcdFx0XHRcdGZsb2F0IGQyMTIxID0gZG90KCBwMjEsIHAyMSApO1xuXG5cdFx0XHRcdFx0ZmxvYXQgZGVub20gPSBkMjEyMSAqIGQ0MzQzIC0gZDQzMjEgKiBkNDMyMTtcblxuXHRcdFx0XHRcdGZsb2F0IG51bWVyID0gZDEzNDMgKiBkNDMyMSAtIGQxMzIxICogZDQzNDM7XG5cblx0XHRcdFx0XHRtdWEgPSBudW1lciAvIGRlbm9tO1xuXHRcdFx0XHRcdG11YSA9IGNsYW1wKCBtdWEsIDAuMCwgMS4wICk7XG5cdFx0XHRcdFx0bXViID0gKCBkMTM0MyArIGQ0MzIxICogKCBtdWEgKSApIC8gZDQzNDM7XG5cdFx0XHRcdFx0bXViID0gY2xhbXAoIG11YiwgMC4wLCAxLjAgKTtcblxuXHRcdFx0XHRcdHJldHVybiB2ZWMyKCBtdWEsIG11YiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxuXG5cdFx0XHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0XHRcdGlmICggdlV2LnkgPCAtIDEuMCB8fCB2VXYueSA+IDEuMCApIGRpc2NhcmQ7IC8vIGRpc2NhcmQgZW5kY2Fwc1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSArIGRhc2hPZmZzZXQsIGRhc2hTaXplICsgZ2FwU2l6ZSApID4gZGFzaFNpemUgKSBkaXNjYXJkOyAvLyB0b2RvIC0gRklYXG5cblx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdGZsb2F0IGFscGhhID0gb3BhY2l0eTtcblxuXHRcdFx0XHRcdCNpZmRlZiBXT1JMRF9VTklUU1xuXG5cdFx0XHRcdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IHBvaW50cyBvbiB0aGUgdmlldyByYXkgYW5kIHRoZSBsaW5lIHNlZ21lbnRcblx0XHRcdFx0XHRcdHZlYzMgcmF5RW5kID0gbm9ybWFsaXplKCB3b3JsZFBvcy54eXogKSAqIDFlNTtcblx0XHRcdFx0XHRcdHZlYzMgbGluZURpciA9IHdvcmxkRW5kIC0gd29ybGRTdGFydDtcblx0XHRcdFx0XHRcdHZlYzIgcGFyYW1zID0gY2xvc2VzdExpbmVUb0xpbmUoIHdvcmxkU3RhcnQsIHdvcmxkRW5kLCB2ZWMzKCAwLjAsIDAuMCwgMC4wICksIHJheUVuZCApO1xuXG5cdFx0XHRcdFx0XHR2ZWMzIHAxID0gd29ybGRTdGFydCArIGxpbmVEaXIgKiBwYXJhbXMueDtcblx0XHRcdFx0XHRcdHZlYzMgcDIgPSByYXlFbmQgKiBwYXJhbXMueTtcblx0XHRcdFx0XHRcdHZlYzMgZGVsdGEgPSBwMSAtIHAyO1xuXHRcdFx0XHRcdFx0ZmxvYXQgbGVuID0gbGVuZ3RoKCBkZWx0YSApO1xuXHRcdFx0XHRcdFx0ZmxvYXQgbm9ybSA9IGxlbiAvIGxpbmV3aWR0aDtcblxuXHRcdFx0XHRcdFx0I2lmbmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0XHRcdCNpZmRlZiBVU0VfQUxQSEFfVE9fQ09WRVJBR0VcblxuXHRcdFx0XHRcdFx0XHRcdGZsb2F0IGRub3JtID0gZndpZHRoKCBub3JtICk7XG5cdFx0XHRcdFx0XHRcdFx0YWxwaGEgPSAxLjAgLSBzbW9vdGhzdGVwKCAwLjUgLSBkbm9ybSwgMC41ICsgZG5vcm0sIG5vcm0gKTtcblxuXHRcdFx0XHRcdFx0XHQjZWxzZVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub3JtID4gMC41ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNjYXJkO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdCNlbHNlXG5cblx0XHRcdFx0XHRcdCNpZmRlZiBVU0VfQUxQSEFfVE9fQ09WRVJBR0VcblxuXHRcdFx0XHRcdFx0XHQvLyBhcnRpZmFjdHMgYXBwZWFyIG9uIHNvbWUgaGFyZHdhcmUgaWYgYSBkZXJpdmF0aXZlIGlzIHRha2VuIHdpdGhpbiBhIGNvbmRpdGlvbmFsXG5cdFx0XHRcdFx0XHRcdGZsb2F0IGEgPSB2VXYueDtcblx0XHRcdFx0XHRcdFx0ZmxvYXQgYiA9ICggdlV2LnkgPiAwLjAgKSA/IHZVdi55IC0gMS4wIDogdlV2LnkgKyAxLjA7XG5cdFx0XHRcdFx0XHRcdGZsb2F0IGxlbjIgPSBhICogYSArIGIgKiBiO1xuXHRcdFx0XHRcdFx0XHRmbG9hdCBkbGVuID0gZndpZHRoKCBsZW4yICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBhYnMoIHZVdi55ICkgPiAxLjAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoIDEuMCAtIGRsZW4sIDEuMCArIGRsZW4sIGxlbjIgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdCNlbHNlXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBhYnMoIHZVdi55ICkgPiAxLjAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmbG9hdCBhID0gdlV2Lng7XG5cdFx0XHRcdFx0XHRcdFx0ZmxvYXQgYiA9ICggdlV2LnkgPiAwLjAgKSA/IHZVdi55IC0gMS4wIDogdlV2LnkgKyAxLjA7XG5cdFx0XHRcdFx0XHRcdFx0ZmxvYXQgbGVuMiA9IGEgKiBhICsgYiAqIGI7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGxlbjIgPiAxLjAgKSBkaXNjYXJkO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgYWxwaGEgKTtcblx0XHRcdFx0XHQjaWZkZWYgVVNFX0NPTE9SXG5cdFx0XHRcdFx0XHQjaWZkZWYgVVNFX0xJTkVfQ09MT1JfQUxQSEFcblx0XHRcdFx0XHRcdFx0ZGlmZnVzZUNvbG9yICo9IHZMaW5lQ29sb3I7XG5cdFx0XHRcdFx0XHQjZWxzZVxuXHRcdFx0XHRcdFx0XHRkaWZmdXNlQ29sb3IucmdiICo9IHZMaW5lQ29sb3I7XG5cdFx0XHRcdFx0XHQjZW5kaWZcblx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cblxuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGRpZmZ1c2VDb2xvcjtcblxuXHRcdFx0XHRcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8JHt2ZXJzaW9uID49IDE1NCA/IFwiY29sb3JzcGFjZV9mcmFnbWVudFwiIDogXCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XG5cdFx0XHRcdFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblxuXHRcdFx0XHR9XG5cdFx0XHRgXG4gICAgICApLFxuICAgICAgY2xpcHBpbmc6IHRydWVcbiAgICAgIC8vIHJlcXVpcmVkIGZvciBjbGlwcGluZyBzdXBwb3J0XG4gICAgfSk7XG4gICAgdGhpcy5pc0xpbmVNYXRlcmlhbCA9IHRydWU7XG4gICAgdGhpcy5vbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5VU0VfTElORV9DT0xPUl9BTFBIQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfTElORV9DT0xPUl9BTFBIQTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlmZnVzZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd29ybGRVbml0czoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBcIldPUkxEX1VOSVRTXCIgaW4gdGhpcy5kZWZpbmVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuV09STERfVU5JVFMgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLldPUkxEX1VOSVRTO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmV3aWR0aDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmxpbmV3aWR0aC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMubGluZXdpZHRoLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkYXNoZWQ6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQm9vbGVhbihcIlVTRV9EQVNIXCIgaW4gdGhpcy5kZWZpbmVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpICE9PSBCb29sZWFuKFwiVVNFX0RBU0hcIiBpbiB0aGlzLmRlZmluZXMpKSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVVNFX0RBU0ggPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9EQVNIO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hTY2FsZToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRhc2hTY2FsZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaFNjYWxlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkYXNoU2l6ZToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRhc2hTaXplLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGFzaE9mZnNldDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRhc2hPZmZzZXQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRhc2hPZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdhcFNpemU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYXBTaXplLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5nYXBTaXplLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzb2x1dGlvbjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuY29weSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbHBoYVRvQ292ZXJhZ2U6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQm9vbGVhbihcIlVTRV9BTFBIQV9UT19DT1ZFUkFHRVwiIGluIHRoaXMuZGVmaW5lcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgIT09IEJvb2xlYW4oXCJVU0VfQUxQSEFfVE9fQ09WRVJBR0VcIiBpbiB0aGlzLmRlZmluZXMpKSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVVNFX0FMUEhBX1RPX0NPVkVSQUdFID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX0FMUEhBX1RPX0NPVkVSQUdFO1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIExpbmVNYXRlcmlhbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVNYXRlcmlhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineSegments2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineSegments2: () => (/* binding */ LineSegments2)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineSegmentsGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\");\n/* harmony import */ var _LineMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineMaterial.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\");\n/* harmony import */ var _polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/uv1.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js\");\n\n\n\n\nconst _viewport = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _start = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _end = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _start4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _end4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _ssOrigin = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _ssOrigin3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _mvMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _line = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\nconst _closestPoint = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _box = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst _sphere = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\nconst _clipToWorldVector = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [_polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__.UV1]: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [_polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__.UV1]: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  constructor(geometry = new _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_2__.LineSegmentsGeometry(), material = new _LineMaterial_js__WEBPACK_IMPORTED_MODULE_3__.LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'\n      );\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\n\n//# sourceMappingURL=LineSegments2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVTZWdtZW50czIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0o7QUFDL0U7QUFDaEI7QUFDUDtBQUMxQyxzQ0FBc0MsMENBQU87QUFDN0MsbUNBQW1DLDBDQUFPO0FBQzFDLGlDQUFpQywwQ0FBTztBQUN4QyxvQ0FBb0MsMENBQU87QUFDM0Msa0NBQWtDLDBDQUFPO0FBQ3pDLHNDQUFzQywwQ0FBTztBQUM3Qyx1Q0FBdUMsMENBQU87QUFDOUMsc0NBQXNDLDBDQUFPO0FBQzdDLGtDQUFrQyx3Q0FBSztBQUN2QywwQ0FBMEMsMENBQU87QUFDakQsaUNBQWlDLHVDQUFJO0FBQ3JDLG9DQUFvQyx5Q0FBTTtBQUMxQywrQ0FBK0MsMENBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQU87QUFDbkMsc0JBQXNCLDBDQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFHO0FBQ1osT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBTztBQUNyQyx3QkFBd0IsMENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBRztBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQUk7QUFDaEMsNkJBQTZCLDBFQUFvQixtQkFBbUIsMERBQVksR0FBRyxpQ0FBaUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZEQUEwQjtBQUNqRSx1REFBdUQsNkRBQTBCO0FBQ2pGLHFEQUFxRCw2REFBMEI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0b21hc1xcUHJvamVjdHNcXGNyZWF0aXZlXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbGluZXNcXExpbmVTZWdtZW50czIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzaCwgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBWZWN0b3I0LCBWZWN0b3IzLCBCb3gzLCBTcGhlcmUsIE1hdGhVdGlscywgTWF0cml4NCwgTGluZTMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IExpbmVTZWdtZW50c0dlb21ldHJ5IH0gZnJvbSBcIi4vTGluZVNlZ21lbnRzR2VvbWV0cnkuanNcIjtcbmltcG9ydCB7IExpbmVNYXRlcmlhbCB9IGZyb20gXCIuL0xpbmVNYXRlcmlhbC5qc1wiO1xuaW1wb3J0IHsgVVYxIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC91djEuanNcIjtcbmNvbnN0IF92aWV3cG9ydCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3N0YXJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfc3RhcnQ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3I0KCk7XG5jb25zdCBfZW5kNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3NzT3JpZ2luID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3I0KCk7XG5jb25zdCBfc3NPcmlnaW4zID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbXZNYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9saW5lID0gLyogQF9fUFVSRV9fICovIG5ldyBMaW5lMygpO1xuY29uc3QgX2Nsb3Nlc3RQb2ludCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQm94MygpO1xuY29uc3QgX3NwaGVyZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfY2xpcFRvV29ybGRWZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjQoKTtcbmxldCBfcmF5LCBfbGluZVdpZHRoO1xuZnVuY3Rpb24gZ2V0V29ybGRTcGFjZUhhbGZXaWR0aChjYW1lcmEsIGRpc3RhbmNlLCByZXNvbHV0aW9uKSB7XG4gIF9jbGlwVG9Xb3JsZFZlY3Rvci5zZXQoMCwgMCwgLWRpc3RhbmNlLCAxKS5hcHBseU1hdHJpeDQoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuICBfY2xpcFRvV29ybGRWZWN0b3IubXVsdGlwbHlTY2FsYXIoMSAvIF9jbGlwVG9Xb3JsZFZlY3Rvci53KTtcbiAgX2NsaXBUb1dvcmxkVmVjdG9yLnggPSBfbGluZVdpZHRoIC8gcmVzb2x1dGlvbi53aWR0aDtcbiAgX2NsaXBUb1dvcmxkVmVjdG9yLnkgPSBfbGluZVdpZHRoIC8gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gIF9jbGlwVG9Xb3JsZFZlY3Rvci5hcHBseU1hdHJpeDQoY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtcbiAgX2NsaXBUb1dvcmxkVmVjdG9yLm11bHRpcGx5U2NhbGFyKDEgLyBfY2xpcFRvV29ybGRWZWN0b3Iudyk7XG4gIHJldHVybiBNYXRoLmFicyhNYXRoLm1heChfY2xpcFRvV29ybGRWZWN0b3IueCwgX2NsaXBUb1dvcmxkVmVjdG9yLnkpKTtcbn1cbmZ1bmN0aW9uIHJheWNhc3RXb3JsZFVuaXRzKGxpbmVTZWdtZW50cywgaW50ZXJzZWN0cykge1xuICBjb25zdCBtYXRyaXhXb3JsZCA9IGxpbmVTZWdtZW50cy5tYXRyaXhXb3JsZDtcbiAgY29uc3QgZ2VvbWV0cnkgPSBsaW5lU2VnbWVudHMuZ2VvbWV0cnk7XG4gIGNvbnN0IGluc3RhbmNlU3RhcnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gIGNvbnN0IGluc3RhbmNlRW5kID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgY29uc3Qgc2VnbWVudENvdW50ID0gTWF0aC5taW4oZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCwgaW5zdGFuY2VTdGFydC5jb3VudCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc2VnbWVudENvdW50OyBpIDwgbDsgaSsrKSB7XG4gICAgX2xpbmUuc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICBfbGluZS5lbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZUVuZCwgaSk7XG4gICAgX2xpbmUuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICBjb25zdCBwb2ludE9uTGluZSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIF9yYXkuZGlzdGFuY2VTcVRvU2VnbWVudChfbGluZS5zdGFydCwgX2xpbmUuZW5kLCBwb2ludCwgcG9pbnRPbkxpbmUpO1xuICAgIGNvbnN0IGlzSW5zaWRlID0gcG9pbnQuZGlzdGFuY2VUbyhwb2ludE9uTGluZSkgPCBfbGluZVdpZHRoICogMC41O1xuICAgIGlmIChpc0luc2lkZSkge1xuICAgICAgaW50ZXJzZWN0cy5wdXNoKHtcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50T25MaW5lLFxuICAgICAgICBkaXN0YW5jZTogX3JheS5vcmlnaW4uZGlzdGFuY2VUbyhwb2ludCksXG4gICAgICAgIG9iamVjdDogbGluZVNlZ21lbnRzLFxuICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICBmYWNlSW5kZXg6IGksXG4gICAgICAgIHV2OiBudWxsLFxuICAgICAgICBbVVYxXTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByYXljYXN0U2NyZWVuU3BhY2UobGluZVNlZ21lbnRzLCBjYW1lcmEsIGludGVyc2VjdHMpIHtcbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4O1xuICBjb25zdCBtYXRlcmlhbCA9IGxpbmVTZWdtZW50cy5tYXRlcmlhbDtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IG1hdGVyaWFsLnJlc29sdXRpb247XG4gIGNvbnN0IG1hdHJpeFdvcmxkID0gbGluZVNlZ21lbnRzLm1hdHJpeFdvcmxkO1xuICBjb25zdCBnZW9tZXRyeSA9IGxpbmVTZWdtZW50cy5nZW9tZXRyeTtcbiAgY29uc3QgaW5zdGFuY2VTdGFydCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgY29uc3QgaW5zdGFuY2VFbmQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kO1xuICBjb25zdCBzZWdtZW50Q291bnQgPSBNYXRoLm1pbihnZW9tZXRyeS5pbnN0YW5jZUNvdW50LCBpbnN0YW5jZVN0YXJ0LmNvdW50KTtcbiAgY29uc3QgbmVhciA9IC1jYW1lcmEubmVhcjtcbiAgX3JheS5hdCgxLCBfc3NPcmlnaW4pO1xuICBfc3NPcmlnaW4udyA9IDE7XG4gIF9zc09yaWdpbi5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gIF9zc09yaWdpbi5hcHBseU1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCk7XG4gIF9zc09yaWdpbi5tdWx0aXBseVNjYWxhcigxIC8gX3NzT3JpZ2luLncpO1xuICBfc3NPcmlnaW4ueCAqPSByZXNvbHV0aW9uLnggLyAyO1xuICBfc3NPcmlnaW4ueSAqPSByZXNvbHV0aW9uLnkgLyAyO1xuICBfc3NPcmlnaW4ueiA9IDA7XG4gIF9zc09yaWdpbjMuY29weShfc3NPcmlnaW4pO1xuICBfbXZNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBtYXRyaXhXb3JsZCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc2VnbWVudENvdW50OyBpIDwgbDsgaSsrKSB7XG4gICAgX3N0YXJ0NC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlU3RhcnQsIGkpO1xuICAgIF9lbmQ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgIF9zdGFydDQudyA9IDE7XG4gICAgX2VuZDQudyA9IDE7XG4gICAgX3N0YXJ0NC5hcHBseU1hdHJpeDQoX212TWF0cml4KTtcbiAgICBfZW5kNC5hcHBseU1hdHJpeDQoX212TWF0cml4KTtcbiAgICBjb25zdCBpc0JlaGluZENhbWVyYU5lYXIgPSBfc3RhcnQ0LnogPiBuZWFyICYmIF9lbmQ0LnogPiBuZWFyO1xuICAgIGlmIChpc0JlaGluZENhbWVyYU5lYXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoX3N0YXJ0NC56ID4gbmVhcikge1xuICAgICAgY29uc3QgZGVsdGFEaXN0ID0gX3N0YXJ0NC56IC0gX2VuZDQuejtcbiAgICAgIGNvbnN0IHQgPSAoX3N0YXJ0NC56IC0gbmVhcikgLyBkZWx0YURpc3Q7XG4gICAgICBfc3RhcnQ0LmxlcnAoX2VuZDQsIHQpO1xuICAgIH0gZWxzZSBpZiAoX2VuZDQueiA+IG5lYXIpIHtcbiAgICAgIGNvbnN0IGRlbHRhRGlzdCA9IF9lbmQ0LnogLSBfc3RhcnQ0Lno7XG4gICAgICBjb25zdCB0ID0gKF9lbmQ0LnogLSBuZWFyKSAvIGRlbHRhRGlzdDtcbiAgICAgIF9lbmQ0LmxlcnAoX3N0YXJ0NCwgdCk7XG4gICAgfVxuICAgIF9zdGFydDQuYXBwbHlNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpO1xuICAgIF9lbmQ0LmFwcGx5TWF0cml4NChwcm9qZWN0aW9uTWF0cml4KTtcbiAgICBfc3RhcnQ0Lm11bHRpcGx5U2NhbGFyKDEgLyBfc3RhcnQ0LncpO1xuICAgIF9lbmQ0Lm11bHRpcGx5U2NhbGFyKDEgLyBfZW5kNC53KTtcbiAgICBfc3RhcnQ0LnggKj0gcmVzb2x1dGlvbi54IC8gMjtcbiAgICBfc3RhcnQ0LnkgKj0gcmVzb2x1dGlvbi55IC8gMjtcbiAgICBfZW5kNC54ICo9IHJlc29sdXRpb24ueCAvIDI7XG4gICAgX2VuZDQueSAqPSByZXNvbHV0aW9uLnkgLyAyO1xuICAgIF9saW5lLnN0YXJ0LmNvcHkoX3N0YXJ0NCk7XG4gICAgX2xpbmUuc3RhcnQueiA9IDA7XG4gICAgX2xpbmUuZW5kLmNvcHkoX2VuZDQpO1xuICAgIF9saW5lLmVuZC56ID0gMDtcbiAgICBjb25zdCBwYXJhbSA9IF9saW5lLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoX3NzT3JpZ2luMywgdHJ1ZSk7XG4gICAgX2xpbmUuYXQocGFyYW0sIF9jbG9zZXN0UG9pbnQpO1xuICAgIGNvbnN0IHpQb3MgPSBNYXRoVXRpbHMubGVycChfc3RhcnQ0LnosIF9lbmQ0LnosIHBhcmFtKTtcbiAgICBjb25zdCBpc0luQ2xpcFNwYWNlID0gelBvcyA+PSAtMSAmJiB6UG9zIDw9IDE7XG4gICAgY29uc3QgaXNJbnNpZGUgPSBfc3NPcmlnaW4zLmRpc3RhbmNlVG8oX2Nsb3Nlc3RQb2ludCkgPCBfbGluZVdpZHRoICogMC41O1xuICAgIGlmIChpc0luQ2xpcFNwYWNlICYmIGlzSW5zaWRlKSB7XG4gICAgICBfbGluZS5zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlU3RhcnQsIGkpO1xuICAgICAgX2xpbmUuZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgICAgX2xpbmUuc3RhcnQuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgIF9saW5lLmVuZC5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgICAgY29uc3QgcG9pbnRPbkxpbmUgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgX3JheS5kaXN0YW5jZVNxVG9TZWdtZW50KF9saW5lLnN0YXJ0LCBfbGluZS5lbmQsIHBvaW50LCBwb2ludE9uTGluZSk7XG4gICAgICBpbnRlcnNlY3RzLnB1c2goe1xuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRPbkxpbmUsXG4gICAgICAgIGRpc3RhbmNlOiBfcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHBvaW50KSxcbiAgICAgICAgb2JqZWN0OiBsaW5lU2VnbWVudHMsXG4gICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgIGZhY2VJbmRleDogaSxcbiAgICAgICAgdXY6IG51bGwsXG4gICAgICAgIFtVVjFdOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIExpbmVTZWdtZW50czIgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBuZXcgTGluZVNlZ21lbnRzR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgTGluZU1hdGVyaWFsKHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSB9KSkge1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdGhpcy5pc0xpbmVTZWdtZW50czIgPSB0cnVlO1xuICAgIHRoaXMudHlwZSA9IFwiTGluZVNlZ21lbnRzMlwiO1xuICB9XG4gIC8vIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYnV0IGNvdWxkIGJlIGEgbWV0aG9kIG9mIExpbmVTZWdtZW50c0dlb21ldHJ5Li4uXG4gIGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBjb25zdCBpbnN0YW5jZVN0YXJ0ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbnN0YW5jZVN0YXJ0O1xuICAgIGNvbnN0IGluc3RhbmNlRW5kID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgICBjb25zdCBsaW5lRGlzdGFuY2VzID0gbmV3IEZsb2F0MzJBcnJheSgyICogaW5zdGFuY2VTdGFydC5jb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBsID0gaW5zdGFuY2VTdGFydC5jb3VudDsgaSA8IGw7IGkrKywgaiArPSAyKSB7XG4gICAgICBfc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICAgIF9lbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZUVuZCwgaSk7XG4gICAgICBsaW5lRGlzdGFuY2VzW2pdID0gaiA9PT0gMCA/IDAgOiBsaW5lRGlzdGFuY2VzW2ogLSAxXTtcbiAgICAgIGxpbmVEaXN0YW5jZXNbaiArIDFdID0gbGluZURpc3RhbmNlc1tqXSArIF9zdGFydC5kaXN0YW5jZVRvKF9lbmQpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZURpc3RhbmNlQnVmZmVyID0gbmV3IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKGxpbmVEaXN0YW5jZXMsIDIsIDEpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcImluc3RhbmNlRGlzdGFuY2VTdGFydFwiLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VEaXN0YW5jZUJ1ZmZlciwgMSwgMCkpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcImluc3RhbmNlRGlzdGFuY2VFbmRcIiwgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRGlzdGFuY2VCdWZmZXIsIDEsIDEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgIGNvbnN0IHdvcmxkVW5pdHMgPSB0aGlzLm1hdGVyaWFsLndvcmxkVW5pdHM7XG4gICAgY29uc3QgY2FtZXJhID0gcmF5Y2FzdGVyLmNhbWVyYTtcbiAgICBpZiAoY2FtZXJhID09PSBudWxsICYmICF3b3JsZFVuaXRzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnTGluZVNlZ21lbnRzMjogXCJSYXljYXN0ZXIuY2FtZXJhXCIgbmVlZHMgdG8gYmUgc2V0IGluIG9yZGVyIHRvIHJheWNhc3QgYWdhaW5zdCBMaW5lU2VnbWVudHMyIHdoaWxlIHdvcmxkVW5pdHMgaXMgc2V0IHRvIGZhbHNlLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuTGluZTIgIT09IHZvaWQgMCA/IHJheWNhc3Rlci5wYXJhbXMuTGluZTIudGhyZXNob2xkIHx8IDAgOiAwO1xuICAgIF9yYXkgPSByYXljYXN0ZXIucmF5O1xuICAgIGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgIF9saW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGggKyB0aHJlc2hvbGQ7XG4gICAgaWYgKGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSB7XG4gICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICB9XG4gICAgX3NwaGVyZS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgIGxldCBzcGhlcmVNYXJnaW47XG4gICAgaWYgKHdvcmxkVW5pdHMpIHtcbiAgICAgIHNwaGVyZU1hcmdpbiA9IF9saW5lV2lkdGggKiAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9TcGhlcmUgPSBNYXRoLm1heChjYW1lcmEubmVhciwgX3NwaGVyZS5kaXN0YW5jZVRvUG9pbnQoX3JheS5vcmlnaW4pKTtcbiAgICAgIHNwaGVyZU1hcmdpbiA9IGdldFdvcmxkU3BhY2VIYWxmV2lkdGgoY2FtZXJhLCBkaXN0YW5jZVRvU3BoZXJlLCBtYXRlcmlhbC5yZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgX3NwaGVyZS5yYWRpdXMgKz0gc3BoZXJlTWFyZ2luO1xuICAgIGlmIChfcmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeS5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgfVxuICAgIF9ib3guY29weShnZW9tZXRyeS5ib3VuZGluZ0JveCkuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICBsZXQgYm94TWFyZ2luO1xuICAgIGlmICh3b3JsZFVuaXRzKSB7XG4gICAgICBib3hNYXJnaW4gPSBfbGluZVdpZHRoICogMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvQm94ID0gTWF0aC5tYXgoY2FtZXJhLm5lYXIsIF9ib3guZGlzdGFuY2VUb1BvaW50KF9yYXkub3JpZ2luKSk7XG4gICAgICBib3hNYXJnaW4gPSBnZXRXb3JsZFNwYWNlSGFsZldpZHRoKGNhbWVyYSwgZGlzdGFuY2VUb0JveCwgbWF0ZXJpYWwucmVzb2x1dGlvbik7XG4gICAgfVxuICAgIF9ib3guZXhwYW5kQnlTY2FsYXIoYm94TWFyZ2luKTtcbiAgICBpZiAoX3JheS5pbnRlcnNlY3RzQm94KF9ib3gpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod29ybGRVbml0cykge1xuICAgICAgcmF5Y2FzdFdvcmxkVW5pdHModGhpcywgaW50ZXJzZWN0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJheWNhc3RTY3JlZW5TcGFjZSh0aGlzLCBjYW1lcmEsIGludGVyc2VjdHMpO1xuICAgIH1cbiAgfVxuICBvbkJlZm9yZVJlbmRlcihyZW5kZXJlcikge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy5tYXRlcmlhbC51bmlmb3JtcztcbiAgICBpZiAodW5pZm9ybXMgJiYgdW5pZm9ybXMucmVzb2x1dGlvbikge1xuICAgICAgcmVuZGVyZXIuZ2V0Vmlld3BvcnQoX3ZpZXdwb3J0KTtcbiAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQoX3ZpZXdwb3J0LnosIF92aWV3cG9ydC53KTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIExpbmVTZWdtZW50czJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU2VnbWVudHMyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineSegmentsGeometry.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineSegmentsGeometry: () => (/* binding */ LineSegmentsGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst _box = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst _vector = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nclass LineSegmentsGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new three__WEBPACK_IMPORTED_MODULE_0__.WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          \"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\",\n          this\n        );\n      }\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\n\n//# sourceMappingURL=LineSegmentsGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVTZWdtZW50c0dlb21ldHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBLO0FBQzFLLGlDQUFpQyx1Q0FBSTtBQUNyQyxvQ0FBb0MsMENBQU87QUFDM0MsbUNBQW1DLDBEQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlEQUFzQjtBQUM1RCxnQ0FBZ0MseURBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCLDZEQUEwQjtBQUN6RCwyQ0FBMkMsNkRBQTBCO0FBQ3JFLHlDQUF5Qyw2REFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0NBQW9DLDZEQUEwQjtBQUM5RCxnREFBZ0QsNkRBQTBCO0FBQzFFLDhDQUE4Qyw2REFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsaW5lc1xcTGluZVNlZ21lbnRzR2VvbWV0cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgV2lyZWZyYW1lR2VvbWV0cnksIEJveDMsIFNwaGVyZSwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQm94MygpO1xuY29uc3QgX3ZlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY2xhc3MgTGluZVNlZ21lbnRzR2VvbWV0cnkgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xpbmVTZWdtZW50c0dlb21ldHJ5ID0gdHJ1ZTtcbiAgICB0aGlzLnR5cGUgPSBcIkxpbmVTZWdtZW50c0dlb21ldHJ5XCI7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWy0xLCAyLCAwLCAxLCAyLCAwLCAtMSwgMSwgMCwgMSwgMSwgMCwgLTEsIDAsIDAsIDEsIDAsIDAsIC0xLCAtMSwgMCwgMSwgLTEsIDBdO1xuICAgIGNvbnN0IHV2cyA9IFstMSwgMiwgMSwgMiwgLTEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIC0xLCAtMiwgMSwgLTJdO1xuICAgIGNvbnN0IGluZGV4ID0gWzAsIDIsIDEsIDIsIDMsIDEsIDIsIDQsIDMsIDQsIDUsIDMsIDQsIDYsIDUsIDYsIDcsIDVdO1xuICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgfVxuICBhcHBseU1hdHJpeDQobWF0cml4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7XG4gICAgaWYgKHN0YXJ0ICE9PSB2b2lkIDApIHtcbiAgICAgIHN0YXJ0LmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgZW5kLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgc3RhcnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFBvc2l0aW9ucyhhcnJheSkge1xuICAgIGxldCBsaW5lU2VnbWVudHM7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICBsaW5lU2VnbWVudHMgPSBhcnJheTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICBsaW5lU2VnbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2VCdWZmZXIgPSBuZXcgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIobGluZVNlZ21lbnRzLCA2LCAxKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImluc3RhbmNlU3RhcnRcIiwgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlQnVmZmVyLCAzLCAwKSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJpbnN0YW5jZUVuZFwiLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VCdWZmZXIsIDMsIDMpKTtcbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Q29sb3JzKGFycmF5LCBpdGVtU2l6ZSA9IDMpIHtcbiAgICBsZXQgY29sb3JzO1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgY29sb3JzID0gYXJyYXk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlQ29sb3JCdWZmZXIgPSBuZXcgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIoY29sb3JzLCBpdGVtU2l6ZSAqIDIsIDEpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiaW5zdGFuY2VDb2xvclN0YXJ0XCIsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZUNvbG9yQnVmZmVyLCBpdGVtU2l6ZSwgMCkpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiaW5zdGFuY2VDb2xvckVuZFwiLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VDb2xvckJ1ZmZlciwgaXRlbVNpemUsIGl0ZW1TaXplKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbVdpcmVmcmFtZUdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXRQb3NpdGlvbnMoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbUVkZ2VzR2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICB0aGlzLnNldFBvc2l0aW9ucyhnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmcm9tTWVzaChtZXNoKSB7XG4gICAgdGhpcy5mcm9tV2lyZWZyYW1lR2VvbWV0cnkobmV3IFdpcmVmcmFtZUdlb21ldHJ5KG1lc2guZ2VvbWV0cnkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmcm9tTGluZVNlZ21lbnRzKGxpbmVTZWdtZW50cykge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbGluZVNlZ21lbnRzLmdlb21ldHJ5O1xuICAgIHRoaXMuc2V0UG9zaXRpb25zKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICBpZiAodGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gICAgY29uc3QgZW5kID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kO1xuICAgIGlmIChzdGFydCAhPT0gdm9pZCAwICYmIGVuZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoc3RhcnQpO1xuICAgICAgX2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGVuZCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnVuaW9uKF9ib3gpO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG4gICAgaWYgKHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZVN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgICBpZiAoc3RhcnQgIT09IHZvaWQgMCAmJiBlbmQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihjZW50ZXIpO1xuICAgICAgbGV0IG1heFJhZGl1c1NxID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHN0YXJ0LmNvdW50OyBpIDwgaWw7IGkrKykge1xuICAgICAgICBfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoc3RhcnQsIGkpO1xuICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoX3ZlY3RvcikpO1xuICAgICAgICBfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoZW5kLCBpKTtcbiAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKF92ZWN0b3IpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KG1heFJhZGl1c1NxKTtcbiAgICAgIGlmIChpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkxpbmVTZWdtZW50c0dlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgaW5zdGFuY2VkIHBvc2l0aW9uIGRhdGEgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgfVxuICBhcHBseU1hdHJpeChtYXRyaXgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5MaW5lU2VnbWVudHNHZW9tZXRyeTogYXBwbHlNYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIGFwcGx5TWF0cml4NCgpLlwiKTtcbiAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTGluZVNlZ21lbnRzR2VvbWV0cnlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU2VnbWVudHNHZW9tZXRyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\n//# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUU7QUFDQSwwQkFBMEIseUNBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNkJBQTZCLGdEQUFnRDtBQUM3RSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWM7QUFDdkM7QUFDQSw0QkFBNEIsa0RBQWU7QUFDM0M7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQTBDO0FBQ3pFLFlBQVk7QUFDWjtBQUNBLCtCQUErQixxREFBcUQ7QUFDcEYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsb2FkZXJzXFxEUkFDT0xvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIEZpbGVMb2FkZXIsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IF90YXNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIERSQUNPTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBcIlwiO1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IHt9O1xuICAgIHRoaXMuZGVjb2RlckJpbmFyeSA9IG51bGw7XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IG51bGw7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IDQ7XG4gICAgdGhpcy53b3JrZXJQb29sID0gW107XG4gICAgdGhpcy53b3JrZXJOZXh0VGFza0lEID0gMTtcbiAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFwiXCI7XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzID0ge1xuICAgICAgcG9zaXRpb246IFwiUE9TSVRJT05cIixcbiAgICAgIG5vcm1hbDogXCJOT1JNQUxcIixcbiAgICAgIGNvbG9yOiBcIkNPTE9SXCIsXG4gICAgICB1djogXCJURVhfQ09PUkRcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIG5vcm1hbDogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIGNvbG9yOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgdXY6IFwiRmxvYXQzMkFycmF5XCJcbiAgICB9O1xuICB9XG4gIHNldERlY29kZXJQYXRoKHBhdGgpIHtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXREZWNvZGVyQ29uZmlnKGNvbmZpZykge1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRXb3JrZXJMaW1pdCh3b3JrZXJMaW1pdCkge1xuICAgIHRoaXMud29ya2VyTGltaXQgPSB3b3JrZXJMaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgKGJ1ZmZlcikgPT4ge1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgICAgIGF0dHJpYnV0ZUlEczogdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgICAgICB1c2VVbmlxdWVJRHM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKG9uTG9hZCkuY2F0Y2gob25FcnJvcik7XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uRXJyb3JcbiAgICApO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBLZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgRFJBQ09Mb2FkZXIgdmVyc2lvbnMuICovXG4gIGRlY29kZURyYWNvRmlsZShidWZmZXIsIGNhbGxiYWNrLCBhdHRyaWJ1dGVJRHMsIGF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgIGF0dHJpYnV0ZUlEczogYXR0cmlidXRlSURzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgIGF0dHJpYnV0ZVR5cGVzOiBhdHRyaWJ1dGVUeXBlcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgIHVzZVVuaXF1ZUlEczogISFhdHRyaWJ1dGVJRHNcbiAgICB9O1xuICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBkZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdO1xuICAgICAgaWYgKHR5cGUuQllURVNfUEVSX0VMRU1FTlQgIT09IHZvaWQgMCkge1xuICAgICAgICB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV0gPSB0eXBlLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhc2tLZXkgPSBKU09OLnN0cmluZ2lmeSh0YXNrQ29uZmlnKTtcbiAgICBpZiAoX3Rhc2tDYWNoZS5oYXMoYnVmZmVyKSkge1xuICAgICAgY29uc3QgY2FjaGVkVGFzayA9IF90YXNrQ2FjaGUuZ2V0KGJ1ZmZlcik7XG4gICAgICBpZiAoY2FjaGVkVGFzay5rZXkgPT09IHRhc2tLZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFRhc2sucHJvbWlzZTtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuYWJsZSB0byByZS1kZWNvZGUgYSBidWZmZXIgd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3MuIEJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHRyYW5zZmVycmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3b3JrZXI7XG4gICAgY29uc3QgdGFza0lEID0gdGhpcy53b3JrZXJOZXh0VGFza0lEKys7XG4gICAgY29uc3QgdGFza0Nvc3QgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBnZW9tZXRyeVBlbmRpbmcgPSB0aGlzLl9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkudGhlbigoX3dvcmtlcikgPT4ge1xuICAgICAgd29ya2VyID0gX3dvcmtlcjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF0gPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogdGFza0lELCB0YXNrQ29uZmlnLCBidWZmZXIgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gICAgfSkudGhlbigobWVzc2FnZSkgPT4gdGhpcy5fY3JlYXRlR2VvbWV0cnkobWVzc2FnZS5nZW9tZXRyeSkpO1xuICAgIGdlb21ldHJ5UGVuZGluZy5jYXRjaCgoKSA9PiB0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh3b3JrZXIgJiYgdGFza0lEKSB7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGFza0NhY2hlLnNldChidWZmZXIsIHtcbiAgICAgIGtleTogdGFza0tleSxcbiAgICAgIHByb21pc2U6IGdlb21ldHJ5UGVuZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiBnZW9tZXRyeVBlbmRpbmc7XG4gIH1cbiAgX2NyZWF0ZUdlb21ldHJ5KGdlb21ldHJ5RGF0YSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5RGF0YS5pbmRleCkge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeURhdGEuaW5kZXguYXJyYXksIDEpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeURhdGEuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXNbaV07XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICBjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBfbG9hZExpYnJhcnkodXJsLCByZXNwb25zZVR5cGUpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMuZGVjb2RlclBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUocmVzcG9uc2VUeXBlKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgcHJlbG9hZCgpIHtcbiAgICB0aGlzLl9pbml0RGVjb2RlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0RGVjb2RlcigpIHtcbiAgICBpZiAodGhpcy5kZWNvZGVyUGVuZGluZylcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICAgIGNvbnN0IHVzZUpTID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSBcIm9iamVjdFwiIHx8IHRoaXMuZGVjb2RlckNvbmZpZy50eXBlID09PSBcImpzXCI7XG4gICAgY29uc3QgbGlicmFyaWVzUGVuZGluZyA9IFtdO1xuICAgIGlmICh1c2VKUykge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci5qc1wiLCBcInRleHRcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb193YXNtX3dyYXBwZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIud2FzbVwiLCBcImFycmF5YnVmZmVyXCIpKTtcbiAgICB9XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IFByb21pc2UuYWxsKGxpYnJhcmllc1BlbmRpbmcpLnRoZW4oKGxpYnJhcmllcykgPT4ge1xuICAgICAgY29uc3QganNDb250ZW50ID0gbGlicmFyaWVzWzBdO1xuICAgICAgaWYgKCF1c2VKUykge1xuICAgICAgICB0aGlzLmRlY29kZXJDb25maWcud2FzbUJpbmFyeSA9IGxpYnJhcmllc1sxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZuID0gRFJBQ09Xb3JrZXIudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBbXG4gICAgICAgIFwiLyogZHJhY28gZGVjb2RlciAqL1wiLFxuICAgICAgICBqc0NvbnRlbnQsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiLyogd29ya2VyICovXCIsXG4gICAgICAgIGZuLnN1YnN0cmluZyhmbi5pbmRleE9mKFwie1wiKSArIDEsIGZuLmxhc3RJbmRleE9mKFwifVwiKSlcbiAgICAgIF0uam9pbihcIlxcblwiKTtcbiAgICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYm9keV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgfVxuICBfZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdERlY29kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy53b3JrZXJMaW1pdCkge1xuICAgICAgICBjb25zdCB3b3JrZXIyID0gbmV3IFdvcmtlcih0aGlzLndvcmtlclNvdXJjZVVSTCk7XG4gICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrQ29zdHMgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0xvYWQgPSAwO1xuICAgICAgICB3b3JrZXIyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJpbml0XCIsIGRlY29kZXJDb25maWc6IHRoaXMuZGVjb2RlckNvbmZpZyB9KTtcbiAgICAgICAgd29ya2VyMi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlamVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBtZXNzYWdlLCBcIicgKyBtZXNzYWdlLnR5cGUgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLl90YXNrTG9hZCA+IGIuX3Rhc2tMb2FkID8gLTEgOiAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbFt0aGlzLndvcmtlclBvb2wubGVuZ3RoIC0gMV07XG4gICAgICB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdID0gdGFza0Nvc3Q7XG4gICAgICB3b3JrZXIuX3Rhc2tMb2FkICs9IHRhc2tDb3N0O1xuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9KTtcbiAgfVxuICBfcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpIHtcbiAgICB3b3JrZXIuX3Rhc2tMb2FkIC09IHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gIH1cbiAgZGVidWcoKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIlRhc2sgbG9hZDogXCIsXG4gICAgICB0aGlzLndvcmtlclBvb2wubWFwKCh3b3JrZXIpID0+IHdvcmtlci5fdGFza0xvYWQpXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53b3JrZXJQb29sLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLndvcmtlclBvb2xbaV0udGVybWluYXRlKCk7XG4gICAgfVxuICAgIHRoaXMud29ya2VyUG9vbC5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBEUkFDT1dvcmtlcigpIHtcbiAgbGV0IGRlY29kZXJDb25maWc7XG4gIGxldCBkZWNvZGVyUGVuZGluZztcbiAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgIGRlY29kZXJDb25maWcgPSBtZXNzYWdlLmRlY29kZXJDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIGRlY29kZXJDb25maWcub25Nb2R1bGVMb2FkZWQgPSBmdW5jdGlvbihkcmFjbykge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGRyYWNvIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgRHJhY29EZWNvZGVyTW9kdWxlKGRlY29kZXJDb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1lc3NhZ2UuYnVmZmVyO1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0gbWVzc2FnZS50YXNrQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZy50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBkcmFjbyA9IG1vZHVsZS5kcmFjbztcbiAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IGRyYWNvLkRlY29kZXIoKTtcbiAgICAgICAgICBjb25zdCBkZWNvZGVyQnVmZmVyID0gbmV3IGRyYWNvLkRlY29kZXJCdWZmZXIoKTtcbiAgICAgICAgICBkZWNvZGVyQnVmZmVyLkluaXQobmV3IEludDhBcnJheShidWZmZXIpLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiBhdHRyLmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXgpXG4gICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChnZW9tZXRyeS5pbmRleC5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiBtZXNzYWdlLmlkLCBnZW9tZXRyeSB9LCBidWZmZXJzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJlcnJvclwiLCBpZDogbWVzc2FnZS5pZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2RlckJ1ZmZlcik7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVJRHMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZUlEcztcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlcyA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXM7XG4gICAgbGV0IGRyYWNvR2VvbWV0cnk7XG4gICAgbGV0IGRlY29kaW5nU3RhdHVzO1xuICAgIGNvbnN0IGdlb21ldHJ5VHlwZSA9IGRlY29kZXIuR2V0RW5jb2RlZEdlb21ldHJ5VHlwZShkZWNvZGVyQnVmZmVyKTtcbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uTWVzaCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvTWVzaChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uUE9JTlRfQ0xPVUQpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uUG9pbnRDbG91ZCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZS5cIik7XG4gICAgfVxuICAgIGlmICghZGVjb2RpbmdTdGF0dXMub2soKSB8fCBkcmFjb0dlb21ldHJ5LnB0ciA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IERlY29kaW5nIGZhaWxlZDogXCIgKyBkZWNvZGluZ1N0YXR1cy5lcnJvcl9tc2coKSk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0geyBpbmRleDogbnVsbCwgYXR0cmlidXRlczogW10gfTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlSURzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVUeXBlID0gc2VsZlthdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICBsZXQgYXR0cmlidXRlO1xuICAgICAgbGV0IGF0dHJpYnV0ZUlEO1xuICAgICAgaWYgKHRhc2tDb25maWcudXNlVW5pcXVlSURzKSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUlkKGRyYWNvR2VvbWV0cnksIGRyYWNvW2F0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXV0pO1xuICAgICAgICBpZiAoYXR0cmlidXRlSUQgPT09IC0xKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZShkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnB1c2goZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBnZW9tZXRyeS5pbmRleCA9IGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9XG4gICAgZHJhY28uZGVzdHJveShkcmFjb0dlb21ldHJ5KTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpIHtcbiAgICBjb25zdCBudW1GYWNlcyA9IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCk7XG4gICAgY29uc3QgbnVtSW5kaWNlcyA9IG51bUZhY2VzICogMztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtSW5kaWNlcyAqIDQ7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5KGRyYWNvR2VvbWV0cnksIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgaW5kZXggPSBuZXcgVWludDMyQXJyYXkoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtSW5kaWNlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7IGFycmF5OiBpbmRleCwgaXRlbVNpemU6IDEgfTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IG51bUNvbXBvbmVudHMgPSBhdHRyaWJ1dGUubnVtX2NvbXBvbmVudHMoKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBkcmFjb0dlb21ldHJ5Lm51bV9wb2ludHMoKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBudW1Qb2ludHMgKiBudW1Db21wb25lbnRzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1WYWx1ZXMgKiBhdHRyaWJ1dGVUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSk7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyhkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGUsIGRhdGFUeXBlLCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IGF0dHJpYnV0ZVR5cGUoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtVmFsdWVzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICBhcnJheSxcbiAgICAgIGl0ZW1TaXplOiBudW1Db21wb25lbnRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKSB7XG4gICAgc3dpdGNoIChhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0ZMT0FUMzI7XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDg7XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQxNjtcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDMyO1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDg7XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDE2O1xuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQzMjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIERSQUNPTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RFJBQ09Mb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n        three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n\n//# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsOENBQVc7QUFDckMscUJBQXFCLDhDQUFXO0FBQ2hDLE1BQU07QUFDTixxQkFBcUIsOENBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FB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LFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsb2FkZXJzXFxHTFRGTG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgTG9hZGVyVXRpbHMsIEZpbGVMb2FkZXIsIENvbG9yLCBTcG90TGlnaHQsIFBvaW50TGlnaHQsIERpcmVjdGlvbmFsTGlnaHQsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgVmVjdG9yMiwgTWF0cml4NCwgVmVjdG9yMywgUXVhdGVybmlvbiwgSW5zdGFuY2VkTWVzaCwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBPYmplY3QzRCwgVGV4dHVyZUxvYWRlciwgSW1hZ2VCaXRtYXBMb2FkZXIsIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgUmVwZWF0V3JhcHBpbmcsIFBvaW50c01hdGVyaWFsLCBNYXRlcmlhbCwgTGluZUJhc2ljTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlLCBQcm9wZXJ0eUJpbmRpbmcsIEJ1ZmZlckdlb21ldHJ5LCBTa2lubmVkTWVzaCwgTWVzaCwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBMaW5lU2VnbWVudHMsIExpbmUsIExpbmVMb29wLCBQb2ludHMsIEdyb3VwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgTWF0aFV0aWxzLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNrZWxldG9uLCBBbmltYXRpb25DbGlwLCBCb25lLCBJbnRlcnBvbGF0ZUxpbmVhciwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIEludGVycG9sYXRlRGlzY3JldGUsIEZyb250U2lkZSwgVGV4dHVyZSwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgTnVtYmVyS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIEJveDMsIFNwaGVyZSwgSW50ZXJwb2xhbnQgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHRvVHJpYW5nbGVzRHJhd01vZGUgfSBmcm9tIFwiLi4vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVUZXh0IH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qc1wiO1xuY29uc3QgU1JHQkNvbG9yU3BhY2UgPSBcInNyZ2JcIjtcbmNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbmNvbnN0IExpbmVhckVuY29kaW5nID0gM2UzO1xuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTGlnaHRzRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hvcHRDb21wcmVzc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNoR3B1SW5zdGFuY2luZyhwYXJzZXIpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgbGV0IHJlc291cmNlUGF0aDtcbiAgICBpZiAodGhpcy5yZXNvdXJjZVBhdGggIT09IFwiXCIpIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXRoICE9PSBcIlwiKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVVybCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCk7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5yZXNvbHZlVVJMKHJlbGF0aXZlVXJsLCB0aGlzLnBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgIH1cbiAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgY29uc3QgX29uRXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzY29wZS5wYXJzZShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXNvdXJjZVBhdGgsXG4gICAgICAgICAgICBmdW5jdGlvbihnbHRmKSB7XG4gICAgICAgICAgICAgIG9uTG9hZChnbHRmKTtcbiAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX29uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgX29uRXJyb3JcbiAgICApO1xuICB9XG4gIHNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKSB7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEREU0xvYWRlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nKTtcbiAgfVxuICBzZXRLVFgyTG9hZGVyKGt0eDJMb2FkZXIpIHtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1lc2hvcHREZWNvZGVyKG1lc2hvcHREZWNvZGVyKSB7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVucmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgIT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwYXJzZShkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBsZXQganNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG4gICAgY29uc3QgcGx1Z2lucyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljID0gZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICBpZiAobWFnaWMgPT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5jb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAganNvbiA9IGRhdGE7XG4gICAgfVxuICAgIGlmIChqc29uLmFzc2V0ID09PSB2b2lkIDAgfHwganNvbi5hc3NldC52ZXJzaW9uWzBdIDwgMikge1xuICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcihqc29uLCB7XG4gICAgICBwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8IFwiXCIsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgIHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcbiAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlcixcbiAgICAgIGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcbiAgICAgIG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG4gICAgfSk7XG4gICAgcGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzW2ldKHBhcnNlcik7XG4gICAgICBpZiAoIXBsdWdpbi5uYW1lKVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBwbHVnaW4gZm91bmQ6IG1pc3NpbmcgbmFtZVwiKTtcbiAgICAgIHBsdWdpbnNbcGx1Z2luLm5hbWVdID0gcGx1Z2luO1xuICAgICAgZXh0ZW5zaW9uc1twbHVnaW4ubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHRlbnNpb25zVXNlZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBqc29uLmV4dGVuc2lvbnNVc2VkW2ldO1xuICAgICAgICBjb25zdCBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcbiAgICAgICAgc3dpdGNoIChleHRlbnNpb25OYW1lKSB7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oanNvbiwgdGhpcy5kcmFjb0xvYWRlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoZXh0ZW5zaW9uTmFtZSkgPj0gMCAmJiBwbHVnaW5zW2V4dGVuc2lvbk5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlci5zZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICAgIHBhcnNlci5zZXRQbHVnaW5zKHBsdWdpbnMpO1xuICAgIHBhcnNlci5wYXJzZShvbkxvYWQsIG9uRXJyb3IpO1xuICB9XG4gIHBhcnNlQXN5bmMoZGF0YSwgcGF0aCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzY29wZS5wYXJzZShkYXRhLCBwYXRoLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG4gIGxldCBvYmplY3RzID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgb2JqZWN0KSB7XG4gICAgICBvYmplY3RzW2tleV0gPSBvYmplY3Q7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVsZXRlIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICBvYmplY3RzID0ge307XG4gICAgfVxuICB9O1xufVxuY29uc3QgRVhURU5TSU9OUyA9IHtcbiAgS0hSX0JJTkFSWV9HTFRGOiBcIktIUl9iaW5hcnlfZ2xURlwiLFxuICBLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogXCJLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblwiLFxuICBLSFJfTElHSFRTX1BVTkNUVUFMOiBcIktIUl9saWdodHNfcHVuY3R1YWxcIixcbiAgS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ6IFwiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIixcbiAgS0hSX01BVEVSSUFMU19ESVNQRVJTSU9OOiBcIktIUl9tYXRlcmlhbHNfZGlzcGVyc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lPUjogXCJLSFJfbWF0ZXJpYWxzX2lvclwiLFxuICBLSFJfTUFURVJJQUxTX1NIRUVOOiBcIktIUl9tYXRlcmlhbHNfc2hlZW5cIixcbiAgS0hSX01BVEVSSUFMU19TUEVDVUxBUjogXCJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCIsXG4gIEtIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OOiBcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U6IFwiS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZVwiLFxuICBLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk6IFwiS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5XCIsXG4gIEtIUl9NQVRFUklBTFNfVU5MSVQ6IFwiS0hSX21hdGVyaWFsc191bmxpdFwiLFxuICBLSFJfTUFURVJJQUxTX1ZPTFVNRTogXCJLSFJfbWF0ZXJpYWxzX3ZvbHVtZVwiLFxuICBLSFJfVEVYVFVSRV9CQVNJU1U6IFwiS0hSX3RleHR1cmVfYmFzaXN1XCIsXG4gIEtIUl9URVhUVVJFX1RSQU5TRk9STTogXCJLSFJfdGV4dHVyZV90cmFuc2Zvcm1cIixcbiAgS0hSX01FU0hfUVVBTlRJWkFUSU9OOiBcIktIUl9tZXNoX3F1YW50aXphdGlvblwiLFxuICBLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIOiBcIktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIixcbiAgRVhUX01BVEVSSUFMU19CVU1QOiBcIkVYVF9tYXRlcmlhbHNfYnVtcFwiLFxuICBFWFRfVEVYVFVSRV9XRUJQOiBcIkVYVF90ZXh0dXJlX3dlYnBcIixcbiAgRVhUX1RFWFRVUkVfQVZJRjogXCJFWFRfdGV4dHVyZV9hdmlmXCIsXG4gIEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OOiBcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCIsXG4gIEVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HOiBcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCJcbn07XG5jbGFzcyBHTFRGTGlnaHRzRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMO1xuICAgIHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICB9XG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlci5fYWRkTm9kZVJlZih0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9sb2FkTGlnaHQobGlnaHRJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJsaWdodDpcIiArIGxpZ2h0SW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSBwYXJzZXIuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZGVwZW5kZW5jeSlcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbGlnaHREZWZzW2xpZ2h0SW5kZXhdO1xuICAgIGxldCBsaWdodE5vZGU7XG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMTY3NzcyMTUpO1xuICAgIGlmIChsaWdodERlZi5jb2xvciAhPT0gdm9pZCAwKVxuICAgICAgY29sb3Iuc2V0UkdCKGxpZ2h0RGVmLmNvbG9yWzBdLCBsaWdodERlZi5jb2xvclsxXSwgbGlnaHREZWYuY29sb3JbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICBjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB2b2lkIDAgPyBsaWdodERlZi5yYW5nZSA6IDA7XG4gICAgc3dpdGNoIChsaWdodERlZi50eXBlKSB7XG4gICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNwb3RcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFNwb3RMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuICAgICAgICBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0O1xuICAgICAgICBsaWdodE5vZGUuYW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUucGVudW1icmEgPSAxIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6IFwiICsgbGlnaHREZWYudHlwZSk7XG4gICAgfVxuICAgIGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgbGlnaHROb2RlLmRlY2F5ID0gMjtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGxpZ2h0Tm9kZSwgbGlnaHREZWYpO1xuICAgIGlmIChsaWdodERlZi5pbnRlbnNpdHkgIT09IHZvaWQgMClcbiAgICAgIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG4gICAgbGlnaHROb2RlLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShsaWdodERlZi5uYW1lIHx8IFwibGlnaHRfXCIgKyBsaWdodEluZGV4KTtcbiAgICBkZXBlbmRlbmN5ID0gUHJvbWlzZS5yZXNvbHZlKGxpZ2h0Tm9kZSk7XG4gICAgcGFyc2VyLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGlmICh0eXBlICE9PSBcImxpZ2h0XCIpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChpbmRleCk7XG4gIH1cbiAgY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KSB7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcbiAgICBpZiAobGlnaHRJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChsaWdodEluZGV4KS50aGVuKGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHNlbGYyLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xuICB9XG4gIGV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3Iuc2V0UkdCKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmVtaXNzaXZlU3RyZW5ndGg7XG4gICAgaWYgKGVtaXNzaXZlU3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBlbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0TWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Um91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Tm9ybWFsTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlKSk7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0Rpc3BlcnNpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRElTUEVSU0lPTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmRpc3BlcnNpb24gPSBleHRlbnNpb24uZGlzcGVyc2lvbiAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmRpc3BlcnNpb24gOiAwO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2UgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZU1hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VJb3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VJT1IgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3I7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID09PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbMTAwLCA0MDBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzBdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVsxXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NIRUVOO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IDA7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW4gPSAxO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgY29sb3JGYWN0b3IgPSBleHRlbnNpb24uc2hlZW5Db2xvckZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3Iuc2V0UkdCKGNvbG9yRmFjdG9yWzBdLCBjb2xvckZhY3RvclsxXSwgY29sb3JGYWN0b3JbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Db2xvck1hcFwiLCBleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlblJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNtaXNzaW9uID0gZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0cmFuc21pc3Npb25NYXBcIiwgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1ZPTFVNRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy50aGlja25lc3MgPSBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yIDogMDtcbiAgICBpZiAoZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uRGlzdGFuY2UgfHwgSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKCkuc2V0UkdCKFxuICAgICAgY29sb3JBcnJheVswXSxcbiAgICAgIGNvbG9yQXJyYXlbMV0sXG4gICAgICBjb2xvckFycmF5WzJdLFxuICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2VcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JT1I7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5pb3IgPSBleHRlbnNpb24uaW9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uaW9yIDogMS41O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NQRUNVTEFSO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFySW50ZW5zaXR5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckludGVuc2l0eU1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uc3BlY3VsYXJDb2xvckZhY3RvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFyQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NQVRFUklBTFNfQlVNUDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5idW1wU2NhbGUgPSBleHRlbnNpb24uYnVtcEZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uYnVtcFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImJ1bXBNYXBcIiwgZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQU5JU09UUk9QWTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5ID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aDtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weVJvdGF0aW9uID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW5pc290cm9weU1hcFwiLCBleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfQkFTSVNVO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9XRUJQO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUFcIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9BVklGO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQVZJRiByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUJjQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFFQUFBQUJBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRQU1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFCb0FBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQjl0WkdGMEVnQUtDQmdBQm9nUUVEUWdNZ2tRQUFBQUI4ZFNMZkk9XCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNob3B0Q29tcHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGxvYWRCdWZmZXJWaWV3KGluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbaW5kZXhdO1xuICAgIGlmIChidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBleHRlbnNpb25EZWYuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuICAgICAgaWYgKCFkZWNvZGVyIHx8ICFkZWNvZGVyLnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgVWludDhBcnJheShyZXMsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoY291bnQsIHN0cmlkZSwgc291cmNlLCBleHRlbnNpb25EZWYubW9kZSwgZXh0ZW5zaW9uRGVmLmZpbHRlcikudGhlbihmdW5jdGlvbihyZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzMi5idWZmZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIucmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihjb3VudCAqIHN0cmlkZSk7XG4gICAgICAgICAgICBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXIoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCksXG4gICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLm1vZGUsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5maWx0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGTWVzaEdwdUluc3RhbmNpbmcge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKCFub2RlRGVmLmV4dGVuc2lvbnMgfHwgIW5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW25vZGVEZWYubWVzaF07XG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWVzaERlZi5wcmltaXRpdmVzKSB7XG4gICAgICBpZiAocHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiAmJiBwcmltaXRpdmUubW9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25EZWYgPSBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzRGVmID0gZXh0ZW5zaW9uRGVmLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzRGVmKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhdHRyaWJ1dGVzRGVmW2tleV0pLnRoZW4oKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYWNjZXNzb3I7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2godGhpcy5wYXJzZXIuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVPYmplY3QgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3QgbWVzaGVzID0gbm9kZU9iamVjdC5pc0dyb3VwID8gbm9kZU9iamVjdC5jaGlsZHJlbiA6IFtub2RlT2JqZWN0XTtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0c1swXS5jb3VudDtcbiAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBjb25zdCBzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBuZXcgSW5zdGFuY2VkTWVzaChtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdGVyaWFsLCBjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OKSB7XG4gICAgICAgICAgICBwLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5UUkFOU0xBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlJPVEFUSU9OKSB7XG4gICAgICAgICAgICBxLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5ST1RBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlNDQUxFKSB7XG4gICAgICAgICAgICBzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5TQ0FMRSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaSwgbS5jb21wb3NlKHAsIHEsIHMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcIl9DT0xPUl8wXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShhdHRyLmFycmF5LCBhdHRyLml0ZW1TaXplLCBhdHRyLm5vcm1hbGl6ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZSAhPT0gXCJUUkFOU0xBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiUk9UQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlNDQUxFXCIpIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKGluc3RhbmNlZE1lc2gsIG1lc2gpO1xuICAgICAgICB0aGlzLnBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKGluc3RhbmNlZE1lc2gpO1xuICAgICAgICBpbnN0YW5jZWRNZXNoZXMucHVzaChpbnN0YW5jZWRNZXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlT2JqZWN0LmlzR3JvdXApIHtcbiAgICAgICAgbm9kZU9iamVjdC5jbGVhcigpO1xuICAgICAgICBub2RlT2JqZWN0LmFkZCguLi5pbnN0YW5jZWRNZXNoZXMpO1xuICAgICAgICByZXR1cm4gbm9kZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZWRNZXNoZXNbMF07XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDID0gXCJnbFRGXCI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggPSAxMjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMgPSB7IEpTT046IDEzMTM4MjE1MTQsIEJJTjogNTEzMDU2MiB9O1xuY2xhc3MgR0xURkJpbmFyeUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcbiAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgY29uc3QgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCAwLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIHRoaXMuaGVhZGVyID0ge1xuICAgICAgbWFnaWM6IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpLFxuICAgICAgdmVyc2lvbjogaGVhZGVyVmlldy5nZXRVaW50MzIoNCwgdHJ1ZSksXG4gICAgICBsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKDgsIHRydWUpXG4gICAgfTtcbiAgICBpZiAodGhpcy5oZWFkZXIubWFnaWMgIT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IExlZ2FjeSBiaW5hcnkgZmlsZSBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rQ29udGVudHNMZW5ndGggPSB0aGlzLmhlYWRlci5sZW5ndGggLSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEg7XG4gICAgY29uc3QgY2h1bmtWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgIHdoaWxlIChjaHVua0luZGV4IDwgY2h1bmtDb250ZW50c0xlbmd0aCkge1xuICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTikge1xuICAgICAgICBjb25zdCBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGRlY29kZVRleHQoY29udGVudEFycmF5KTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkJJTikge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleDtcbiAgICAgICAgdGhpcy5ib2R5ID0gZGF0YS5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY2h1bmtJbmRleCArPSBjaHVua0xlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3Rvcihqc29uLCBkcmFjb0xvYWRlcikge1xuICAgIGlmICghZHJhY29Mb2FkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IE5vIERSQUNPTG9hZGVyIGluc3RhbmNlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKTtcbiAgfVxuICBkZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGRyYWNvTG9hZGVyID0gdGhpcy5kcmFjb0xvYWRlcjtcbiAgICBjb25zdCBidWZmZXJWaWV3SW5kZXggPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmJ1ZmZlclZpZXc7XG4gICAgY29uc3QgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcztcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlTWFwID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXApIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhyZWVBdHRyaWJ1dGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yRGVmID0ganNvbi5hY2Nlc3NvcnNbcHJpbWl0aXZlLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBjb21wb25lbnRUeXBlLm5hbWU7XG4gICAgICAgIGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYnVmZmVyVmlld0luZGV4KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKFxuICAgICAgICAgIGJ1ZmZlclZpZXcsXG4gICAgICAgICAgZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZ2VvbWV0cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyZWVBdHRyaWJ1dGVNYXAsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZU1hcCxcbiAgICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICByZWplY3RcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuICB9XG4gIGV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCh0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHZvaWQgMCB8fCB0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHRleHR1cmUuY2hhbm5lbCkgJiYgdHJhbnNmb3JtLm9mZnNldCA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5yb3RhdGlvbiA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5zY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICBpZiAodHJhbnNmb3JtLnRleENvb3JkICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUuY2hhbm5lbCA9IHRyYW5zZm9ybS50ZXhDb29yZDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5vZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KHRyYW5zZm9ybS5vZmZzZXQpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0uc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KHRyYW5zZm9ybS5zY2FsZSk7XG4gICAgfVxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuICB9XG59XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuICB9XG4gIGNvcHlTYW1wbGVWYWx1ZV8oaW5kZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlciwgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsIHZhbHVlU2l6ZSA9IHRoaXMudmFsdWVTaXplLCBvZmZzZXQgPSBpbmRleCAqIHZhbHVlU2l6ZSAqIDMgKyB2YWx1ZVNpemU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHZhbHVlU2l6ZTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB2YWx1ZXNbb2Zmc2V0ICsgaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcjtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcztcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcbiAgICBjb25zdCBzdHJpZGUyID0gc3RyaWRlICogMjtcbiAgICBjb25zdCBzdHJpZGUzID0gc3RyaWRlICogMztcbiAgICBjb25zdCB0ZCA9IHQxIC0gdDA7XG4gICAgY29uc3QgcCA9ICh0IC0gdDApIC8gdGQ7XG4gICAgY29uc3QgcHAgPSBwICogcDtcbiAgICBjb25zdCBwcHAgPSBwcCAqIHA7XG4gICAgY29uc3Qgb2Zmc2V0MSA9IGkxICogc3RyaWRlMztcbiAgICBjb25zdCBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG4gICAgY29uc3QgczIgPSAtMiAqIHBwcCArIDMgKiBwcDtcbiAgICBjb25zdCBzMyA9IHBwcCAtIHBwO1xuICAgIGNvbnN0IHMwID0gMSAtIHMyO1xuICAgIGNvbnN0IHMxID0gczMgLSBwcCArIHA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgaSsrKSB7XG4gICAgICBjb25zdCBwMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZTJdICogdGQ7XG4gICAgICBjb25zdCBwMSA9IHZhbHVlc1tvZmZzZXQxICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMSA9IHZhbHVlc1tvZmZzZXQxICsgaV0gKiB0ZDtcbiAgICAgIHJlc3VsdFtpXSA9IHMwICogcDAgKyBzMSAqIG0wICsgczIgKiBwMSArIHMzICogbTE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IF9xID0gLyogQF9fUFVSRV9fICovIG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xuY2xhc3MgR0xURlBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGpzb24gPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuc291cmNlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuICAgIGxldCBpc1NhZmFyaSA9IGZhbHNlO1xuICAgIGxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbiAgICBsZXQgZmlyZWZveFZlcnNpb24gPSAtMTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID09PSB0cnVlO1xuICAgICAgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xO1xuICAgICAgZmlyZWZveFZlcnNpb24gPSBpc0ZpcmVmb3ggPyBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKVsxXSA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSBcInVuZGVmaW5lZFwiIHx8IGlzU2FmYXJpIHx8IGlzRmlyZWZveCAmJiBmaXJlZm94VmVyc2lvbiA8IDk4KSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IFwidXNlLWNyZWRlbnRpYWxzXCIpIHtcbiAgICAgIHRoaXMuZmlsZUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIH1cbiAgc2V0UGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2lucztcbiAgfVxuICBwYXJzZShvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmJlZm9yZVJvb3QgJiYgZXh0LmJlZm9yZVJvb3QoKTtcbiAgICAgIH0pXG4gICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcInNjZW5lXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiYW5pbWF0aW9uXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiY2FtZXJhXCIpXG4gICAgICBdKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzY2VuZTogZGVwZW5kZW5jaWVzWzBdW2pzb24uc2NlbmUgfHwgMF0sXG4gICAgICAgIHNjZW5lczogZGVwZW5kZW5jaWVzWzBdLFxuICAgICAgICBhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbMV0sXG4gICAgICAgIGNhbWVyYXM6IGRlcGVuZGVuY2llc1syXSxcbiAgICAgICAgYXNzZXQ6IGpzb24uYXNzZXQsXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgdXNlckRhdGE6IHt9XG4gICAgICB9O1xuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbik7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHJlc3VsdCwganNvbik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgIHJldHVybiBleHQuYWZ0ZXJSb290ICYmIGV4dC5hZnRlclJvb3QocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiByZXN1bHQuc2NlbmVzKSB7XG4gICAgICAgICAgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuICAgKi9cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuICAgIGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9pbnRzID0gc2tpbkRlZnNbc2tpbkluZGV4XS5qb2ludHM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlRGVmc1tqb2ludHNbaV1dLmlzQm9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLm1lc2ggIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2gpO1xuICAgICAgICBpZiAobm9kZURlZi5za2luICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoRGVmc1tub2RlRGVmLm1lc2hdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyByZWZlcmVuY2VzIHRvIHNoYXJlZCBub2RlIC8gT2JqZWN0M0QgcmVzb3VyY2VzLiBUaGVzZSByZXNvdXJjZXNcbiAgICogY2FuIGJlIHJldXNlZCwgb3IgXCJpbnN0YW50aWF0ZWRcIiwgYXQgbXVsdGlwbGUgbm9kZXMgaW4gdGhlIHNjZW5lXG4gICAqIGhpZXJhcmNoeS4gTWVzaCwgQ2FtZXJhLCBhbmQgTGlnaHQgaW5zdGFuY2VzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIG11c3RcbiAgICogYmUgbWFya2VkLiBOb24tc2NlbmVncmFwaCByZXNvdXJjZXMgKGxpa2UgTWF0ZXJpYWxzLCBHZW9tZXRyaWVzLCBhbmRcbiAgICogVGV4dHVyZXMpIGNhbiBiZSByZXVzZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgbWFya2VkIGhlcmUuXG4gICAqXG4gICAqIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG4gICAqL1xuICBfYWRkTm9kZVJlZihjYWNoZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUucmVmc1tpbmRleF0gPSBjYWNoZS51c2VzW2luZGV4XSA9IDA7XG4gICAgfVxuICAgIGNhY2hlLnJlZnNbaW5kZXhdKys7XG4gIH1cbiAgLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuICBfZ2V0Tm9kZVJlZihjYWNoZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA8PSAxKVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcbiAgICBjb25zdCB1cGRhdGVNYXBwaW5ncyA9IChvcmlnaW5hbCwgY2xvbmUpID0+IHtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG9yaWdpbmFsKTtcbiAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjbG9uZSwgbWFwcGluZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbaSwgY2hpbGRdIG9mIG9yaWdpbmFsLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB1cGRhdGVNYXBwaW5ncyhjaGlsZCwgY2xvbmUuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlTWFwcGluZ3Mob2JqZWN0LCByZWYpO1xuICAgIHJlZi5uYW1lICs9IFwiX2luc3RhbmNlX1wiICsgY2FjaGUudXNlc1tpbmRleF0rKztcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIF9pbnZva2VPbmUoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy5wdXNoKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9pbnZva2VBbGwoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IHR5cGUgKyBcIjpcIiArIGluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzY2VuZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE5vZGUgJiYgZXh0LmxvYWROb2RlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc2hcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWNjZXNzb3JcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQWNjZXNzb3IoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyVmlld1wiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyhpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hdGVyaWFsXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1hdGVyaWFsICYmIGV4dC5sb2FkTWF0ZXJpYWwoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dHVyZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJza2luXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5pbWF0aW9uXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEFuaW1hdGlvbiAmJiBleHQubG9hZEFuaW1hdGlvbihpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYW1lcmFcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dCAhPSB0aGlzICYmIGV4dC5nZXREZXBlbmRlbmN5ICYmIGV4dC5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICBsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQodHlwZSk7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgICBjb25zdCBkZWZzID0gdGhpcy5qc29uW3R5cGUgKyAodHlwZSA9PT0gXCJtZXNoXCIgPyBcImVzXCIgOiBcInNcIildIHx8IFtdO1xuICAgICAgZGVwZW5kZW5jaWVzID0gUHJvbWlzZS5hbGwoXG4gICAgICAgIGRlZnMubWFwKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FjaGUuYWRkKHR5cGUsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXIoYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1tidWZmZXJJbmRleF07XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5maWxlTG9hZGVyO1xuICAgIGlmIChidWZmZXJEZWYudHlwZSAmJiBidWZmZXJEZWYudHlwZSAhPT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBcIiArIGJ1ZmZlckRlZi50eXBlICsgXCIgYnVmZmVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGlmIChidWZmZXJEZWYudXJpID09PSB2b2lkIDAgJiYgYnVmZmVySW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5ib2R5KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKGJ1ZmZlckRlZi51cmksIG9wdGlvbnMucGF0aCksIHJlc29sdmUsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IEZhaWxlZCB0byBsb2FkIGJ1ZmZlciBcIicgKyBidWZmZXJEZWYudXJpICsgJ1wiLicpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlclZpZXcoYnVmZmVyVmlld0luZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyVmlld0RlZiA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tidWZmZXJWaWV3SW5kZXhdO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgYnVmZmVyVmlld0RlZi5idWZmZXIpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuICAgKi9cbiAgbG9hZEFjY2Vzc29yKGFjY2Vzc29ySW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzW2FjY2Vzc29ySW5kZXhdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ID09PSB2b2lkIDAgJiYgYWNjZXNzb3JEZWYuc3BhcnNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuYnVmZmVyVmlldykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaChudWxsKTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcpKTtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3KSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nQnVmZmVyVmlld3MpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlld3MpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1swXTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgaXRlbUJ5dGVzID0gZWxlbWVudEJ5dGVzICogaXRlbVNpemU7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCA/IGpzb24uYnVmZmVyVmlld3NbYWNjZXNzb3JEZWYuYnVmZmVyVmlld10uYnl0ZVN0cmlkZSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgbGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG4gICAgICBpZiAoYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaWJTbGljZSA9IE1hdGguZmxvb3IoYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUpO1xuICAgICAgICBjb25zdCBpYkNhY2hlS2V5ID0gXCJJbnRlcmxlYXZlZEJ1ZmZlcjpcIiArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyBcIjpcIiArIGliU2xpY2UgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvdW50O1xuICAgICAgICBsZXQgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KGliQ2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWliKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgcGFyc2VyLmNhY2hlLmFkZChpYkNhY2hlS2V5LCBpYik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgIGliLFxuICAgICAgICAgIGl0ZW1TaXplLFxuICAgICAgICAgIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzLFxuICAgICAgICAgIG5vcm1hbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpdGVtU2l6ZUluZGljZXMgPSBXRUJHTF9UWVBFX1NJWkVTLlNDQUxBUjtcbiAgICAgICAgY29uc3QgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoXG4gICAgICAgICAgYnVmZmVyVmlld3NbMV0sXG4gICAgICAgICAgYnl0ZU9mZnNldEluZGljZXMsXG4gICAgICAgICAgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXdzWzJdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1tpXTtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WChpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAyKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFkoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAxXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDMpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WihpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDJdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNClcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRXKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgM10pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCN0ZXh0dXJlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuVGV4dHVyZXxudWxsPn1cbiAgICovXG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gdGV4dHVyZURlZi5zb3VyY2U7XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZURlZi51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2VEZWYudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcik7XG4gIH1cbiAgbG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgY2FjaGVLZXkgPSAoc291cmNlRGVmLnVyaSB8fCBzb3VyY2VEZWYuYnVmZmVyVmlldykgKyBcIjpcIiArIHRleHR1cmVEZWYuc2FtcGxlcjtcbiAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5sb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlRGVmLm5hbWUgfHwgc291cmNlRGVmLm5hbWUgfHwgXCJcIjtcbiAgICAgIGlmICh0ZXh0dXJlLm5hbWUgPT09IFwiXCIgJiYgdHlwZW9mIHNvdXJjZURlZi51cmkgPT09IFwic3RyaW5nXCIgJiYgc291cmNlRGVmLnVyaS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9cIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHRleHR1cmUubmFtZSA9IHNvdXJjZURlZi51cmk7XG4gICAgICB9XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG4gICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbdGV4dHVyZURlZi5zYW1wbGVyXSB8fCB7fTtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1hZ0ZpbHRlcl0gfHwgTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWluRmlsdGVyXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFNdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBUXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIHsgdGV4dHVyZXM6IHRleHR1cmVJbmRleCB9KTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBsb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0udGhlbigodGV4dHVyZSkgPT4gdGV4dHVyZS5jbG9uZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuICAgIGxldCBzb3VyY2VVUkkgPSBzb3VyY2VEZWYudXJpIHx8IFwiXCI7XG4gICAgbGV0IGlzT2JqZWN0VVJMID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZURlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBzb3VyY2VEZWYuYnVmZmVyVmlldykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICAgIGlzT2JqZWN0VVJMID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJWaWV3XSwgeyB0eXBlOiBzb3VyY2VEZWYubWltZVR5cGUgfSk7XG4gICAgICAgIHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBzb3VyY2VVUkk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURlZi51cmkgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgXCIgKyBzb3VyY2VJbmRleCArIFwiIGlzIG1pc3NpbmcgVVJJIGFuZCBidWZmZXJWaWV3XCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZVVSSSkudGhlbihmdW5jdGlvbihzb3VyY2VVUkkyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBvbkxvYWQgPSByZXNvbHZlO1xuICAgICAgICBpZiAobG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBvbkxvYWQgPSBmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlQml0bWFwKTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoc291cmNlVVJJMiwgb3B0aW9ucy5wYXRoKSwgb25Mb2FkLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmIChpc09iamVjdFVSTCA9PT0gdHJ1ZSkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVSSSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHRleHR1cmUsIHNvdXJjZURlZik7XG4gICAgICB0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gc291cmNlRGVmLm1pbWVUeXBlIHx8IGdldEltYWdlVVJJTWltZVR5cGUoc291cmNlRGVmLnVyaSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IENvdWxkbid0IGxvYWQgdGV4dHVyZVwiLCBzb3VyY2VVUkkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcbiAgICogQHJldHVybiB7UHJvbWlzZTxUZXh0dXJlPn1cbiAgICovXG4gIGFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiwgY29sb3JTcGFjZSkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcInRleHR1cmVcIiwgbWFwRGVmLmluZGV4KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmICghdGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobWFwRGVmLnRleENvb3JkICE9PSB2b2lkIDAgJiYgbWFwRGVmLnRleENvb3JkID4gMCkge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICB0ZXh0dXJlLmNoYW5uZWwgPSBtYXBEZWYudGV4Q29vcmQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB2b2lkIDAgPyBtYXBEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0gOiB2b2lkIDA7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBnbHRmUmVmZXJlbmNlID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQodGV4dHVyZSk7XG4gICAgICAgICAgdGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXS5leHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2xvclNwYWNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvclNwYWNlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgIGNvbG9yU3BhY2UgPSBjb2xvclNwYWNlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgICBpZiAoXCJjb2xvclNwYWNlXCIgaW4gdGV4dHVyZSlcbiAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlID8gc1JHQkVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtc1ttYXBOYW1lXSA9IHRleHR1cmU7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG4gICAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG4gICAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG4gICAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuICAgKi9cbiAgYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIGxldCBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG4gICAgY29uc3QgdXNlRGVyaXZhdGl2ZVRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ID09PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlVmVydGV4Q29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZUZsYXRTaGFkaW5nID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IHZvaWQgMDtcbiAgICBpZiAobWVzaC5pc1BvaW50cykge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIlBvaW50c01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBwb2ludHNNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghcG9pbnRzTWF0ZXJpYWwpIHtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50c01hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gcG9pbnRzTWF0ZXJpYWw7XG4gICAgfSBlbHNlIGlmIChtZXNoLmlzTGluZSkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIkxpbmVCYXNpY01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWxpbmVNYXRlcmlhbCkge1xuICAgICAgICBsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgbGluZU1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gbGluZU1hdGVyaWFsO1xuICAgIH1cbiAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZykge1xuICAgICAgbGV0IGNhY2hlS2V5ID0gXCJDbG9uZWRNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQgKyBcIjpcIjtcbiAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZGVyaXZhdGl2ZS10YW5nZW50czpcIjtcbiAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwidmVydGV4LWNvbG9yczpcIjtcbiAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJmbGF0LXNoYWRpbmc6XCI7XG4gICAgICBsZXQgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWNhY2hlZE1hdGVyaWFsKSB7XG4gICAgICAgIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKSB7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBjYWNoZWRNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG1hdGVyaWFsKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuICAgIH1cbiAgICBtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG4gICAqL1xuICBsb2FkTWF0ZXJpYWwobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgbGV0IG1hdGVyaWFsVHlwZTtcbiAgICBjb25zdCBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGVyaWFsRXh0ZW5zaW9ucyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwge307XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGlmIChtYXRlcmlhbEV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXSkge1xuICAgICAgY29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdO1xuICAgICAgbWF0ZXJpYWxUeXBlID0ga211RXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuICAgICAgcGVuZGluZy5wdXNoKGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5zZXRSR0IoYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zLm1ldGFsbmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA6IDE7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDE7XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1ldGFsbmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInJvdWdobmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsVHlwZSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5nZXRNYXRlcmlhbFR5cGUgJiYgZXh0LmdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmRvdWJsZVNpZGVkID09PSB0cnVlKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaWRlID0gRG91YmxlU2lkZTtcbiAgICB9XG4gICAgY29uc3QgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcbiAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSykge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdm9pZCAwID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm5vcm1hbE1hcFwiLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlKSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldChzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhb01hcFwiLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlKSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgY29uc3QgZW1pc3NpdmVGYWN0b3IgPSBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuc2V0UkdCKFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclswXSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMV0sXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzJdLFxuICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJlbWlzc2l2ZU1hcFwiLCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5uYW1lKVxuICAgICAgICBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1hdGVyaWFsLCB7IG1hdGVyaWFsczogbWF0ZXJpYWxJbmRleCB9KTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICAvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cbiAgY3JlYXRlVW5pcXVlTmFtZShvcmlnaW5hbE5hbWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUob3JpZ2luYWxOYW1lIHx8IFwiXCIpO1xuICAgIGlmIChzYW5pdGl6ZWROYW1lIGluIHRoaXMubm9kZU5hbWVzVXNlZCkge1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWUgKyBcIl9cIiArICsrdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV0gPSAwO1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dlb21ldHJ5XG4gICAqXG4gICAqIENyZWF0ZXMgQnVmZmVyR2VvbWV0cmllcyBmcm9tIHByaW1pdGl2ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8R0xURi5QcmltaXRpdmU+fSBwcmltaXRpdmVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8QnVmZmVyR2VvbWV0cnk+Pn1cbiAgICovXG4gIGxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0uZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKS50aGVuKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgIHJldHVybiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZSk7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChjYWNoZWQucHJvbWlzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZ2VvbWV0cnlQcm9taXNlO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0pIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMobmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG4gICAgICAgIHBlbmRpbmcucHVzaChnZW9tZXRyeVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cbiAgICovXG4gIGxvYWRNZXNoKG1lc2hJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1ttZXNoSW5kZXhdO1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBwcmltaXRpdmVzW2ldLm1hdGVyaWFsID09PSB2b2lkIDAgPyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwodGhpcy5jYWNoZSkgOiB0aGlzLmdldERlcGVuZGVuY3koXCJtYXRlcmlhbFwiLCBwcmltaXRpdmVzW2ldLm1hdGVyaWFsKTtcbiAgICAgIHBlbmRpbmcucHVzaChtYXRlcmlhbCk7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaChwYXJzZXIubG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoMCwgcmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBtZXNoZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICAgIGxldCBtZXNoO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG1hdGVyaWFsc1tpXTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHwgcHJpbWl0aXZlLm1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgPyBuZXcgU2tpbm5lZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKSA6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgaWYgKG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCkge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1ApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVMb29wKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiBcIiArIHByaW1pdGl2ZS5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZik7XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobWVzaERlZi5uYW1lIHx8IFwibWVzaF9cIiArIG1lc2hJbmRleCk7XG4gICAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWVzaCwgbWVzaERlZik7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlKTtcbiAgICAgICAgcGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCk7XG4gICAgICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWVzaGVzW2ldLCB7XG4gICAgICAgICAgbWVzaGVzOiBtZXNoSW5kZXgsXG4gICAgICAgICAgcHJpbWl0aXZlczogaVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2hlc1swXSwgbWVzaERlZik7XG4gICAgICAgIHJldHVybiBtZXNoZXNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIGdyb3VwLCBtZXNoRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KGdyb3VwLCB7IG1lc2hlczogbWVzaEluZGV4IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuYWRkKG1lc2hlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG4gICAqL1xuICBsb2FkQ2FtZXJhKGNhbWVyYUluZGV4KSB7XG4gICAgbGV0IGNhbWVyYTtcbiAgICBjb25zdCBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1tjYW1lcmFJbmRleF07XG4gICAgY29uc3QgcGFyYW1zID0gY2FtZXJhRGVmW2NhbWVyYURlZi50eXBlXTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJwZXJzcGVjdGl2ZVwiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoXG4gICAgICAgIE1hdGhVdGlscy5yYWRUb0RlZyhwYXJhbXMueWZvdiksXG4gICAgICAgIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLFxuICAgICAgICBwYXJhbXMuem5lYXIgfHwgMSxcbiAgICAgICAgcGFyYW1zLnpmYXIgfHwgMmU2XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwib3J0aG9ncmFwaGljXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLXBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC1wYXJhbXMueW1hZywgcGFyYW1zLnpuZWFyLCBwYXJhbXMuemZhcik7XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYubmFtZSlcbiAgICAgIGNhbWVyYS5uYW1lID0gdGhpcy5jcmVhdGVVbmlxdWVOYW1lKGNhbWVyYURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGNhbWVyYSwgY2FtZXJhRGVmKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2tlbGV0b24+fVxuICAgKi9cbiAgbG9hZFNraW4oc2tpbkluZGV4KSB7XG4gICAgY29uc3Qgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1tza2luSW5kZXhdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBza2luRGVmLmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5fbG9hZE5vZGVTaGFsbG93KHNraW5EZWYuam9pbnRzW2ldKSk7XG4gICAgfVxuICAgIGlmIChza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IGludmVyc2VCaW5kTWF0cmljZXMgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3Qgam9pbnROb2RlcyA9IHJlc3VsdHM7XG4gICAgICBjb25zdCBib25lcyA9IFtdO1xuICAgICAgY29uc3QgYm9uZUludmVyc2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgam9pbnROb2RlID0gam9pbnROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGpvaW50Tm9kZSkge1xuICAgICAgICAgIGJvbmVzLnB1c2goam9pbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgIGlmIChpbnZlcnNlQmluZE1hdHJpY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXQuZnJvbUFycmF5KGludmVyc2VCaW5kTWF0cmljZXMuYXJyYXksIGkgKiAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVJbnZlcnNlcy5wdXNoKG1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5EZWYuam9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTa2VsZXRvbihib25lcywgYm9uZUludmVyc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG4gICAqL1xuICBsb2FkQW5pbWF0aW9uKGFuaW1hdGlvbkluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlZiA9IGpzb24uYW5pbWF0aW9uc1thbmltYXRpb25JbmRleF07XG4gICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiBcImFuaW1hdGlvbl9cIiArIGFuaW1hdGlvbkluZGV4O1xuICAgIGNvbnN0IHBlbmRpbmdOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdJbnB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nVGFyZ2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzW2ldO1xuICAgICAgY29uc3Qgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1tjaGFubmVsLnNhbXBsZXJdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG4gICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5vZGU7XG4gICAgICBjb25zdCBpbnB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLmlucHV0XSA6IHNhbXBsZXIuaW5wdXQ7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5vdXRwdXRdIDogc2FtcGxlci5vdXRwdXQ7XG4gICAgICBpZiAodGFyZ2V0Lm5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBwZW5kaW5nTm9kZXMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5hbWUpKTtcbiAgICAgIHBlbmRpbmdJbnB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGlucHV0KSk7XG4gICAgICBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgb3V0cHV0KSk7XG4gICAgICBwZW5kaW5nU2FtcGxlcnMucHVzaChzYW1wbGVyKTtcbiAgICAgIHBlbmRpbmdUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb2RlcyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nSW5wdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ091dHB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nU2FtcGxlcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1RhcmdldHMpXG4gICAgXSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gZGVwZW5kZW5jaWVzWzBdO1xuICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMV07XG4gICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMl07XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1szXTtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBkZXBlbmRlbmNpZXNbNF07XG4gICAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29yID0gb3V0cHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbaV07XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlLnVwZGF0ZU1hdHJpeCkge1xuICAgICAgICAgIG5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZFRyYWNrcyA9IHBhcnNlci5fY3JlYXRlQW5pbWF0aW9uVHJhY2tzKG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQpO1xuICAgICAgICBpZiAoY3JlYXRlZFRyYWNrcykge1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY3JlYXRlZFRyYWNrcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdHJhY2tzLnB1c2goY3JlYXRlZFRyYWNrc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoYW5pbWF0aW9uTmFtZSwgdm9pZCAwLCB0cmFja3MpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlRGVmLm1lc2ggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm1lc2hcIiwgbm9kZURlZi5tZXNoKS50aGVuKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoKTtcbiAgICAgIGlmIChub2RlRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIW8uaXNNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICBvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG5vZGVEZWYud2VpZ2h0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG4gICAqL1xuICBsb2FkTm9kZShub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlUGVuZGluZyA9IHBhcnNlci5fbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCk7XG4gICAgY29uc3QgY2hpbGRQZW5kaW5nID0gW107XG4gICAgY29uc3QgY2hpbGRyZW5EZWYgPSBub2RlRGVmLmNoaWxkcmVuIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuRGVmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNoaWxkUGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBjaGlsZHJlbkRlZltpXSkpO1xuICAgIH1cbiAgICBjb25zdCBza2VsZXRvblBlbmRpbmcgPSBub2RlRGVmLnNraW4gPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHBhcnNlci5nZXREZXBlbmRlbmN5KFwic2tpblwiLCBub2RlRGVmLnNraW4pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbbm9kZVBlbmRpbmcsIFByb21pc2UuYWxsKGNoaWxkUGVuZGluZyksIHNrZWxldG9uUGVuZGluZ10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdHNbMF07XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHJlc3VsdHNbMV07XG4gICAgICBjb25zdCBza2VsZXRvbiA9IHJlc3VsdHNbMl07XG4gICAgICBpZiAoc2tlbGV0b24gIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihtZXNoKSB7XG4gICAgICAgICAgaWYgKCFtZXNoLmlzU2tpbm5lZE1lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgbWVzaC5iaW5kKHNrZWxldG9uLCBfaWRlbnRpdHlNYXRyaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZS5hZGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLy8gLl9sb2FkTm9kZVNoYWxsb3coKSBwYXJzZXMgYSBzaW5nbGUgbm9kZS5cbiAgLy8gc2tpbiBhbmQgY2hpbGQgbm9kZXMgYXJlIGNyZWF0ZWQgYW5kIGFkZGVkIGluIC5sb2FkTm9kZSgpIChubyAnXycgcHJlZml4KS5cbiAgX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBpZiAodGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGVEZWYubmFtZSA/IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG5vZGVEZWYubmFtZSkgOiBcIlwiO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBtZXNoUHJvbWlzZSA9IHBhcnNlci5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlTWVzaCAmJiBleHQuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAobWVzaFByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChtZXNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiY2FtZXJhXCIsIG5vZGVEZWYuY2FtZXJhKS50aGVuKGZ1bmN0aW9uKGNhbWVyYSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwcm9taXNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdID0gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gbmV3IEJvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgR3JvdXAoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbm9kZSA9IG9iamVjdHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IE9iamVjdDNEKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gb2JqZWN0c1swXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBub2RlLmFkZChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYubmFtZSkge1xuICAgICAgICBub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG4gICAgICAgIG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLm1hdHJpeCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeC5mcm9tQXJyYXkobm9kZURlZi5tYXRyaXgpO1xuICAgICAgICBub2RlLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucG9zaXRpb24uZnJvbUFycmF5KG5vZGVEZWYudHJhbnNsYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KG5vZGVEZWYucm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnNjYWxlLmZyb21BcnJheShub2RlRGVmLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZXIuYXNzb2NpYXRpb25zLmhhcyhub2RlKSkge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChub2RlLCB7fSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlKS5ub2RlcyA9IG5vZGVJbmRleDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXA+fVxuICAgKi9cbiAgbG9hZFNjZW5lKHNjZW5lSW5kZXgpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1tzY2VuZUluZGV4XTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IEdyb3VwKCk7XG4gICAgaWYgKHNjZW5lRGVmLm5hbWUpXG4gICAgICBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoc2NlbmVEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGlmIChzY2VuZURlZi5leHRlbnNpb25zKVxuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZik7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbm9kZUlkc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBzY2VuZS5hZGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVkdWNlQXNzb2NpYXRpb25zID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVkdWNlZEFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcnNlci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgTWF0ZXJpYWwgfHwga2V5IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUudHJhdmVyc2UoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlMik7XG4gICAgICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KG5vZGUyLCBtYXBwaW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRBc3NvY2lhdGlvbnM7XG4gICAgICB9O1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucyA9IHJlZHVjZUFzc29jaWF0aW9ucyhzY2VuZSk7XG4gICAgICByZXR1cm4gc2NlbmU7XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvblRyYWNrcyhub2RlLCBpbnB1dEFjY2Vzc29yLCBvdXRwdXRBY2Nlc3Nvciwgc2FtcGxlciwgdGFyZ2V0KSB7XG4gICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSA6IG5vZGUudXVpZDtcbiAgICBjb25zdCB0YXJnZXROYW1lcyA9IFtdO1xuICAgIGlmIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdID09PSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0cykge1xuICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMpIHtcbiAgICAgICAgICB0YXJnZXROYW1lcy5wdXNoKG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3QudXVpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXROYW1lcy5wdXNoKHRhcmdldE5hbWUpO1xuICAgIH1cbiAgICBsZXQgVHlwZWRLZXlmcmFtZVRyYWNrO1xuICAgIHN3aXRjaCAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSkge1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzd2l0Y2ggKG91dHB1dEFjY2Vzc29yLml0ZW1TaXplKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHNhbXBsZXIuaW50ZXJwb2xhdGlvbiAhPT0gdm9pZCAwID8gSU5URVJQT0xBVElPTltzYW1wbGVyLmludGVycG9sYXRpb25dIDogSW50ZXJwb2xhdGVMaW5lYXI7XG4gICAgY29uc3Qgb3V0cHV0QXJyYXkgPSB0aGlzLl9nZXRBcnJheUZyb21BY2Nlc3NvcihvdXRwdXRBY2Nlc3Nvcik7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgY29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuICAgICAgICB0YXJnZXROYW1lc1tqXSArIFwiLlwiICsgUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSxcbiAgICAgICAgaW5wdXRBY2Nlc3Nvci5hcnJheSxcbiAgICAgICAgb3V0cHV0QXJyYXksXG4gICAgICAgIGludGVycG9sYXRpb25cbiAgICAgICk7XG4gICAgICBpZiAoc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSBcIkNVQklDU1BMSU5FXCIpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50KHRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrcztcbiAgfVxuICBfZ2V0QXJyYXlGcm9tQWNjZXNzb3IoYWNjZXNzb3IpIHtcbiAgICBsZXQgb3V0cHV0QXJyYXkgPSBhY2Nlc3Nvci5hcnJheTtcbiAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUob3V0cHV0QXJyYXkuY29uc3RydWN0b3IpO1xuICAgICAgY29uc3Qgc2NhbGVkID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXRBcnJheS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICBzY2FsZWRbal0gPSBvdXRwdXRBcnJheVtqXSAqIHNjYWxlO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgfVxuICBfY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50KHRyYWNrKSB7XG4gICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUocmVzdWx0KSB7XG4gICAgICBjb25zdCBpbnRlcnBvbGFudFR5cGUgPSB0aGlzIGluc3RhbmNlb2YgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgOiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcbiAgICAgIHJldHVybiBuZXcgaW50ZXJwb2xhbnRUeXBlKHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0KTtcbiAgICB9O1xuICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBib3ggPSBuZXcgQm94MygpO1xuICBpZiAoYXR0cmlidXRlcy5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbYXR0cmlidXRlcy5QT1NJVElPTl07XG4gICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgIGJveC5zZXQobmV3IFZlY3RvcjMobWluWzBdLCBtaW5bMV0sIG1pblsyXSksIG5ldyBWZWN0b3IzKG1heFswXSwgbWF4WzFdLCBtYXhbMl0pKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgIGJveC5taW4ubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICBib3gubWF4Lm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcbiAgaWYgKHRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBpZiAodGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbdGFyZ2V0LlBPU0lUSU9OXTtcbiAgICAgICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgICAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZlY3Rvci5zZXRYKE1hdGgubWF4KE1hdGguYWJzKG1pblswXSksIE1hdGguYWJzKG1heFswXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WShNYXRoLm1heChNYXRoLmFicyhtaW5bMV0pLCBNYXRoLmFicyhtYXhbMV0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFooTWF0aC5tYXgoTWF0aC5hYnMobWluWzJdKSwgTWF0aC5hYnMobWF4WzJdKSkpO1xuICAgICAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF4RGlzcGxhY2VtZW50Lm1heCh2ZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYm94LmV4cGFuZEJ5VmVjdG9yKG1heERpc3BsYWNlbWVudCk7XG4gIH1cbiAgZ2VvbWV0cnkuYm91bmRpbmdCb3ggPSBib3g7XG4gIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAgYm94LmdldENlbnRlcihzcGhlcmUuY2VudGVyKTtcbiAgc3BoZXJlLnJhZGl1cyA9IGJveC5taW4uZGlzdGFuY2VUbyhib3gubWF4KSAvIDI7XG4gIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xufVxuZnVuY3Rpb24gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBwZW5kaW5nID0gW107XG4gIGZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGFjY2Vzc29ySW5kZXgsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhY2Nlc3NvckluZGV4KS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYWNjZXNzb3IpO1xuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbZ2x0ZkF0dHJpYnV0ZU5hbWVdIHx8IGdsdGZBdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRocmVlQXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKVxuICAgICAgY29udGludWU7XG4gICAgcGVuZGluZy5wdXNoKGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGF0dHJpYnV0ZXNbZ2x0ZkF0dHJpYnV0ZU5hbWVdLCB0aHJlZUF0dHJpYnV0ZU5hbWUpKTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHZvaWQgMCAmJiAhZ2VvbWV0cnkuaW5kZXgpIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgcHJpbWl0aXZlRGVmLmluZGljZXMpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IyKSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChhY2Nlc3NvcjIpO1xuICAgIH0pO1xuICAgIHBlbmRpbmcucHVzaChhY2Nlc3Nvcik7XG4gIH1cbiAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShnZW9tZXRyeSwgcHJpbWl0aXZlRGVmKTtcbiAgY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCA/IGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLnRhcmdldHMsIHBhcnNlcikgOiBnZW9tZXRyeTtcbiAgfSk7XG59XG5leHBvcnQge1xuICBHTFRGTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xURkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/SVGLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGLoader: () => (/* binding */ SVGLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst COLOR_SPACE_SVG = \"srgb\";\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader2 extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager) {\n      super(manager);\n      this.defaultDPI = 90;\n      this.defaultUnit = \"px\";\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(\n        url,\n        function(text) {\n          try {\n            onLoad(scope.parse(text));\n          } catch (e) {\n            if (onError) {\n              onError(e);\n            } else {\n              console.error(e);\n            }\n            scope.manager.itemError(url);\n          }\n        },\n        onProgress,\n        onError\n      );\n    }\n    parse(text) {\n      const scope = this;\n      function parseNode(node, style) {\n        if (node.nodeType !== 1)\n          return;\n        const transform = getNodeTransform(node);\n        let isDefsNode = false;\n        let path = null;\n        switch (node.nodeName) {\n          case \"svg\":\n            style = parseStyle(node, style);\n            break;\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\"))\n              path = parsePathNode(node);\n            break;\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n          case \"defs\":\n            isDefsNode = true;\n            break;\n          case \"use\":\n            style = parseStyle(node, style);\n            const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n            const usedNodeId = href.substring(1);\n            const usedNode = node.viewportElement.getElementById(usedNodeId);\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n            break;\n        }\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n          }\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = { node, style };\n        }\n        const childNodes = node.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n          const node2 = childNodes[i];\n          if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n            continue;\n          }\n          parseNode(node2, style);\n        }\n        if (transform) {\n          transformStack.pop();\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n      function parsePathNode(node) {\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const control = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const firstPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        let isFirstPoint = true;\n        let doSetFirstPoint = false;\n        const d = node.getAttribute(\"d\");\n        if (d === \"\" || d === \"none\")\n          return null;\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i];\n          const type = command.charAt(0);\n          const data2 = command.slice(1).trim();\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n          let numbers;\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"H\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"V\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"L\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"C\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5]\n                );\n                control.x = numbers[j + 2];\n                control.y = numbers[j + 3];\n                point.x = numbers[j + 4];\n                point.y = numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"S\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3]\n                );\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"Q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"T\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                  continue;\n                const start = point.clone();\n                point.x = numbers[j + 5];\n                point.y = numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point\n                );\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"m\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"h\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"v\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"l\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"c\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5]\n                );\n                control.x = point.x + numbers[j + 2];\n                control.y = point.y + numbers[j + 3];\n                point.x += numbers[j + 4];\n                point.y += numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"s\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3]\n                );\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3]\n                );\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"t\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = point.x + numbers[j + 0];\n                point.y = point.y + numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                  continue;\n                const start = point.clone();\n                point.x += numbers[j + 5];\n                point.y += numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point\n                );\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n              break;\n            default:\n              console.warn(command);\n          }\n          doSetFirstPoint = false;\n        }\n        return path;\n      }\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n          return;\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1)\n            continue;\n          const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n          for (let j = 0; j < selectorList.length; j++) {\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n          }\n        }\n      }\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        const dx2 = (start.x - end.x) / 2;\n        const dy2 = (start.y - end.y) / 2;\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        let rxs = rx * rx;\n        let rys = ry * ry;\n        const x1ps = x1p * x1p;\n        const y1ps = y1p * y1p;\n        const cr = x1ps / rxs + y1ps / rys;\n        if (cr > 1) {\n          const s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n        const dq = rxs * y1ps + rys * x1ps;\n        const pq = (rxs * rys - dq) / dq;\n        let q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag)\n          q = -q;\n        const cxp = q * rx * y1p / ry;\n        const cyp = -q * ry * x1p / rx;\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy;\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0)\n          ang = -ang;\n        return ang;\n      }\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        const bci = 1 - 0.551915024494;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n        path.lineTo(x + w, y + h - ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n        path.lineTo(x + rx, y + h);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n        path.lineTo(x, y + ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n        return path;\n      }\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        let stylesheetStyles = {};\n        if (node.hasAttribute(\"class\")) {\n          const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0)\n            adjustFunction = function copy(v) {\n              if (v.startsWith(\"url\"))\n                console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n              return v;\n            };\n          if (node.hasAttribute(svgName))\n            style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName])\n            style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\")\n            style[jsName] = adjustFunction(node.style[svgName]);\n        }\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        const SEP = 0;\n        const INT = 1;\n        const FLOAT = 2;\n        const EXP = 3;\n        let state = SEP;\n        let seenComma = true;\n        let number = \"\", exponent = \"\";\n        const result = [];\n        function throwSyntaxError(current2, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\")\n              result.push(Number(number));\n            else\n              result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n          number = \"\";\n          exponent = \"\";\n        }\n        let current;\n        const length = input.length;\n        for (let i = 0; i < length; i++) {\n          current = input[i];\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n              seenComma = true;\n            }\n          }\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        newNumber();\n        return result;\n      }\n      const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n      function parseFloatWithUnits(string) {\n        let theUnit = \"px\";\n        if (typeof string === \"string\" || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i];\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n        let scale = void 0;\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n        return scale * parseFloat(string);\n      }\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n        const transform = parseNodeTransform(node);\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n      function parseNodeTransform(node) {\n        const transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n        const currentTransform2 = tempTransform0;\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n        if (node.hasAttribute(\"transform\")) {\n          const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\")\n              continue;\n            const openParPos = transformText.indexOf(\"(\");\n            const closeParPos = transformText.length;\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos);\n              const array = parseFloats(transformText.slice(openParPos + 1));\n              currentTransform2.identity();\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    const tx = array[0];\n                    let ty = 0;\n                    if (array.length >= 2) {\n                      ty = array[1];\n                    }\n                    currentTransform2.translate(tx, ty);\n                  }\n                  break;\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    let angle = 0;\n                    let cx = 0;\n                    let cy = 0;\n                    angle = array[0] * Math.PI / 180;\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n                    tempTransform1.makeTranslation(-cx, -cy);\n                    tempTransform2.makeRotation(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.makeTranslation(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n                  break;\n                case \"scale\":\n                  if (array.length >= 1) {\n                    const scaleX = array[0];\n                    let scaleY = scaleX;\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n                  break;\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n                  break;\n              }\n            }\n            transform.premultiply(currentTransform2);\n          }\n        }\n        return transform;\n      }\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n        function transfEllipseGeneric(curve) {\n          const a = curve.xRadius;\n          const b = curve.yRadius;\n          const cosTheta = Math.cos(curve.aRotation);\n          const sinTheta = Math.sin(curve.aRotation);\n          const v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(a * cosTheta, a * sinTheta, 0);\n          const v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b * sinTheta, b * cosTheta, 0);\n          const f1 = v1.applyMatrix3(m);\n          const f2 = v2.applyMatrix3(m);\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n          const mFInv = tempTransform1.copy(mF).invert();\n          const mFInvT = tempTransform2.copy(mFInv).transpose();\n          const mQ = mFInvT.multiply(mFInv);\n          const mQe = mQ.elements;\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n          const rt1sqrt = Math.sqrt(ed.rt1);\n          const rt2sqrt = Math.sqrt(ed.rt2);\n          curve.xRadius = 1 / rt1sqrt;\n          curve.yRadius = 1 / rt2sqrt;\n          curve.aRotation = Math.atan2(ed.sn, ed.cs);\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n              return Math.atan2(sinR, cosR);\n            };\n            curve.aStartAngle = transformAngle(curve.aStartAngle);\n            curve.aEndAngle = transformAngle(curve.aEndAngle);\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise;\n            }\n          }\n        }\n        function transfEllipseNoSkew(curve) {\n          const sx = getTransformScaleX(m);\n          const sy = getTransformScaleY(m);\n          curve.xRadius *= sx;\n          curve.yRadius *= sy;\n          const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n          curve.aRotation += theta;\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1;\n            curve.aEndAngle *= -1;\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n        const subPaths = path.subPaths;\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i];\n          const curves = subPath.curves;\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j];\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve);\n              } else {\n                transfEllipseNoSkew(curve);\n              }\n            }\n          }\n        }\n      }\n      function isTransformFlipped(m) {\n        const te = m.elements;\n        return te[0] * te[4] - te[1] * te[3] < 0;\n      }\n      function isTransformSkewed(m) {\n        const te = m.elements;\n        const basisDot = te[0] * te[3] + te[1] * te[4];\n        if (basisDot === 0)\n          return false;\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n      }\n      function getTransformScaleX(m) {\n        const te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n      function getTransformScaleY(m) {\n        const te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t;\n        const sm = A + C;\n        const df = A - C;\n        const rt = Math.sqrt(df * df + 4 * B * B);\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt);\n          t = 1 / rt1;\n          rt2 = A * t * C - B * t * B;\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt);\n        } else {\n          rt1 = 0.5 * rt;\n          rt2 = -0.5 * rt;\n        }\n        if (df > 0) {\n          cs = df + rt;\n        } else {\n          cs = df - rt;\n        }\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = -2 * B / cs;\n          sn = 1 / Math.sqrt(1 + t * t);\n          cs = t * sn;\n        } else if (Math.abs(B) === 0) {\n          cs = 1;\n          sn = 0;\n        } else {\n          t = -0.5 * cs / B;\n          cs = 1 / Math.sqrt(1 + t * t);\n          sn = t * cs;\n        }\n        if (df > 0) {\n          t = cs;\n          cs = -sn;\n          sn = t;\n        }\n        return { rt1, rt2, cs, sn };\n      }\n      const paths = [];\n      const stylesheets = {};\n      const transformStack = [];\n      const tempTransform0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const currentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      const data = { paths, xml: xml.documentElement };\n      return data;\n    }\n    static createShapes(shapePath) {\n      const BIGNUMBER = 999999999;\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x;\n        const x2 = a1.x;\n        const x3 = b0.x;\n        const x4 = b1.x;\n        const y1 = a0.y;\n        const y2 = a1.y;\n        const y3 = b0.y;\n        const y4 = b1.y;\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        const t1 = nom1 / denom;\n        const t2 = nom2 / denom;\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return { x: point.x, y: point.y, t: classifyResult.t };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return { x, y, t: classifyResult.t };\n            }\n          }\n          return null;\n        } else {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return { x: point.x, y: point.y, t: classifyResult.t };\n            }\n          }\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n          return { x, y, t: t1 };\n        }\n      }\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x;\n        const ay = edgeEnd.y - edgeStart.y;\n        const bx = p.x - edgeStart.x;\n        const by = p.y - edgeStart.y;\n        const sa = ax * by - bx * ay;\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n        let t;\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = [];\n        const intersections = [];\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1];\n          const path1EdgeEnd = path1[index];\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1];\n            const path2EdgeEnd = path2[index2];\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n            if (intersection !== null && intersectionsRaw.find(\n              (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON\n            ) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(intersection.x, intersection.y));\n            }\n          }\n        }\n        return intersections;\n      }\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        boundingBox.getCenter(center);\n        const allIntersections = [];\n        paths.forEach((path) => {\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points);\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n            });\n          }\n        });\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n        const centerBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        const scanline = [\n          new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMinX2, centerBoundingBox.y),\n          new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMaxX2, centerBoundingBox.y)\n        ];\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        const baseIntersections = [];\n        const otherIntersections = [];\n        scanlineIntersections.forEach((i2) => {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        const firstXOfPath = baseIntersections[0].point.x;\n        const stack = [];\n        let i = 0;\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n          i++;\n        }\n        stack.push(simplePath.identifier);\n        if (_fillRule === \"evenodd\") {\n          const isHole = stack.length % 2 === 0 ? true : false;\n          const isHoleFor = stack[stack.length - 2];\n          return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n        } else if (_fillRule === \"nonzero\") {\n          let isHole = true;\n          let isHoleFor = null;\n          let lastCWValue = null;\n          for (let i2 = 0; i2 < stack.length; i2++) {\n            const identifier = stack[i2];\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = false;\n              isHoleFor = identifier;\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = true;\n            }\n          }\n          return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n      let scanlineMinX = BIGNUMBER;\n      let scanlineMaxX = -BIGNUMBER;\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints();\n        let maxY = -BIGNUMBER;\n        let minY = BIGNUMBER;\n        let maxX = -BIGNUMBER;\n        let minX = BIGNUMBER;\n        for (let i = 0; i < points.length; i++) {\n          const p2 = points[i];\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n        return {\n          curves: p.curves,\n          points,\n          isCW: three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new three__WEBPACK_IMPORTED_MODULE_0__.Box2(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(minX, minY), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier;\n      }\n      const isAHole = simplePaths.map(\n        (p) => isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : void 0\n        )\n      );\n      const shapesToReturn = [];\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier];\n        if (!amIAHole.isHole) {\n          const shape = new three__WEBPACK_IMPORTED_MODULE_0__.Shape();\n          shape.curves = p.curves;\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier];\n            const path = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      if (SVGLoader2.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n      const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n      geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      const tempV2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_6 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_7 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const lastPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const lastPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const point0L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const point0R = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const currentPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const currentPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const nextPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const nextPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const innerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const outerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      const numPoints = points.length;\n      if (numPoints < 2)\n        return 0;\n      const isClosed = points[0].equals(points[numPoints - 1]);\n      let currentPoint;\n      let previousPoint = points[0];\n      let nextPoint;\n      const strokeWidth2 = style.strokeWidth / 2;\n      const deltaU = 1 / (numPoints - 1);\n      let u0 = 0, u1;\n      let innerSideModified;\n      let joinIsOnLeftSide;\n      let isMiter;\n      let initialJoinIsOnLeftSide = false;\n      let numVertices = 0;\n      let currentCoordinate = vertexOffset * 3;\n      let currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else\n            nextPoint = void 0;\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n        const normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n          if (iPoint === 1)\n            initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          const dot = Math.abs(normal1.dot(tempV2_3));\n          if (dot > Number.EPSILON) {\n            const miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            const miterLength2 = tempV2_5.length();\n            const segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            const segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n                break;\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                  isMiter = true;\n                }\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        let lastOuter = outerPoint;\n        let lastInner = innerPoint;\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n      return numVertices;\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n          currentCoordinate += 3;\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n        numVertices += 3;\n      }\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        let angle = Math.PI;\n        const dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1)\n          angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 0);\n        addVertex(currentPointR, u1, 1);\n      }\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(innerPoint, u, 0);\n            addVertex(nextPointR, u, 1);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n            break;\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              const vl = vertices.length;\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n            break;\n        }\n      }\n      function removeDuplicatedPoints(points2) {\n        let dupPoints = false;\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n        if (!dupPoints)\n          return points2;\n        const newPoints = [];\n        newPoints.push(points2[0]);\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n            newPoints.push(points2[i]);\n          }\n        }\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }\n  return SVGLoader2;\n})();\n\n//# sourceMappingURL=SVGLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvU1ZHTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdKO0FBQ3hKO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEMsMEJBQTBCLDBDQUFPO0FBQ2pDLDRCQUE0QiwwQ0FBTztBQUNuQywrQkFBK0IsMENBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUFJO0FBQ2hDO0FBQ0EseUJBQXlCLDRDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQUk7QUFDaEM7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFHQztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsb2FkZXJzXFxTVkdMb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBNYXRyaXgzLCBWZWN0b3IyLCBWZWN0b3IzLCBTaGFwZVV0aWxzLCBCb3gyLCBTaGFwZSwgUGF0aCwgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIFNoYXBlUGF0aCB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgQ09MT1JfU1BBQ0VfU1ZHID0gXCJzcmdiXCI7XG5jb25zdCBTVkdMb2FkZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY2xhc3MgU1ZHTG9hZGVyMiBleHRlbmRzIExvYWRlciB7XG4gICAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgICAgc3VwZXIobWFuYWdlcik7XG4gICAgICB0aGlzLmRlZmF1bHREUEkgPSA5MDtcbiAgICAgIHRoaXMuZGVmYXVsdFVuaXQgPSBcInB4XCI7XG4gICAgfVxuICAgIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuICAgICAgbG9hZGVyLnNldFBhdGgoc2NvcGUucGF0aCk7XG4gICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcihzY29wZS5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgIGxvYWRlci5sb2FkKFxuICAgICAgICB1cmwsXG4gICAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb25Mb2FkKHNjb3BlLnBhcnNlKHRleHQpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzLFxuICAgICAgICBvbkVycm9yXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZSh0ZXh0KSB7XG4gICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBwYXJzZU5vZGUobm9kZSwgc3R5bGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXROb2RlVHJhbnNmb3JtKG5vZGUpO1xuICAgICAgICBsZXQgaXNEZWZzTm9kZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcGF0aCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgIHBhcnNlQ1NTU3R5bGVzaGVldChub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJkXCIpKVxuICAgICAgICAgICAgICBwYXRoID0gcGFyc2VQYXRoTm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgcGF0aCA9IHBhcnNlUmVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicG9seWdvblwiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXJzZVBvbHlnb25Ob2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBvbHlsaW5lXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgcGF0aCA9IHBhcnNlUG9seWxpbmVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXJzZUNpcmNsZU5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXJzZUVsbGlwc2VOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBwYXRoID0gcGFyc2VMaW5lTm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkZWZzXCI6XG4gICAgICAgICAgICBpc0RlZnNOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ1c2VcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gbm9kZS5nZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCB1c2VkTm9kZUlkID0gaHJlZi5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBjb25zdCB1c2VkTm9kZSA9IG5vZGUudmlld3BvcnRFbGVtZW50LmdldEVsZW1lbnRCeUlkKHVzZWROb2RlSWQpO1xuICAgICAgICAgICAgaWYgKHVzZWROb2RlKSB7XG4gICAgICAgICAgICAgIHBhcnNlTm9kZSh1c2VkTm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU1ZHTG9hZGVyOiAndXNlIG5vZGUnIHJlZmVyZW5jZXMgbm9uLWV4aXN0ZW50IG5vZGUgaWQ6IFwiICsgdXNlZE5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIGlmIChzdHlsZS5maWxsICE9PSB2b2lkIDAgJiYgc3R5bGUuZmlsbCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHBhdGguY29sb3Iuc2V0U3R5bGUoc3R5bGUuZmlsbCwgQ09MT1JfU1BBQ0VfU1ZHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNmb3JtUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtKTtcbiAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIHBhdGgudXNlckRhdGEgPSB7IG5vZGUsIHN0eWxlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZTIgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGlmIChpc0RlZnNOb2RlICYmIG5vZGUyLm5vZGVOYW1lICE9PSBcInN0eWxlXCIgJiYgbm9kZTIubm9kZU5hbWUgIT09IFwiZGVmc1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VOb2RlKG5vZGUyLCBzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIHRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLmNvcHkodHJhbnNmb3JtU3RhY2tbdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZVBhdGhOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgICBjb25zdCBjb250cm9sID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIGxldCBpc0ZpcnN0UG9pbnQgPSB0cnVlO1xuICAgICAgICBsZXQgZG9TZXRGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGQgPSBub2RlLmdldEF0dHJpYnV0ZShcImRcIik7XG4gICAgICAgIGlmIChkID09PSBcIlwiIHx8IGQgPT09IFwibm9uZVwiKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IGQubWF0Y2goL1thLWRmLXpdW15hLWRmLXpdKi9naSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY29tbWFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBjb21tYW5kLmNoYXJBdCgwKTtcbiAgICAgICAgICBjb25zdCBkYXRhMiA9IGNvbW1hbmQuc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICAgIGlmIChpc0ZpcnN0UG9pbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRvU2V0Rmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgICAgICBpc0ZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG51bWJlcnM7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMClcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gbnVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNikge1xuICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDBdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgNF0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyA1XVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gbnVtYmVyc1tqICsgMl07XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDRdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyA1XTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgZ2V0UmVmbGVjdGlvbihwb2ludC54LCBjb250cm9sLngpLFxuICAgICAgICAgICAgICAgICAgZ2V0UmVmbGVjdGlvbihwb2ludC55LCBjb250cm9sLnkpLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgM11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhudW1iZXJzW2ogKyAwXSwgbnVtYmVyc1tqICsgMV0sIG51bWJlcnNbaiArIDJdLCBudW1iZXJzW2ogKyAzXSk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnggPSBnZXRSZWZsZWN0aW9uKHBvaW50LngsIGNvbnRyb2wueCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnkgPSBnZXRSZWZsZWN0aW9uKHBvaW50LnksIGNvbnRyb2wueSk7XG4gICAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgbnVtYmVyc1tqICsgMF0sIG51bWJlcnNbaiArIDFdKTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSByeDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSByeTtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIsIFszLCA0XSwgNyk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNykge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXJzW2ogKyA1XSA9PSBwb2ludC54ICYmIG51bWJlcnNbaiArIDZdID09IHBvaW50LnkpXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvaW50LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDVdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyA2XTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGFyc2VBcmNDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbal0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgM10sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyA0XSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgIHBvaW50LnggKz0gbnVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50LnggKz0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgICAgcG9pbnQueSArPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNikge1xuICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyA0XSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyA1XVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDRdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgNV07XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgIGdldFJlZmxlY3Rpb24ocG9pbnQueCwgY29udHJvbC54KSxcbiAgICAgICAgICAgICAgICAgIGdldFJlZmxlY3Rpb24ocG9pbnQueSwgY29udHJvbC55KSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ4ID0gZ2V0UmVmbGVjdGlvbihwb2ludC54LCBjb250cm9sLngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ5ID0gZ2V0UmVmbGVjdGlvbihwb2ludC55LCBjb250cm9sLnkpO1xuICAgICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSwgcG9pbnQueSArIG51bWJlcnNbaiArIDFdKTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSByeDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSByeTtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwb2ludC55ICsgbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMiwgWzMsIDRdLCA3KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA3KSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlcnNbaiArIDVdID09IDAgJiYgbnVtYmVyc1tqICsgNl0gPT0gMClcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDVdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgNl07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhcnNlQXJjQ29tbWFuZChcbiAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2pdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgNF0sXG4gICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAgIHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKHBhdGguY3VycmVudFBhdGguY3VydmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludC5jb3B5KGZpcnN0UG9pbnQpO1xuICAgICAgICAgICAgICAgIHBhdGguY3VycmVudFBhdGguY3VycmVudFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29tbWFuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VDU1NTdHlsZXNoZWV0KG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnNoZWV0IHx8ICFub2RlLnNoZWV0LmNzc1J1bGVzIHx8ICFub2RlLnNoZWV0LmNzc1J1bGVzLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBub2RlLnNoZWV0LmNzc1J1bGVzW2ldO1xuICAgICAgICAgIGlmIChzdHlsZXNoZWV0LnR5cGUgIT09IDEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rvckxpc3QgPSBzdHlsZXNoZWV0LnNlbGVjdG9yVGV4dC5zcGxpdCgvLC9nbSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgoaTIpID0+IGkyLnRyaW0oKSk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rvckxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHN0eWxlc2hlZXQuc3R5bGUpLmZpbHRlcigoWywgdl0pID0+IHYgIT09IFwiXCIpKTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXRzW3NlbGVjdG9yTGlzdFtqXV0gPSBPYmplY3QuYXNzaWduKHN0eWxlc2hlZXRzW3NlbGVjdG9yTGlzdFtqXV0gfHwge30sIGRlZmluaXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQXJjQ29tbWFuZChwYXRoLCByeCwgcnksIHhfYXhpc19yb3RhdGlvbiwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHJ4ID09IDAgfHwgcnkgPT0gMCkge1xuICAgICAgICAgIHBhdGgubGluZVRvKGVuZC54LCBlbmQueSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHhfYXhpc19yb3RhdGlvbiA9IHhfYXhpc19yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHJ4ID0gTWF0aC5hYnMocngpO1xuICAgICAgICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgICAgICAgY29uc3QgZHgyID0gKHN0YXJ0LnggLSBlbmQueCkgLyAyO1xuICAgICAgICBjb25zdCBkeTIgPSAoc3RhcnQueSAtIGVuZC55KSAvIDI7XG4gICAgICAgIGNvbnN0IHgxcCA9IE1hdGguY29zKHhfYXhpc19yb3RhdGlvbikgKiBkeDIgKyBNYXRoLnNpbih4X2F4aXNfcm90YXRpb24pICogZHkyO1xuICAgICAgICBjb25zdCB5MXAgPSAtTWF0aC5zaW4oeF9heGlzX3JvdGF0aW9uKSAqIGR4MiArIE1hdGguY29zKHhfYXhpc19yb3RhdGlvbikgKiBkeTI7XG4gICAgICAgIGxldCByeHMgPSByeCAqIHJ4O1xuICAgICAgICBsZXQgcnlzID0gcnkgKiByeTtcbiAgICAgICAgY29uc3QgeDFwcyA9IHgxcCAqIHgxcDtcbiAgICAgICAgY29uc3QgeTFwcyA9IHkxcCAqIHkxcDtcbiAgICAgICAgY29uc3QgY3IgPSB4MXBzIC8gcnhzICsgeTFwcyAvIHJ5cztcbiAgICAgICAgaWYgKGNyID4gMSkge1xuICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLnNxcnQoY3IpO1xuICAgICAgICAgIHJ4ID0gcyAqIHJ4O1xuICAgICAgICAgIHJ5ID0gcyAqIHJ5O1xuICAgICAgICAgIHJ4cyA9IHJ4ICogcng7XG4gICAgICAgICAgcnlzID0gcnkgKiByeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcSA9IHJ4cyAqIHkxcHMgKyByeXMgKiB4MXBzO1xuICAgICAgICBjb25zdCBwcSA9IChyeHMgKiByeXMgLSBkcSkgLyBkcTtcbiAgICAgICAgbGV0IHEgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgcHEpKTtcbiAgICAgICAgaWYgKGxhcmdlX2FyY19mbGFnID09PSBzd2VlcF9mbGFnKVxuICAgICAgICAgIHEgPSAtcTtcbiAgICAgICAgY29uc3QgY3hwID0gcSAqIHJ4ICogeTFwIC8gcnk7XG4gICAgICAgIGNvbnN0IGN5cCA9IC1xICogcnkgKiB4MXAgLyByeDtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLmNvcyh4X2F4aXNfcm90YXRpb24pICogY3hwIC0gTWF0aC5zaW4oeF9heGlzX3JvdGF0aW9uKSAqIGN5cCArIChzdGFydC54ICsgZW5kLngpIC8gMjtcbiAgICAgICAgY29uc3QgY3kgPSBNYXRoLnNpbih4X2F4aXNfcm90YXRpb24pICogY3hwICsgTWF0aC5jb3MoeF9heGlzX3JvdGF0aW9uKSAqIGN5cCArIChzdGFydC55ICsgZW5kLnkpIC8gMjtcbiAgICAgICAgY29uc3QgdGhldGEgPSBzdmdBbmdsZSgxLCAwLCAoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5KTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBzdmdBbmdsZSgoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5LCAoLXgxcCAtIGN4cCkgLyByeCwgKC15MXAgLSBjeXApIC8gcnkpICUgKE1hdGguUEkgKiAyKTtcbiAgICAgICAgcGF0aC5jdXJyZW50UGF0aC5hYnNlbGxpcHNlKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgdGhldGEgKyBkZWx0YSwgc3dlZXBfZmxhZyA9PT0gMCwgeF9heGlzX3JvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN2Z0FuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IHV4ICogdnggKyB1eSAqIHZ5O1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQodXggKiB1eCArIHV5ICogdXkpICogTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcbiAgICAgICAgbGV0IGFuZyA9IE1hdGguYWNvcyhNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZG90IC8gbGVuKSkpO1xuICAgICAgICBpZiAodXggKiB2eSAtIHV5ICogdnggPCAwKVxuICAgICAgICAgIGFuZyA9IC1hbmc7XG4gICAgICAgIHJldHVybiBhbmc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZVJlY3ROb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ4XCIpIHx8IDApO1xuICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInlcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInJ4XCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwicnlcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHJ5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInJ5XCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwicnhcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHcgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkdGhcIikpO1xuICAgICAgICBjb25zdCBoID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSk7XG4gICAgICAgIGNvbnN0IGJjaSA9IDEgLSAwLjU1MTkxNTAyNDQ5NDtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgcGF0aC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgdyAtIHJ4ICogYmNpLCB5LCB4ICsgdywgeSArIHJ5ICogYmNpLCB4ICsgdywgeSArIHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgdywgeSArIGggLSByeSAqIGJjaSwgeCArIHcgLSByeCAqIGJjaSwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgICAgaWYgKHJ4ICE9PSAwIHx8IHJ5ICE9PSAwKSB7XG4gICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHggKyByeCAqIGJjaSwgeSArIGgsIHgsIHkgKyBoIC0gcnkgKiBiY2ksIHgsIHkgKyBoIC0gcnkpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgKiBiY2ksIHggKyByeCAqIGJjaSwgeSwgeCArIHJ4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlUG9seWdvbk5vZGUobm9kZSkge1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvcihtYXRjaCwgYSwgYikge1xuICAgICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKGEpO1xuICAgICAgICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKGIpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gLyhbKy1dP1xcZCpcXC4/XFxkKyg/OmVbKy1dP1xcZCspPykoPzosfFxccykoWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pL2c7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpLnJlcGxhY2UocmVnZXgsIGl0ZXJhdG9yKTtcbiAgICAgICAgcGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlUG9seWxpbmVOb2RlKG5vZGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IobWF0Y2gsIGEsIGIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhhKTtcbiAgICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhiKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdleCA9IC8oWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pKD86LHxcXHMpKFsrLV0/XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KS9nO1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBub2RlLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKS5yZXBsYWNlKHJlZ2V4LCBpdGVyYXRvcik7XG4gICAgICAgIHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VDaXJjbGVOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJjeFwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJjeVwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgciA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyXCIpIHx8IDApO1xuICAgICAgICBjb25zdCBzdWJwYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICAgc3VicGF0aC5hYnNhcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgICBwYXRoLnN1YlBhdGhzLnB1c2goc3VicGF0aCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VFbGxpcHNlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiY3hcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiY3lcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInJ4XCIpIHx8IDApO1xuICAgICAgICBjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeVwiKSB8fCAwKTtcbiAgICAgICAgY29uc3Qgc3VicGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIHN1YnBhdGguYWJzZWxsaXBzZSh4LCB5LCByeCwgcnksIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgcGF0aC5zdWJQYXRocy5wdXNoKHN1YnBhdGgpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlTGluZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB4MSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ4MVwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgeTEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieTFcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHgyID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcIngyXCIpIHx8IDApO1xuICAgICAgICBjb25zdCB5MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ5MlwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgcGF0aC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgcGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUpO1xuICAgICAgICBsZXQgc3R5bGVzaGVldFN0eWxlcyA9IHt9O1xuICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJjbGFzc1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNsYXNzU2VsZWN0b3JzID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5zcGxpdCgvXFxzLykuZmlsdGVyKEJvb2xlYW4pLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlc2hlZXRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHN0eWxlc2hlZXRTdHlsZXMsIHN0eWxlc2hlZXRzW1wiLlwiICsgY2xhc3NTZWxlY3RvcnNbaV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwiaWRcIikpIHtcbiAgICAgICAgICBzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbihzdHlsZXNoZWV0U3R5bGVzLCBzdHlsZXNoZWV0c1tcIiNcIiArIG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIildKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRTdHlsZShzdmdOYW1lLCBqc05hbWUsIGFkanVzdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgaWYgKGFkanVzdEZ1bmN0aW9uID09PSB2b2lkIDApXG4gICAgICAgICAgICBhZGp1c3RGdW5jdGlvbiA9IGZ1bmN0aW9uIGNvcHkodikge1xuICAgICAgICAgICAgICBpZiAodi5zdGFydHNXaXRoKFwidXJsXCIpKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNWR0xvYWRlcjogdXJsIGFjY2VzcyBpbiBhdHRyaWJ1dGVzIGlzIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoc3ZnTmFtZSkpXG4gICAgICAgICAgICBzdHlsZVtqc05hbWVdID0gYWRqdXN0RnVuY3Rpb24obm9kZS5nZXRBdHRyaWJ1dGUoc3ZnTmFtZSkpO1xuICAgICAgICAgIGlmIChzdHlsZXNoZWV0U3R5bGVzW3N2Z05hbWVdKVxuICAgICAgICAgICAgc3R5bGVbanNOYW1lXSA9IGFkanVzdEZ1bmN0aW9uKHN0eWxlc2hlZXRTdHlsZXNbc3ZnTmFtZV0pO1xuICAgICAgICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGVbc3ZnTmFtZV0gIT09IFwiXCIpXG4gICAgICAgICAgICBzdHlsZVtqc05hbWVdID0gYWRqdXN0RnVuY3Rpb24obm9kZS5zdHlsZVtzdmdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xhbXAodikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0V2l0aFVuaXRzKHYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcG9zaXRpdmUodikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBwYXJzZUZsb2F0V2l0aFVuaXRzKHYpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRTdHlsZShcImZpbGxcIiwgXCJmaWxsXCIpO1xuICAgICAgICBhZGRTdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcImZpbGxPcGFjaXR5XCIsIGNsYW1wKTtcbiAgICAgICAgYWRkU3R5bGUoXCJmaWxsLXJ1bGVcIiwgXCJmaWxsUnVsZVwiKTtcbiAgICAgICAgYWRkU3R5bGUoXCJvcGFjaXR5XCIsIFwib3BhY2l0eVwiLCBjbGFtcCk7XG4gICAgICAgIGFkZFN0eWxlKFwic3Ryb2tlXCIsIFwic3Ryb2tlXCIpO1xuICAgICAgICBhZGRTdHlsZShcInN0cm9rZS1vcGFjaXR5XCIsIFwic3Ryb2tlT3BhY2l0eVwiLCBjbGFtcCk7XG4gICAgICAgIGFkZFN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwic3Ryb2tlV2lkdGhcIiwgcG9zaXRpdmUpO1xuICAgICAgICBhZGRTdHlsZShcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZUxpbmVKb2luXCIpO1xuICAgICAgICBhZGRTdHlsZShcInN0cm9rZS1saW5lY2FwXCIsIFwic3Ryb2tlTGluZUNhcFwiKTtcbiAgICAgICAgYWRkU3R5bGUoXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCBcInN0cm9rZU1pdGVyTGltaXRcIiwgcG9zaXRpdmUpO1xuICAgICAgICBhZGRTdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRSZWZsZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSAoYiAtIGEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VGbG9hdHMoaW5wdXQsIGZsYWdzLCBzdHJpZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0OiBcIiArIHR5cGVvZiBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgUkUgPSB7XG4gICAgICAgICAgU0VQQVJBVE9SOiAvWyBcXHRcXHJcXG5cXCwuXFwtK10vLFxuICAgICAgICAgIFdISVRFU1BBQ0U6IC9bIFxcdFxcclxcbl0vLFxuICAgICAgICAgIERJR0lUOiAvW1xcZF0vLFxuICAgICAgICAgIFNJR046IC9bLStdLyxcbiAgICAgICAgICBQT0lOVDogL1xcLi8sXG4gICAgICAgICAgQ09NTUE6IC8sLyxcbiAgICAgICAgICBFWFA6IC9lL2ksXG4gICAgICAgICAgRkxBR1M6IC9bMDFdL1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBTRVAgPSAwO1xuICAgICAgICBjb25zdCBJTlQgPSAxO1xuICAgICAgICBjb25zdCBGTE9BVCA9IDI7XG4gICAgICAgIGNvbnN0IEVYUCA9IDM7XG4gICAgICAgIGxldCBzdGF0ZSA9IFNFUDtcbiAgICAgICAgbGV0IHNlZW5Db21tYSA9IHRydWU7XG4gICAgICAgIGxldCBudW1iZXIgPSBcIlwiLCBleHBvbmVudCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQyLCBpLCBwYXJ0aWFsKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJyArIGN1cnJlbnQyICsgJ1wiIGF0IGluZGV4ICcgKyBpICsgXCIuXCIpO1xuICAgICAgICAgIGVycm9yLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5ld051bWJlcigpIHtcbiAgICAgICAgICBpZiAobnVtYmVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IFwiXCIpXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihudW1iZXIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTnVtYmVyKG51bWJlcikgKiBNYXRoLnBvdygxMCwgTnVtYmVyKGV4cG9uZW50KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgPSBcIlwiO1xuICAgICAgICAgIGV4cG9uZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudCA9IGlucHV0W2ldO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZsYWdzKSAmJiBmbGFncy5pbmNsdWRlcyhyZXN1bHQubGVuZ3RoICUgc3RyaWRlKSAmJiBSRS5GTEFHUy50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVDtcbiAgICAgICAgICAgIG51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IFNFUCkge1xuICAgICAgICAgICAgaWYgKFJFLldISVRFU1BBQ0UudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpIHx8IFJFLlNJR04udGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IElOVDtcbiAgICAgICAgICAgICAgbnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuUE9JTlQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZMT0FUO1xuICAgICAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSRS5DT01NQS50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIGlmIChzZWVuQ29tbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQsIGksIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VlbkNvbW1hID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBJTlQpIHtcbiAgICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBjdXJyZW50O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSRS5QT0lOVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBjdXJyZW50O1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZMT0FUO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSRS5FWFAudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEVYUDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuU0lHTi50ZXN0KGN1cnJlbnQpICYmIG51bWJlci5sZW5ndGggPT09IDEgJiYgUkUuU0lHTi50ZXN0KG51bWJlclswXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEZMT0FUKSB7XG4gICAgICAgICAgICBpZiAoUkUuRElHSVQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gY3VycmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuRVhQLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBFWFA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJFLlBPSU5ULnRlc3QoY3VycmVudCkgJiYgbnVtYmVyW251bWJlci5sZW5ndGggLSAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEVYUCkge1xuICAgICAgICAgICAgaWYgKFJFLkRJR0lULnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgZXhwb25lbnQgKz0gY3VycmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuU0lHTi50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGV4cG9uZW50ICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGV4cG9uZW50Lmxlbmd0aCA9PT0gMSAmJiBSRS5TSUdOLnRlc3QoZXhwb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRS5XSElURVNQQUNFLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgIG5ld051bWJlcigpO1xuICAgICAgICAgICAgc3RhdGUgPSBTRVA7XG4gICAgICAgICAgICBzZWVuQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFLkNPTU1BLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgIG5ld051bWJlcigpO1xuICAgICAgICAgICAgc3RhdGUgPSBTRVA7XG4gICAgICAgICAgICBzZWVuQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUkUuU0lHTi50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICAgIHN0YXRlID0gSU5UO1xuICAgICAgICAgICAgbnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFLlBPSU5ULnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgIG5ld051bWJlcigpO1xuICAgICAgICAgICAgc3RhdGUgPSBGTE9BVDtcbiAgICAgICAgICAgIG51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93U3ludGF4RXJyb3IoY3VycmVudCwgaSwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3TnVtYmVyKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bml0cyA9IFtcIm1tXCIsIFwiY21cIiwgXCJpblwiLCBcInB0XCIsIFwicGNcIiwgXCJweFwiXTtcbiAgICAgIGNvbnN0IHVuaXRDb252ZXJzaW9uID0ge1xuICAgICAgICBtbToge1xuICAgICAgICAgIG1tOiAxLFxuICAgICAgICAgIGNtOiAwLjEsXG4gICAgICAgICAgaW46IDEgLyAyNS40LFxuICAgICAgICAgIHB0OiA3MiAvIDI1LjQsXG4gICAgICAgICAgcGM6IDYgLyAyNS40LFxuICAgICAgICAgIHB4OiAtMVxuICAgICAgICB9LFxuICAgICAgICBjbToge1xuICAgICAgICAgIG1tOiAxMCxcbiAgICAgICAgICBjbTogMSxcbiAgICAgICAgICBpbjogMSAvIDIuNTQsXG4gICAgICAgICAgcHQ6IDcyIC8gMi41NCxcbiAgICAgICAgICBwYzogNiAvIDIuNTQsXG4gICAgICAgICAgcHg6IC0xXG4gICAgICAgIH0sXG4gICAgICAgIGluOiB7XG4gICAgICAgICAgbW06IDI1LjQsXG4gICAgICAgICAgY206IDIuNTQsXG4gICAgICAgICAgaW46IDEsXG4gICAgICAgICAgcHQ6IDcyLFxuICAgICAgICAgIHBjOiA2LFxuICAgICAgICAgIHB4OiAtMVxuICAgICAgICB9LFxuICAgICAgICBwdDoge1xuICAgICAgICAgIG1tOiAyNS40IC8gNzIsXG4gICAgICAgICAgY206IDIuNTQgLyA3MixcbiAgICAgICAgICBpbjogMSAvIDcyLFxuICAgICAgICAgIHB0OiAxLFxuICAgICAgICAgIHBjOiA2IC8gNzIsXG4gICAgICAgICAgcHg6IC0xXG4gICAgICAgIH0sXG4gICAgICAgIHBjOiB7XG4gICAgICAgICAgbW06IDI1LjQgLyA2LFxuICAgICAgICAgIGNtOiAyLjU0IC8gNixcbiAgICAgICAgICBpbjogMSAvIDYsXG4gICAgICAgICAgcHQ6IDcyIC8gNixcbiAgICAgICAgICBwYzogMSxcbiAgICAgICAgICBweDogLTFcbiAgICAgICAgfSxcbiAgICAgICAgcHg6IHtcbiAgICAgICAgICBweDogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcGFyc2VGbG9hdFdpdGhVbml0cyhzdHJpbmcpIHtcbiAgICAgICAgbGV0IHRoZVVuaXQgPSBcInB4XCI7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiIHx8IHN0cmluZyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdW5pdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gdW5pdHNbaV07XG4gICAgICAgICAgICBpZiAoc3RyaW5nLmVuZHNXaXRoKHUpKSB7XG4gICAgICAgICAgICAgIHRoZVVuaXQgPSB1O1xuICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHN0cmluZy5sZW5ndGggLSB1Lmxlbmd0aCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NhbGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGVVbml0ID09PSBcInB4XCIgJiYgc2NvcGUuZGVmYXVsdFVuaXQgIT09IFwicHhcIikge1xuICAgICAgICAgIHNjYWxlID0gdW5pdENvbnZlcnNpb25bXCJpblwiXVtzY29wZS5kZWZhdWx0VW5pdF0gLyBzY29wZS5kZWZhdWx0RFBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlID0gdW5pdENvbnZlcnNpb25bdGhlVW5pdF1bc2NvcGUuZGVmYXVsdFVuaXRdO1xuICAgICAgICAgIGlmIChzY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHNjYWxlID0gdW5pdENvbnZlcnNpb25bdGhlVW5pdF1bXCJpblwiXSAqIHNjb3BlLmRlZmF1bHREUEk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZSAqIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldE5vZGVUcmFuc2Zvcm0obm9kZSkge1xuICAgICAgICBpZiAoIShub2RlLmhhc0F0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSB8fCBub2RlLm5vZGVOYW1lID09PSBcInVzZVwiICYmIChub2RlLmhhc0F0dHJpYnV0ZShcInhcIikgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoXCJ5XCIpKSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBwYXJzZU5vZGVUcmFuc2Zvcm0obm9kZSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLnByZW11bHRpcGx5KHRyYW5zZm9ybVN0YWNrW3RyYW5zZm9ybVN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VHJhbnNmb3JtLmNvcHkodHJhbnNmb3JtKTtcbiAgICAgICAgdHJhbnNmb3JtU3RhY2sucHVzaCh0cmFuc2Zvcm0pO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VOb2RlVHJhbnNmb3JtKG5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybTIgPSB0ZW1wVHJhbnNmb3JtMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwidXNlXCIgJiYgKG5vZGUuaGFzQXR0cmlidXRlKFwieFwiKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShcInlcIikpKSB7XG4gICAgICAgICAgY29uc3QgdHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSk7XG4gICAgICAgICAgY29uc3QgdHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieVwiKSk7XG4gICAgICAgICAgdHJhbnNmb3JtLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybXNUZXh0cyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLnNwbGl0KFwiKVwiKTtcbiAgICAgICAgICBmb3IgKGxldCB0SW5kZXggPSB0cmFuc2Zvcm1zVGV4dHMubGVuZ3RoIC0gMTsgdEluZGV4ID49IDA7IHRJbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZXh0ID0gdHJhbnNmb3Jtc1RleHRzW3RJbmRleF0udHJpbSgpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVRleHQgPT09IFwiXCIpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qgb3BlblBhclBvcyA9IHRyYW5zZm9ybVRleHQuaW5kZXhPZihcIihcIik7XG4gICAgICAgICAgICBjb25zdCBjbG9zZVBhclBvcyA9IHRyYW5zZm9ybVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9wZW5QYXJQb3MgPiAwICYmIG9wZW5QYXJQb3MgPCBjbG9zZVBhclBvcykge1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UeXBlID0gdHJhbnNmb3JtVGV4dC5zbGljZSgwLCBvcGVuUGFyUG9zKTtcbiAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBwYXJzZUZsb2F0cyh0cmFuc2Zvcm1UZXh0LnNsaWNlKG9wZW5QYXJQb3MgKyAxKSk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLmlkZW50aXR5KCk7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHJhbnNmb3JtVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2xhdGVcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGFycmF5WzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eSA9IGFycmF5WzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gYXJyYXlbMF0gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjeCA9IGFycmF5WzFdO1xuICAgICAgICAgICAgICAgICAgICAgIGN5ID0gYXJyYXlbMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTEubWFrZVRyYW5zbGF0aW9uKC1jeCwgLWN5KTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTIubWFrZVJvdGF0aW9uKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTMubXVsdGlwbHlNYXRyaWNlcyh0ZW1wVHJhbnNmb3JtMiwgdGVtcFRyYW5zZm9ybTEpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wVHJhbnNmb3JtMS5tYWtlVHJhbnNsYXRpb24oY3gsIGN5KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybTIubXVsdGlwbHlNYXRyaWNlcyh0ZW1wVHJhbnNmb3JtMSwgdGVtcFRyYW5zZm9ybTMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxlXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gYXJyYXlbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVkgPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IGFycmF5WzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJza2V3WFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5zZXQoMSwgTWF0aC50YW4oYXJyYXlbMF0gKiBNYXRoLlBJIC8gMTgwKSwgMCwgMCwgMSwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2tld1lcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybTIuc2V0KDEsIDAsIDAsIE1hdGgudGFuKGFycmF5WzBdICogTWF0aC5QSSAvIDE4MCksIDEsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5zZXQoYXJyYXlbMF0sIGFycmF5WzJdLCBhcnJheVs0XSwgYXJyYXlbMV0sIGFycmF5WzNdLCBhcnJheVs1XSwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNmb3JtLnByZW11bHRpcGx5KGN1cnJlbnRUcmFuc2Zvcm0yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgbSkge1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2ZWZWMyKHYyKSB7XG4gICAgICAgICAgdGVtcFYzLnNldCh2Mi54LCB2Mi55LCAxKS5hcHBseU1hdHJpeDMobSk7XG4gICAgICAgICAgdjIuc2V0KHRlbXBWMy54LCB0ZW1wVjMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmRWxsaXBzZUdlbmVyaWMoY3VydmUpIHtcbiAgICAgICAgICBjb25zdCBhID0gY3VydmUueFJhZGl1cztcbiAgICAgICAgICBjb25zdCBiID0gY3VydmUueVJhZGl1cztcbiAgICAgICAgICBjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKGN1cnZlLmFSb3RhdGlvbik7XG4gICAgICAgICAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbihjdXJ2ZS5hUm90YXRpb24pO1xuICAgICAgICAgIGNvbnN0IHYxID0gbmV3IFZlY3RvcjMoYSAqIGNvc1RoZXRhLCBhICogc2luVGhldGEsIDApO1xuICAgICAgICAgIGNvbnN0IHYyID0gbmV3IFZlY3RvcjMoLWIgKiBzaW5UaGV0YSwgYiAqIGNvc1RoZXRhLCAwKTtcbiAgICAgICAgICBjb25zdCBmMSA9IHYxLmFwcGx5TWF0cml4MyhtKTtcbiAgICAgICAgICBjb25zdCBmMiA9IHYyLmFwcGx5TWF0cml4MyhtKTtcbiAgICAgICAgICBjb25zdCBtRiA9IHRlbXBUcmFuc2Zvcm0wLnNldChmMS54LCBmMi54LCAwLCBmMS55LCBmMi55LCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICBjb25zdCBtRkludiA9IHRlbXBUcmFuc2Zvcm0xLmNvcHkobUYpLmludmVydCgpO1xuICAgICAgICAgIGNvbnN0IG1GSW52VCA9IHRlbXBUcmFuc2Zvcm0yLmNvcHkobUZJbnYpLnRyYW5zcG9zZSgpO1xuICAgICAgICAgIGNvbnN0IG1RID0gbUZJbnZULm11bHRpcGx5KG1GSW52KTtcbiAgICAgICAgICBjb25zdCBtUWUgPSBtUS5lbGVtZW50cztcbiAgICAgICAgICBjb25zdCBlZCA9IGVpZ2VuRGVjb21wb3NpdGlvbihtUWVbMF0sIG1RZVsxXSwgbVFlWzRdKTtcbiAgICAgICAgICBjb25zdCBydDFzcXJ0ID0gTWF0aC5zcXJ0KGVkLnJ0MSk7XG4gICAgICAgICAgY29uc3QgcnQyc3FydCA9IE1hdGguc3FydChlZC5ydDIpO1xuICAgICAgICAgIGN1cnZlLnhSYWRpdXMgPSAxIC8gcnQxc3FydDtcbiAgICAgICAgICBjdXJ2ZS55UmFkaXVzID0gMSAvIHJ0MnNxcnQ7XG4gICAgICAgICAgY3VydmUuYVJvdGF0aW9uID0gTWF0aC5hdGFuMihlZC5zbiwgZWQuY3MpO1xuICAgICAgICAgIGNvbnN0IGlzRnVsbEVsbGlwc2UgPSAoY3VydmUuYUVuZEFuZ2xlIC0gY3VydmUuYVN0YXJ0QW5nbGUpICUgKDIgKiBNYXRoLlBJKSA8IE51bWJlci5FUFNJTE9OO1xuICAgICAgICAgIGlmICghaXNGdWxsRWxsaXBzZSkge1xuICAgICAgICAgICAgY29uc3QgbURzcXJ0ID0gdGVtcFRyYW5zZm9ybTEuc2V0KHJ0MXNxcnQsIDAsIDAsIDAsIHJ0MnNxcnQsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgY29uc3QgbVJUID0gdGVtcFRyYW5zZm9ybTIuc2V0KGVkLmNzLCBlZC5zbiwgMCwgLWVkLnNuLCBlZC5jcywgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICBjb25zdCBtRFJGID0gbURzcXJ0Lm11bHRpcGx5KG1SVCkubXVsdGlwbHkobUYpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtQW5nbGUgPSAocGhpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgeDogY29zUiwgeTogc2luUiB9ID0gbmV3IFZlY3RvcjMoTWF0aC5jb3MocGhpKSwgTWF0aC5zaW4ocGhpKSwgMCkuYXBwbHlNYXRyaXgzKG1EUkYpO1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihzaW5SLCBjb3NSKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJ2ZS5hU3RhcnRBbmdsZSA9IHRyYW5zZm9ybUFuZ2xlKGN1cnZlLmFTdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIGN1cnZlLmFFbmRBbmdsZSA9IHRyYW5zZm9ybUFuZ2xlKGN1cnZlLmFFbmRBbmdsZSk7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1GbGlwcGVkKG0pKSB7XG4gICAgICAgICAgICAgIGN1cnZlLmFDbG9ja3dpc2UgPSAhY3VydmUuYUNsb2Nrd2lzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmRWxsaXBzZU5vU2tldyhjdXJ2ZSkge1xuICAgICAgICAgIGNvbnN0IHN4ID0gZ2V0VHJhbnNmb3JtU2NhbGVYKG0pO1xuICAgICAgICAgIGNvbnN0IHN5ID0gZ2V0VHJhbnNmb3JtU2NhbGVZKG0pO1xuICAgICAgICAgIGN1cnZlLnhSYWRpdXMgKj0gc3g7XG4gICAgICAgICAgY3VydmUueVJhZGl1cyAqPSBzeTtcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IHN4ID4gTnVtYmVyLkVQU0lMT04gPyBNYXRoLmF0YW4yKG0uZWxlbWVudHNbMV0sIG0uZWxlbWVudHNbMF0pIDogTWF0aC5hdGFuMigtbS5lbGVtZW50c1szXSwgbS5lbGVtZW50c1s0XSk7XG4gICAgICAgICAgY3VydmUuYVJvdGF0aW9uICs9IHRoZXRhO1xuICAgICAgICAgIGlmIChpc1RyYW5zZm9ybUZsaXBwZWQobSkpIHtcbiAgICAgICAgICAgIGN1cnZlLmFTdGFydEFuZ2xlICo9IC0xO1xuICAgICAgICAgICAgY3VydmUuYUVuZEFuZ2xlICo9IC0xO1xuICAgICAgICAgICAgY3VydmUuYUNsb2Nrd2lzZSA9ICFjdXJ2ZS5hQ2xvY2t3aXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJQYXRocyA9IHBhdGguc3ViUGF0aHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHN1YlBhdGhzW2ldO1xuICAgICAgICAgIGNvbnN0IGN1cnZlcyA9IHN1YlBhdGguY3VydmVzO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VydmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJ2ZSA9IGN1cnZlc1tqXTtcbiAgICAgICAgICAgIGlmIChjdXJ2ZS5pc0xpbmVDdXJ2ZSkge1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYxKTtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnZlLmlzQ3ViaWNCZXppZXJDdXJ2ZSkge1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYwKTtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MSk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjIpO1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VydmUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSkge1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYwKTtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MSk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSkge1xuICAgICAgICAgICAgICB0ZW1wVjIuc2V0KGN1cnZlLmFYLCBjdXJ2ZS5hWSk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIodGVtcFYyKTtcbiAgICAgICAgICAgICAgY3VydmUuYVggPSB0ZW1wVjIueDtcbiAgICAgICAgICAgICAgY3VydmUuYVkgPSB0ZW1wVjIueTtcbiAgICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtU2tld2VkKG0pKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmRWxsaXBzZUdlbmVyaWMoY3VydmUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zZkVsbGlwc2VOb1NrZXcoY3VydmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc1RyYW5zZm9ybUZsaXBwZWQobSkge1xuICAgICAgICBjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIHJldHVybiB0ZVswXSAqIHRlWzRdIC0gdGVbMV0gKiB0ZVszXSA8IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc1RyYW5zZm9ybVNrZXdlZChtKSB7XG4gICAgICAgIGNvbnN0IHRlID0gbS5lbGVtZW50cztcbiAgICAgICAgY29uc3QgYmFzaXNEb3QgPSB0ZVswXSAqIHRlWzNdICsgdGVbMV0gKiB0ZVs0XTtcbiAgICAgICAgaWYgKGJhc2lzRG90ID09PSAwKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3ggPSBnZXRUcmFuc2Zvcm1TY2FsZVgobSk7XG4gICAgICAgIGNvbnN0IHN5ID0gZ2V0VHJhbnNmb3JtU2NhbGVZKG0pO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYmFzaXNEb3QgLyAoc3ggKiBzeSkpID4gTnVtYmVyLkVQU0lMT047XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TY2FsZVgobSkge1xuICAgICAgICBjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGVbMF0gKiB0ZVswXSArIHRlWzFdICogdGVbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVZKG0pIHtcbiAgICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRlWzNdICogdGVbM10gKyB0ZVs0XSAqIHRlWzRdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVpZ2VuRGVjb21wb3NpdGlvbihBLCBCLCBDKSB7XG4gICAgICAgIGxldCBydDEsIHJ0MiwgY3MsIHNuLCB0O1xuICAgICAgICBjb25zdCBzbSA9IEEgKyBDO1xuICAgICAgICBjb25zdCBkZiA9IEEgLSBDO1xuICAgICAgICBjb25zdCBydCA9IE1hdGguc3FydChkZiAqIGRmICsgNCAqIEIgKiBCKTtcbiAgICAgICAgaWYgKHNtID4gMCkge1xuICAgICAgICAgIHJ0MSA9IDAuNSAqIChzbSArIHJ0KTtcbiAgICAgICAgICB0ID0gMSAvIHJ0MTtcbiAgICAgICAgICBydDIgPSBBICogdCAqIEMgLSBCICogdCAqIEI7XG4gICAgICAgIH0gZWxzZSBpZiAoc20gPCAwKSB7XG4gICAgICAgICAgcnQyID0gMC41ICogKHNtIC0gcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ0MSA9IDAuNSAqIHJ0O1xuICAgICAgICAgIHJ0MiA9IC0wLjUgKiBydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGYgPiAwKSB7XG4gICAgICAgICAgY3MgPSBkZiArIHJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzID0gZGYgLSBydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoY3MpID4gMiAqIE1hdGguYWJzKEIpKSB7XG4gICAgICAgICAgdCA9IC0yICogQiAvIGNzO1xuICAgICAgICAgIHNuID0gMSAvIE1hdGguc3FydCgxICsgdCAqIHQpO1xuICAgICAgICAgIGNzID0gdCAqIHNuO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKEIpID09PSAwKSB7XG4gICAgICAgICAgY3MgPSAxO1xuICAgICAgICAgIHNuID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gLTAuNSAqIGNzIC8gQjtcbiAgICAgICAgICBjcyA9IDEgLyBNYXRoLnNxcnQoMSArIHQgKiB0KTtcbiAgICAgICAgICBzbiA9IHQgKiBjcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGYgPiAwKSB7XG4gICAgICAgICAgdCA9IGNzO1xuICAgICAgICAgIGNzID0gLXNuO1xuICAgICAgICAgIHNuID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBydDEsIHJ0MiwgY3MsIHNuIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgY29uc3Qgc3R5bGVzaGVldHMgPSB7fTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMCA9IG5ldyBNYXRyaXgzKCk7XG4gICAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMSA9IG5ldyBNYXRyaXgzKCk7XG4gICAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMiA9IG5ldyBNYXRyaXgzKCk7XG4gICAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMyA9IG5ldyBNYXRyaXgzKCk7XG4gICAgICBjb25zdCB0ZW1wVjIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYzID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpO1xuICAgICAgY29uc3QgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgICBwYXJzZU5vZGUoeG1sLmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgICBmaWxsOiBcIiMwMDBcIixcbiAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogXCJtaXRlclwiLFxuICAgICAgICBzdHJva2VMaW5lQ2FwOiBcImJ1dHRcIixcbiAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogNFxuICAgICAgfSk7XG4gICAgICBjb25zdCBkYXRhID0geyBwYXRocywgeG1sOiB4bWwuZG9jdW1lbnRFbGVtZW50IH07XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVNoYXBlcyhzaGFwZVBhdGgpIHtcbiAgICAgIGNvbnN0IEJJR05VTUJFUiA9IDk5OTk5OTk5OTtcbiAgICAgIGNvbnN0IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZSA9IHtcbiAgICAgICAgT1JJR0lOOiAwLFxuICAgICAgICBERVNUSU5BVElPTjogMSxcbiAgICAgICAgQkVUV0VFTjogMixcbiAgICAgICAgTEVGVDogMyxcbiAgICAgICAgUklHSFQ6IDQsXG4gICAgICAgIEJFSElORDogNSxcbiAgICAgICAgQkVZT05EOiA2XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xhc3NpZnlSZXN1bHQgPSB7XG4gICAgICAgIGxvYzogSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTixcbiAgICAgICAgdDogMFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGZpbmRFZGdlSW50ZXJzZWN0aW9uKGEwLCBhMSwgYjAsIGIxKSB7XG4gICAgICAgIGNvbnN0IHgxID0gYTAueDtcbiAgICAgICAgY29uc3QgeDIgPSBhMS54O1xuICAgICAgICBjb25zdCB4MyA9IGIwLng7XG4gICAgICAgIGNvbnN0IHg0ID0gYjEueDtcbiAgICAgICAgY29uc3QgeTEgPSBhMC55O1xuICAgICAgICBjb25zdCB5MiA9IGExLnk7XG4gICAgICAgIGNvbnN0IHkzID0gYjAueTtcbiAgICAgICAgY29uc3QgeTQgPSBiMS55O1xuICAgICAgICBjb25zdCBub20xID0gKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpO1xuICAgICAgICBjb25zdCBub20yID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICAgICAgICBjb25zdCBkZW5vbSA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcbiAgICAgICAgY29uc3QgdDEgPSBub20xIC8gZGVub207XG4gICAgICAgIGNvbnN0IHQyID0gbm9tMiAvIGRlbm9tO1xuICAgICAgICBpZiAoZGVub20gPT09IDAgJiYgbm9tMSAhPT0gMCB8fCB0MSA8PSAwIHx8IHQxID49IDEgfHwgdDIgPCAwIHx8IHQyID4gMSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKG5vbTEgPT09IDAgJiYgZGVub20gPT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NpZnlQb2ludChpID09PSAwID8gYjAgOiBiMSwgYTAsIGExKTtcbiAgICAgICAgICAgIGlmIChjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTikge1xuICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGkgPT09IDAgPyBiMCA6IGIxO1xuICAgICAgICAgICAgICByZXR1cm4geyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB0OiBjbGFzc2lmeVJlc3VsdC50IH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzaWZ5UmVzdWx0LmxvYyA9PSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVUV0VFTikge1xuICAgICAgICAgICAgICBjb25zdCB4ID0gKyh4MSArIGNsYXNzaWZ5UmVzdWx0LnQgKiAoeDIgLSB4MSkpLnRvUHJlY2lzaW9uKDEwKTtcbiAgICAgICAgICAgICAgY29uc3QgeSA9ICsoeTEgKyBjbGFzc2lmeVJlc3VsdC50ICogKHkyIC0geTEpKS50b1ByZWNpc2lvbigxMCk7XG4gICAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHQ6IGNsYXNzaWZ5UmVzdWx0LnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzaWZ5UG9pbnQoaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NpZnlSZXN1bHQubG9jID09IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5PUklHSU4pIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBpID09PSAwID8gYjAgOiBiMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSwgdDogY2xhc3NpZnlSZXN1bHQudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB4ID0gKyh4MSArIHQxICogKHgyIC0geDEpKS50b1ByZWNpc2lvbigxMCk7XG4gICAgICAgICAgY29uc3QgeSA9ICsoeTEgKyB0MSAqICh5MiAtIHkxKSkudG9QcmVjaXNpb24oMTApO1xuICAgICAgICAgIHJldHVybiB7IHgsIHksIHQ6IHQxIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsYXNzaWZ5UG9pbnQocCwgZWRnZVN0YXJ0LCBlZGdlRW5kKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gZWRnZUVuZC54IC0gZWRnZVN0YXJ0Lng7XG4gICAgICAgIGNvbnN0IGF5ID0gZWRnZUVuZC55IC0gZWRnZVN0YXJ0Lnk7XG4gICAgICAgIGNvbnN0IGJ4ID0gcC54IC0gZWRnZVN0YXJ0Lng7XG4gICAgICAgIGNvbnN0IGJ5ID0gcC55IC0gZWRnZVN0YXJ0Lnk7XG4gICAgICAgIGNvbnN0IHNhID0gYXggKiBieSAtIGJ4ICogYXk7XG4gICAgICAgIGlmIChwLnggPT09IGVkZ2VTdGFydC54ICYmIHAueSA9PT0gZWRnZVN0YXJ0LnkpIHtcbiAgICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOO1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LnQgPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC54ID09PSBlZGdlRW5kLnggJiYgcC55ID09PSBlZGdlRW5kLnkpIHtcbiAgICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuREVTVElOQVRJT047XG4gICAgICAgICAgY2xhc3NpZnlSZXN1bHQudCA9IDE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYSA8IC1OdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5MRUZUO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2EgPiBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5SSUdIVDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4ICogYnggPCAwIHx8IGF5ICogYnkgPCAwKSB7XG4gICAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFSElORDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgPCBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSB7XG4gICAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFWU9ORDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmIChheCAhPT0gMCkge1xuICAgICAgICAgIHQgPSBieCAvIGF4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSBieSAvIGF5O1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5CRVRXRUVOO1xuICAgICAgICBjbGFzc2lmeVJlc3VsdC50ID0gdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnNSYXcgPSBbXTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgcGF0aDEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcGF0aDFFZGdlU3RhcnQgPSBwYXRoMVtpbmRleCAtIDFdO1xuICAgICAgICAgIGNvbnN0IHBhdGgxRWRnZUVuZCA9IHBhdGgxW2luZGV4XTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleDIgPSAxOyBpbmRleDIgPCBwYXRoMi5sZW5ndGg7IGluZGV4MisrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoMkVkZ2VTdGFydCA9IHBhdGgyW2luZGV4MiAtIDFdO1xuICAgICAgICAgICAgY29uc3QgcGF0aDJFZGdlRW5kID0gcGF0aDJbaW5kZXgyXTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGZpbmRFZGdlSW50ZXJzZWN0aW9uKHBhdGgxRWRnZVN0YXJ0LCBwYXRoMUVkZ2VFbmQsIHBhdGgyRWRnZVN0YXJ0LCBwYXRoMkVkZ2VFbmQpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCAmJiBpbnRlcnNlY3Rpb25zUmF3LmZpbmQoXG4gICAgICAgICAgICAgIChpKSA9PiBpLnQgPD0gaW50ZXJzZWN0aW9uLnQgKyBOdW1iZXIuRVBTSUxPTiAmJiBpLnQgPj0gaW50ZXJzZWN0aW9uLnQgLSBOdW1iZXIuRVBTSUxPTlxuICAgICAgICAgICAgKSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdGlvbnNSYXcucHVzaChpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2gobmV3IFZlY3RvcjIoaW50ZXJzZWN0aW9uLngsIGludGVyc2VjdGlvbi55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0U2NhbmxpbmVJbnRlcnNlY3Rpb25zKHNjYW5saW5lLCBib3VuZGluZ0JveCwgcGF0aHMpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgYm91bmRpbmdCb3guZ2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICAgIGNvbnN0IGFsbEludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgIGlmIChwYXRoLmJvdW5kaW5nQm94LmNvbnRhaW5zUG9pbnQoY2VudGVyKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IGdldEludGVyc2VjdGlvbnMoc2NhbmxpbmUsIHBhdGgucG9pbnRzKTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgICBhbGxJbnRlcnNlY3Rpb25zLnB1c2goeyBpZGVudGlmaWVyOiBwYXRoLmlkZW50aWZpZXIsIGlzQ1c6IHBhdGguaXNDVywgcG9pbnQ6IHAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxJbnRlcnNlY3Rpb25zLnNvcnQoKGkxLCBpMikgPT4ge1xuICAgICAgICAgIHJldHVybiBpMS5wb2ludC54IC0gaTIucG9pbnQueDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhbGxJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXNIb2xlVG8oc2ltcGxlUGF0aCwgYWxsUGF0aHMsIHNjYW5saW5lTWluWDIsIHNjYW5saW5lTWF4WDIsIF9maWxsUnVsZSkge1xuICAgICAgICBpZiAoX2ZpbGxSdWxlID09PSBudWxsIHx8IF9maWxsUnVsZSA9PT0gdm9pZCAwIHx8IF9maWxsUnVsZSA9PT0gXCJcIikge1xuICAgICAgICAgIF9maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbnRlckJvdW5kaW5nQm94ID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgc2ltcGxlUGF0aC5ib3VuZGluZ0JveC5nZXRDZW50ZXIoY2VudGVyQm91bmRpbmdCb3gpO1xuICAgICAgICBjb25zdCBzY2FubGluZSA9IFtcbiAgICAgICAgICBuZXcgVmVjdG9yMihzY2FubGluZU1pblgyLCBjZW50ZXJCb3VuZGluZ0JveC55KSxcbiAgICAgICAgICBuZXcgVmVjdG9yMihzY2FubGluZU1heFgyLCBjZW50ZXJCb3VuZGluZ0JveC55KVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzY2FubGluZUludGVyc2VjdGlvbnMgPSBnZXRTY2FubGluZUludGVyc2VjdGlvbnMoc2NhbmxpbmUsIHNpbXBsZVBhdGguYm91bmRpbmdCb3gsIGFsbFBhdGhzKTtcbiAgICAgICAgc2NhbmxpbmVJbnRlcnNlY3Rpb25zLnNvcnQoKGkxLCBpMikgPT4ge1xuICAgICAgICAgIHJldHVybiBpMS5wb2ludC54IC0gaTIucG9pbnQueDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhc2VJbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IG90aGVySW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgICBzY2FubGluZUludGVyc2VjdGlvbnMuZm9yRWFjaCgoaTIpID0+IHtcbiAgICAgICAgICBpZiAoaTIuaWRlbnRpZmllciA9PT0gc2ltcGxlUGF0aC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBiYXNlSW50ZXJzZWN0aW9ucy5wdXNoKGkyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXJJbnRlcnNlY3Rpb25zLnB1c2goaTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpcnN0WE9mUGF0aCA9IGJhc2VJbnRlcnNlY3Rpb25zWzBdLnBvaW50Lng7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvdGhlckludGVyc2VjdGlvbnMubGVuZ3RoICYmIG90aGVySW50ZXJzZWN0aW9uc1tpXS5wb2ludC54IDwgZmlyc3RYT2ZQYXRoKSB7XG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IG90aGVySW50ZXJzZWN0aW9uc1tpXS5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaChvdGhlckludGVyc2VjdGlvbnNbaV0uaWRlbnRpZmllcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHNpbXBsZVBhdGguaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChfZmlsbFJ1bGUgPT09IFwiZXZlbm9kZFwiKSB7XG4gICAgICAgICAgY29uc3QgaXNIb2xlID0gc3RhY2subGVuZ3RoICUgMiA9PT0gMCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0hvbGVGb3IgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICByZXR1cm4geyBpZGVudGlmaWVyOiBzaW1wbGVQYXRoLmlkZW50aWZpZXIsIGlzSG9sZSwgZm9yOiBpc0hvbGVGb3IgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfZmlsbFJ1bGUgPT09IFwibm9uemVyb1wiKSB7XG4gICAgICAgICAgbGV0IGlzSG9sZSA9IHRydWU7XG4gICAgICAgICAgbGV0IGlzSG9sZUZvciA9IG51bGw7XG4gICAgICAgICAgbGV0IGxhc3RDV1ZhbHVlID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgc3RhY2subGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gc3RhY2tbaTJdO1xuICAgICAgICAgICAgaWYgKGlzSG9sZSkge1xuICAgICAgICAgICAgICBsYXN0Q1dWYWx1ZSA9IGFsbFBhdGhzW2lkZW50aWZpZXJdLmlzQ1c7XG4gICAgICAgICAgICAgIGlzSG9sZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpc0hvbGVGb3IgPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q1dWYWx1ZSAhPT0gYWxsUGF0aHNbaWRlbnRpZmllcl0uaXNDVykge1xuICAgICAgICAgICAgICBsYXN0Q1dWYWx1ZSA9IGFsbFBhdGhzW2lkZW50aWZpZXJdLmlzQ1c7XG4gICAgICAgICAgICAgIGlzSG9sZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGlkZW50aWZpZXI6IHNpbXBsZVBhdGguaWRlbnRpZmllciwgaXNIb2xlLCBmb3I6IGlzSG9sZUZvciB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignZmlsbC1ydWxlOiBcIicgKyBfZmlsbFJ1bGUgKyAnXCIgaXMgY3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHNjYW5saW5lTWluWCA9IEJJR05VTUJFUjtcbiAgICAgIGxldCBzY2FubGluZU1heFggPSAtQklHTlVNQkVSO1xuICAgICAgbGV0IHNpbXBsZVBhdGhzID0gc2hhcGVQYXRoLnN1YlBhdGhzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBwLmdldFBvaW50cygpO1xuICAgICAgICBsZXQgbWF4WSA9IC1CSUdOVU1CRVI7XG4gICAgICAgIGxldCBtaW5ZID0gQklHTlVNQkVSO1xuICAgICAgICBsZXQgbWF4WCA9IC1CSUdOVU1CRVI7XG4gICAgICAgIGxldCBtaW5YID0gQklHTlVNQkVSO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2ldO1xuICAgICAgICAgIGlmIChwMi55ID4gbWF4WSkge1xuICAgICAgICAgICAgbWF4WSA9IHAyLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwMi55IDwgbWluWSkge1xuICAgICAgICAgICAgbWluWSA9IHAyLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwMi54ID4gbWF4WCkge1xuICAgICAgICAgICAgbWF4WCA9IHAyLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwMi54IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IHAyLng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubGluZU1heFggPD0gbWF4WCkge1xuICAgICAgICAgIHNjYW5saW5lTWF4WCA9IG1heFggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubGluZU1pblggPj0gbWluWCkge1xuICAgICAgICAgIHNjYW5saW5lTWluWCA9IG1pblggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VydmVzOiBwLmN1cnZlcyxcbiAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgaXNDVzogU2hhcGVVdGlscy5pc0Nsb2NrV2lzZShwb2ludHMpLFxuICAgICAgICAgIGlkZW50aWZpZXI6IC0xLFxuICAgICAgICAgIGJvdW5kaW5nQm94OiBuZXcgQm94MihuZXcgVmVjdG9yMihtaW5YLCBtaW5ZKSwgbmV3IFZlY3RvcjIobWF4WCwgbWF4WSkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHNpbXBsZVBhdGhzID0gc2ltcGxlUGF0aHMuZmlsdGVyKChzcCkgPT4gc3AucG9pbnRzLmxlbmd0aCA+IDEpO1xuICAgICAgZm9yIChsZXQgaWRlbnRpZmllciA9IDA7IGlkZW50aWZpZXIgPCBzaW1wbGVQYXRocy5sZW5ndGg7IGlkZW50aWZpZXIrKykge1xuICAgICAgICBzaW1wbGVQYXRoc1tpZGVudGlmaWVyXS5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQUhvbGUgPSBzaW1wbGVQYXRocy5tYXAoXG4gICAgICAgIChwKSA9PiBpc0hvbGVUbyhcbiAgICAgICAgICBwLFxuICAgICAgICAgIHNpbXBsZVBhdGhzLFxuICAgICAgICAgIHNjYW5saW5lTWluWCxcbiAgICAgICAgICBzY2FubGluZU1heFgsXG4gICAgICAgICAgc2hhcGVQYXRoLnVzZXJEYXRhID8gc2hhcGVQYXRoLnVzZXJEYXRhLnN0eWxlLmZpbGxSdWxlIDogdm9pZCAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBjb25zdCBzaGFwZXNUb1JldHVybiA9IFtdO1xuICAgICAgc2ltcGxlUGF0aHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBjb25zdCBhbUlBSG9sZSA9IGlzQUhvbGVbcC5pZGVudGlmaWVyXTtcbiAgICAgICAgaWYgKCFhbUlBSG9sZS5pc0hvbGUpIHtcbiAgICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xuICAgICAgICAgIHNoYXBlLmN1cnZlcyA9IHAuY3VydmVzO1xuICAgICAgICAgIGNvbnN0IGhvbGVzID0gaXNBSG9sZS5maWx0ZXIoKGgpID0+IGguaXNIb2xlICYmIGguZm9yID09PSBwLmlkZW50aWZpZXIpO1xuICAgICAgICAgIGhvbGVzLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhvbGUgPSBzaW1wbGVQYXRoc1toLmlkZW50aWZpZXJdO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgICAgICBwYXRoLmN1cnZlcyA9IGhvbGUuY3VydmVzO1xuICAgICAgICAgICAgc2hhcGUuaG9sZXMucHVzaChwYXRoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzaGFwZXNUb1JldHVybi5wdXNoKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hhcGVzVG9SZXR1cm47XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTdHJva2VTdHlsZSh3aWR0aCwgY29sb3IsIGxpbmVKb2luLCBsaW5lQ2FwLCBtaXRlckxpbWl0KSB7XG4gICAgICB3aWR0aCA9IHdpZHRoICE9PSB2b2lkIDAgPyB3aWR0aCA6IDE7XG4gICAgICBjb2xvciA9IGNvbG9yICE9PSB2b2lkIDAgPyBjb2xvciA6IFwiIzAwMFwiO1xuICAgICAgbGluZUpvaW4gPSBsaW5lSm9pbiAhPT0gdm9pZCAwID8gbGluZUpvaW4gOiBcIm1pdGVyXCI7XG4gICAgICBsaW5lQ2FwID0gbGluZUNhcCAhPT0gdm9pZCAwID8gbGluZUNhcCA6IFwiYnV0dFwiO1xuICAgICAgbWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQgIT09IHZvaWQgMCA/IG1pdGVyTGltaXQgOiA0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3Ryb2tlQ29sb3I6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVKb2luOiBsaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogbGluZUNhcCxcbiAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogbWl0ZXJMaW1pdFxuICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHBvaW50c1RvU3Ryb2tlKHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UpIHtcbiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgICBjb25zdCBub3JtYWxzID0gW107XG4gICAgICBjb25zdCB1dnMgPSBbXTtcbiAgICAgIGlmIChTVkdMb2FkZXIyLnBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMocG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSwgdmVydGljZXMsIG5vcm1hbHMsIHV2cykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9XG4gICAgc3RhdGljIHBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMocG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSwgdmVydGljZXMsIG5vcm1hbHMsIHV2cywgdmVydGV4T2Zmc2V0KSB7XG4gICAgICBjb25zdCB0ZW1wVjJfMSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfMiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfMyA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfNCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfNSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfNiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCB0ZW1wVjJfNyA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBsYXN0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IGxhc3RQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgcG9pbnQwTCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBwb2ludDBSID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRQb2ludEwgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgY3VycmVudFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBuZXh0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IG5leHRQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgaW5uZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBvdXRlclBvaW50ID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGFyY0RpdmlzaW9ucyA9IGFyY0RpdmlzaW9ucyAhPT0gdm9pZCAwID8gYXJjRGl2aXNpb25zIDogMTI7XG4gICAgICBtaW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlICE9PSB2b2lkIDAgPyBtaW5EaXN0YW5jZSA6IDFlLTM7XG4gICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhPZmZzZXQgIT09IHZvaWQgMCA/IHZlcnRleE9mZnNldCA6IDA7XG4gICAgICBwb2ludHMgPSByZW1vdmVEdXBsaWNhdGVkUG9pbnRzKHBvaW50cyk7XG4gICAgICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgaWYgKG51bVBvaW50cyA8IDIpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgY29uc3QgaXNDbG9zZWQgPSBwb2ludHNbMF0uZXF1YWxzKHBvaW50c1tudW1Qb2ludHMgLSAxXSk7XG4gICAgICBsZXQgY3VycmVudFBvaW50O1xuICAgICAgbGV0IHByZXZpb3VzUG9pbnQgPSBwb2ludHNbMF07XG4gICAgICBsZXQgbmV4dFBvaW50O1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGgyID0gc3R5bGUuc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgY29uc3QgZGVsdGFVID0gMSAvIChudW1Qb2ludHMgLSAxKTtcbiAgICAgIGxldCB1MCA9IDAsIHUxO1xuICAgICAgbGV0IGlubmVyU2lkZU1vZGlmaWVkO1xuICAgICAgbGV0IGpvaW5Jc09uTGVmdFNpZGU7XG4gICAgICBsZXQgaXNNaXRlcjtcbiAgICAgIGxldCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGZhbHNlO1xuICAgICAgbGV0IG51bVZlcnRpY2VzID0gMDtcbiAgICAgIGxldCBjdXJyZW50Q29vcmRpbmF0ZSA9IHZlcnRleE9mZnNldCAqIDM7XG4gICAgICBsZXQgY3VycmVudENvb3JkaW5hdGVVViA9IHZlcnRleE9mZnNldCAqIDI7XG4gICAgICBnZXROb3JtYWwocG9pbnRzWzBdLCBwb2ludHNbMV0sIHRlbXBWMl8xKS5tdWx0aXBseVNjYWxhcihzdHJva2VXaWR0aDIpO1xuICAgICAgbGFzdFBvaW50TC5jb3B5KHBvaW50c1swXSkuc3ViKHRlbXBWMl8xKTtcbiAgICAgIGxhc3RQb2ludFIuY29weShwb2ludHNbMF0pLmFkZCh0ZW1wVjJfMSk7XG4gICAgICBwb2ludDBMLmNvcHkobGFzdFBvaW50TCk7XG4gICAgICBwb2ludDBSLmNvcHkobGFzdFBvaW50Uik7XG4gICAgICBmb3IgKGxldCBpUG9pbnQgPSAxOyBpUG9pbnQgPCBudW1Qb2ludHM7IGlQb2ludCsrKSB7XG4gICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1tpUG9pbnRdO1xuICAgICAgICBpZiAoaVBvaW50ID09PSBudW1Qb2ludHMgLSAxKSB7XG4gICAgICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbMV07XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBuZXh0UG9pbnQgPSB2b2lkIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2lQb2ludCArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vcm1hbDEgPSB0ZW1wVjJfMTtcbiAgICAgICAgZ2V0Tm9ybWFsKHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbm9ybWFsMSk7XG4gICAgICAgIHRlbXBWMl8zLmNvcHkobm9ybWFsMSkubXVsdGlwbHlTY2FsYXIoc3Ryb2tlV2lkdGgyKTtcbiAgICAgICAgY3VycmVudFBvaW50TC5jb3B5KGN1cnJlbnRQb2ludCkuc3ViKHRlbXBWMl8zKTtcbiAgICAgICAgY3VycmVudFBvaW50Ui5jb3B5KGN1cnJlbnRQb2ludCkuYWRkKHRlbXBWMl8zKTtcbiAgICAgICAgdTEgPSB1MCArIGRlbHRhVTtcbiAgICAgICAgaW5uZXJTaWRlTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5leHRQb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZ2V0Tm9ybWFsKGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCB0ZW1wVjJfMik7XG4gICAgICAgICAgdGVtcFYyXzMuY29weSh0ZW1wVjJfMikubXVsdGlwbHlTY2FsYXIoc3Ryb2tlV2lkdGgyKTtcbiAgICAgICAgICBuZXh0UG9pbnRMLmNvcHkoY3VycmVudFBvaW50KS5zdWIodGVtcFYyXzMpO1xuICAgICAgICAgIG5leHRQb2ludFIuY29weShjdXJyZW50UG9pbnQpLmFkZCh0ZW1wVjJfMyk7XG4gICAgICAgICAgam9pbklzT25MZWZ0U2lkZSA9IHRydWU7XG4gICAgICAgICAgdGVtcFYyXzMuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIHByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgIGlmIChub3JtYWwxLmRvdCh0ZW1wVjJfMykgPCAwKSB7XG4gICAgICAgICAgICBqb2luSXNPbkxlZnRTaWRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpUG9pbnQgPT09IDEpXG4gICAgICAgICAgICBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGpvaW5Jc09uTGVmdFNpZGU7XG4gICAgICAgICAgdGVtcFYyXzMuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgdGVtcFYyXzMubm9ybWFsaXplKCk7XG4gICAgICAgICAgY29uc3QgZG90ID0gTWF0aC5hYnMobm9ybWFsMS5kb3QodGVtcFYyXzMpKTtcbiAgICAgICAgICBpZiAoZG90ID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAgIGNvbnN0IG1pdGVyU2lkZSA9IHN0cm9rZVdpZHRoMiAvIGRvdDtcbiAgICAgICAgICAgIHRlbXBWMl8zLm11bHRpcGx5U2NhbGFyKC1taXRlclNpZGUpO1xuICAgICAgICAgICAgdGVtcFYyXzQuc3ViVmVjdG9ycyhjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgICAgdGVtcFYyXzUuY29weSh0ZW1wVjJfNCkuc2V0TGVuZ3RoKG1pdGVyU2lkZSkuYWRkKHRlbXBWMl8zKTtcbiAgICAgICAgICAgIGlubmVyUG9pbnQuY29weSh0ZW1wVjJfNSkubmVnYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBtaXRlckxlbmd0aDIgPSB0ZW1wVjJfNS5sZW5ndGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRMZW5ndGhQcmV2ID0gdGVtcFYyXzQubGVuZ3RoKCk7XG4gICAgICAgICAgICB0ZW1wVjJfNC5kaXZpZGVTY2FsYXIoc2VnbWVudExlbmd0aFByZXYpO1xuICAgICAgICAgICAgdGVtcFYyXzYuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50TGVuZ3RoTmV4dCA9IHRlbXBWMl82Lmxlbmd0aCgpO1xuICAgICAgICAgICAgdGVtcFYyXzYuZGl2aWRlU2NhbGFyKHNlZ21lbnRMZW5ndGhOZXh0KTtcbiAgICAgICAgICAgIGlmICh0ZW1wVjJfNC5kb3QoaW5uZXJQb2ludCkgPCBzZWdtZW50TGVuZ3RoUHJldiAmJiB0ZW1wVjJfNi5kb3QoaW5uZXJQb2ludCkgPCBzZWdtZW50TGVuZ3RoTmV4dCkge1xuICAgICAgICAgICAgICBpbm5lclNpZGVNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRlclBvaW50LmNvcHkodGVtcFYyXzUpLmFkZChjdXJyZW50UG9pbnQpO1xuICAgICAgICAgICAgaW5uZXJQb2ludC5hZGQoY3VycmVudFBvaW50KTtcbiAgICAgICAgICAgIGlzTWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbm5lclNpZGVNb2RpZmllZCkge1xuICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgIG5leHRQb2ludFIuY29weShpbm5lclBvaW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRSLmNvcHkoaW5uZXJQb2ludCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50TC5jb3B5KGlubmVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludEwuY29weShpbm5lclBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUuc3Ryb2tlTGluZUpvaW4pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJldmVsXCI6XG4gICAgICAgICAgICAgICAgbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1MSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICAgICAgICAgIGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbihqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgIG1ha2VDaXJjdWxhclNlY3RvcihjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIG5leHRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWFrZUNpcmN1bGFyU2VjdG9yKGN1cnJlbnRQb2ludCwgbmV4dFBvaW50UiwgY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1pdGVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtaXRlci1jbGlwXCI6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc3QgbWl0ZXJGcmFjdGlvbiA9IHN0cm9rZVdpZHRoMiAqIHN0eWxlLnN0cm9rZU1pdGVyTGltaXQgLyBtaXRlckxlbmd0aDI7XG4gICAgICAgICAgICAgICAgaWYgKG1pdGVyRnJhY3Rpb24gPCAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlTGluZUpvaW4gIT09IFwibWl0ZXItY2xpcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbihqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbihqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFYyXzYuc3ViVmVjdG9ycyhvdXRlclBvaW50LCBjdXJyZW50UG9pbnRMKS5tdWx0aXBseVNjYWxhcihtaXRlckZyYWN0aW9uKS5hZGQoY3VycmVudFBvaW50TCk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFYyXzcuc3ViVmVjdG9ycyhvdXRlclBvaW50LCBuZXh0UG9pbnRMKS5tdWx0aXBseVNjYWxhcihtaXRlckZyYWN0aW9uKS5hZGQobmV4dFBvaW50TCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzYsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzYsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzcsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzcsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBWMl82LnN1YlZlY3RvcnMob3V0ZXJQb2ludCwgY3VycmVudFBvaW50UikubXVsdGlwbHlTY2FsYXIobWl0ZXJGcmFjdGlvbikuYWRkKGN1cnJlbnRQb2ludFIpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBWMl83LnN1YlZlY3RvcnMob3V0ZXJQb2ludCwgbmV4dFBvaW50UikubXVsdGlwbHlTY2FsYXIobWl0ZXJGcmFjdGlvbikuYWRkKG5leHRQb2ludFIpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl83LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl83LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5uZXJTaWRlTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG91dGVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG91dGVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG91dGVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRQb2ludEwuY29weShvdXRlclBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnRSLmNvcHkob3V0ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG91dGVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc01pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Nsb3NlZCAmJiBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEpIHtcbiAgICAgICAgICBhZGRDYXBHZW9tZXRyeShwb2ludHNbMF0sIHBvaW50MEwsIHBvaW50MFIsIGpvaW5Jc09uTGVmdFNpZGUsIHRydWUsIHUwKTtcbiAgICAgICAgfVxuICAgICAgICB1MCA9IHUxO1xuICAgICAgICBwcmV2aW91c1BvaW50ID0gY3VycmVudFBvaW50O1xuICAgICAgICBsYXN0UG9pbnRMLmNvcHkobmV4dFBvaW50TCk7XG4gICAgICAgIGxhc3RQb2ludFIuY29weShuZXh0UG9pbnRSKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNDbG9zZWQpIHtcbiAgICAgICAgYWRkQ2FwR2VvbWV0cnkoY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBjdXJyZW50UG9pbnRSLCBqb2luSXNPbkxlZnRTaWRlLCBmYWxzZSwgdTEpO1xuICAgICAgfSBlbHNlIGlmIChpbm5lclNpZGVNb2RpZmllZCAmJiB2ZXJ0aWNlcykge1xuICAgICAgICBsZXQgbGFzdE91dGVyID0gb3V0ZXJQb2ludDtcbiAgICAgICAgbGV0IGxhc3RJbm5lciA9IGlubmVyUG9pbnQ7XG4gICAgICAgIGlmIChpbml0aWFsSm9pbklzT25MZWZ0U2lkZSAhPT0gam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgIGxhc3RPdXRlciA9IGlubmVyUG9pbnQ7XG4gICAgICAgICAgbGFzdElubmVyID0gb3V0ZXJQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgIGlmIChpc01pdGVyIHx8IGluaXRpYWxKb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICBsYXN0SW5uZXIudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgICAgbGFzdElubmVyLnRvQXJyYXkodmVydGljZXMsIDMgKiAzKTtcbiAgICAgICAgICAgIGlmIChpc01pdGVyKSB7XG4gICAgICAgICAgICAgIGxhc3RPdXRlci50b0FycmF5KHZlcnRpY2VzLCAxICogMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc01pdGVyIHx8ICFpbml0aWFsSm9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgbGFzdElubmVyLnRvQXJyYXkodmVydGljZXMsIDEgKiAzKTtcbiAgICAgICAgICAgIGxhc3RJbm5lci50b0FycmF5KHZlcnRpY2VzLCAzICogMyk7XG4gICAgICAgICAgICBpZiAoaXNNaXRlcikge1xuICAgICAgICAgICAgICBsYXN0T3V0ZXIudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bVZlcnRpY2VzO1xuICAgICAgZnVuY3Rpb24gZ2V0Tm9ybWFsKHAxLCBwMiwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5zdWJWZWN0b3JzKHAyLCBwMSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KC1yZXN1bHQueSwgcmVzdWx0LngpLm5vcm1hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYWRkVmVydGV4KHBvc2l0aW9uLCB1LCB2KSB7XG4gICAgICAgIGlmICh2ZXJ0aWNlcykge1xuICAgICAgICAgIHZlcnRpY2VzW2N1cnJlbnRDb29yZGluYXRlXSA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgdmVydGljZXNbY3VycmVudENvb3JkaW5hdGUgKyAxXSA9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgdmVydGljZXNbY3VycmVudENvb3JkaW5hdGUgKyAyXSA9IDA7XG4gICAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICAgIG5vcm1hbHNbY3VycmVudENvb3JkaW5hdGVdID0gMDtcbiAgICAgICAgICAgIG5vcm1hbHNbY3VycmVudENvb3JkaW5hdGUgKyAxXSA9IDA7XG4gICAgICAgICAgICBub3JtYWxzW2N1cnJlbnRDb29yZGluYXRlICsgMl0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZSArPSAzO1xuICAgICAgICAgIGlmICh1dnMpIHtcbiAgICAgICAgICAgIHV2c1tjdXJyZW50Q29vcmRpbmF0ZVVWXSA9IHU7XG4gICAgICAgICAgICB1dnNbY3VycmVudENvb3JkaW5hdGVVViArIDFdID0gdjtcbiAgICAgICAgICAgIGN1cnJlbnRDb29yZGluYXRlVVYgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtVmVydGljZXMgKz0gMztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1ha2VDaXJjdWxhclNlY3RvcihjZW50ZXIsIHAxLCBwMiwgdSwgdikge1xuICAgICAgICB0ZW1wVjJfMS5jb3B5KHAxKS5zdWIoY2VudGVyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGVtcFYyXzIuY29weShwMikuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguUEk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHRlbXBWMl8xLmRvdCh0ZW1wVjJfMik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgMSlcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYWJzKE1hdGguYWNvcyhkb3QpKTtcbiAgICAgICAgYW5nbGUgLz0gYXJjRGl2aXNpb25zO1xuICAgICAgICB0ZW1wVjJfMy5jb3B5KHAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYXJjRGl2aXNpb25zIC0gMTsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICB0ZW1wVjJfNC5jb3B5KHRlbXBWMl8zKS5yb3RhdGVBcm91bmQoY2VudGVyLCBhbmdsZSk7XG4gICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl8zLCB1LCB2KTtcbiAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzQsIHUsIHYpO1xuICAgICAgICAgIGFkZFZlcnRleChjZW50ZXIsIHUsIDAuNSk7XG4gICAgICAgICAgdGVtcFYyXzMuY29weSh0ZW1wVjJfNCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVmVydGV4KHRlbXBWMl80LCB1LCB2KTtcbiAgICAgICAgYWRkVmVydGV4KHAyLCB1LCB2KTtcbiAgICAgICAgYWRkVmVydGV4KGNlbnRlciwgdSwgMC41KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1ha2VTZWdtZW50VHJpYW5nbGVzKCkge1xuICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKGpvaW5Jc09uTGVmdFNpZGUyLCBpbm5lclNpZGVNb2RpZmllZDIsIHUpIHtcbiAgICAgICAgaWYgKGlubmVyU2lkZU1vZGlmaWVkMikge1xuICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUsIDAuNSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1LCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1LCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRSLCB1LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUyKSB7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50TCwgdSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1LCAwLjUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1LCAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKGpvaW5Jc09uTGVmdFNpZGUyLCBpbm5lclNpZGVNb2RpZmllZDIpIHtcbiAgICAgICAgaWYgKGlubmVyU2lkZU1vZGlmaWVkMikge1xuICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYWRkQ2FwR2VvbWV0cnkoY2VudGVyLCBwMSwgcDIsIGpvaW5Jc09uTGVmdFNpZGUyLCBzdGFydCwgdSkge1xuICAgICAgICBzd2l0Y2ggKHN0eWxlLnN0cm9rZUxpbmVDYXApIHtcbiAgICAgICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICBtYWtlQ2lyY3VsYXJTZWN0b3IoY2VudGVyLCBwMiwgcDEsIHUsIDAuNSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYWtlQ2lyY3VsYXJTZWN0b3IoY2VudGVyLCBwMSwgcDIsIHUsIDAuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgdGVtcFYyXzEuc3ViVmVjdG9ycyhwMSwgY2VudGVyKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzIuc2V0KHRlbXBWMl8xLnksIC10ZW1wVjJfMS54KTtcbiAgICAgICAgICAgICAgdGVtcFYyXzMuYWRkVmVjdG9ycyh0ZW1wVjJfMSwgdGVtcFYyXzIpLmFkZChjZW50ZXIpO1xuICAgICAgICAgICAgICB0ZW1wVjJfNC5zdWJWZWN0b3JzKHRlbXBWMl8yLCB0ZW1wVjJfMSkuYWRkKGNlbnRlcik7XG4gICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgICAgIHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIDEgKiAzKTtcbiAgICAgICAgICAgICAgICB0ZW1wVjJfNC50b0FycmF5KHZlcnRpY2VzLCAwICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgMyAqIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIDEgKiAzKTtcbiAgICAgICAgICAgICAgICB1dnNbMyAqIDIgKyAxXSA9PT0gMSA/IHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIDMgKiAzKSA6IHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIDMgKiAzKTtcbiAgICAgICAgICAgICAgICB0ZW1wVjJfNC50b0FycmF5KHZlcnRpY2VzLCAwICogMyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlbXBWMl8xLnN1YlZlY3RvcnMocDIsIGNlbnRlcik7XG4gICAgICAgICAgICAgIHRlbXBWMl8yLnNldCh0ZW1wVjJfMS55LCAtdGVtcFYyXzEueCk7XG4gICAgICAgICAgICAgIHRlbXBWMl8zLmFkZFZlY3RvcnModGVtcFYyXzEsIHRlbXBWMl8yKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzQuc3ViVmVjdG9ycyh0ZW1wVjJfMiwgdGVtcFYyXzEpLmFkZChjZW50ZXIpO1xuICAgICAgICAgICAgICBjb25zdCB2bCA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUyKSB7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzMudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSAxICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSAyICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSA0ICogMyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSAyICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzMudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSAxICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSA0ICogMyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVkUG9pbnRzKHBvaW50czIpIHtcbiAgICAgICAgbGV0IGR1cFBvaW50cyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgbiA9IHBvaW50czIubGVuZ3RoIC0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGlmIChwb2ludHMyW2ldLmRpc3RhbmNlVG8ocG9pbnRzMltpICsgMV0pIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGR1cFBvaW50cyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkdXBQb2ludHMpXG4gICAgICAgICAgcmV0dXJuIHBvaW50czI7XG4gICAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFtdO1xuICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludHMyWzBdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBwb2ludHMyLmxlbmd0aCAtIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9pbnRzMltpXS5kaXN0YW5jZVRvKHBvaW50czJbaSArIDFdKSA+PSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnRzMltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50czJbcG9pbnRzMi5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTVkdMb2FkZXIyO1xufSkoKTtcbmV4cG9ydCB7XG4gIFNWR0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR0xvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/postprocessing/Pass.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/postprocessing/Pass.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FullScreenQuad: () => (/* binding */ FullScreenQuad),\n/* harmony export */   Pass: () => (/* binding */ Pass)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nclass Pass {\n  constructor() {\n    // if set to true, the pass is processed by the composer\n    __publicField(this, \"enabled\", true);\n    // if set to true, the pass indicates to swap read and write buffer after rendering\n    __publicField(this, \"needsSwap\", true);\n    // if set to true, the pass clears its buffer before rendering\n    __publicField(this, \"clear\", false);\n    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n    __publicField(this, \"renderToScreen\", false);\n  }\n  setSize(width, height) {\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n  }\n  dispose() {\n  }\n}\nclass FullScreenQuad {\n  constructor(material) {\n    __publicField(this, \"camera\", new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-1, 1, 1, -1, 0, 1));\n    __publicField(this, \"geometry\", new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(2, 2));\n    __publicField(this, \"mesh\");\n    this.mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, material);\n  }\n  get material() {\n    return this.mesh.material;\n  }\n  set material(value) {\n    this.mesh.material = value;\n  }\n  dispose() {\n    this.mesh.geometry.dispose();\n  }\n  render(renderer) {\n    renderer.render(this.mesh, this.camera);\n  }\n}\n\n//# sourceMappingURL=Pass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3Bvc3Rwcm9jZXNzaW5nL1Bhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ2dFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxREFBa0I7QUFDeEQsd0NBQXdDLGdEQUFhO0FBQ3JEO0FBQ0Esb0JBQW9CLHVDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxwb3N0cHJvY2Vzc2luZ1xcUGFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5pbXBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEsIFBsYW5lR2VvbWV0cnksIE1lc2ggfSBmcm9tIFwidGhyZWVcIjtcbmNsYXNzIFBhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBpZiBzZXQgdG8gdHJ1ZSwgdGhlIHBhc3MgaXMgcHJvY2Vzc2VkIGJ5IHRoZSBjb21wb3NlclxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIC8vIGlmIHNldCB0byB0cnVlLCB0aGUgcGFzcyBpbmRpY2F0ZXMgdG8gc3dhcCByZWFkIGFuZCB3cml0ZSBidWZmZXIgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5lZWRzU3dhcFwiLCB0cnVlKTtcbiAgICAvLyBpZiBzZXQgdG8gdHJ1ZSwgdGhlIHBhc3MgY2xlYXJzIGl0cyBidWZmZXIgYmVmb3JlIHJlbmRlcmluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbGVhclwiLCBmYWxzZSk7XG4gICAgLy8gaWYgc2V0IHRvIHRydWUsIHRoZSByZXN1bHQgb2YgdGhlIHBhc3MgaXMgcmVuZGVyZWQgdG8gc2NyZWVuLiBUaGlzIGlzIHNldCBhdXRvbWF0aWNhbGx5IGJ5IEVmZmVjdENvbXBvc2VyLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW5kZXJUb1NjcmVlblwiLCBmYWxzZSk7XG4gIH1cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGFUaW1lLCBtYXNrQWN0aXZlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlBhc3M6IC5yZW5kZXIoKSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgcGFzcy5cIik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgfVxufVxuY2xhc3MgRnVsbFNjcmVlblF1YWQge1xuICBjb25zdHJ1Y3RvcihtYXRlcmlhbCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjYW1lcmFcIiwgbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAsIDEpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VvbWV0cnlcIiwgbmV3IFBsYW5lR2VvbWV0cnkoMiwgMikpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXNoXCIpO1xuICAgIHRoaXMubWVzaCA9IG5ldyBNZXNoKHRoaXMuZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgfVxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzaC5tYXRlcmlhbDtcbiAgfVxuICBzZXQgbWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLm1lc2gubWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMubWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMubWVzaCwgdGhpcy5jYW1lcmEpO1xuICB9XG59XG5leHBvcnQge1xuICBGdWxsU2NyZWVuUXVhZCxcbiAgUGFzc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhc3MuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/postprocessing/Pass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0b21hc1xcUHJvamVjdHNcXGNyZWF0aXZlXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcdHlwZXNcXGhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0V2l0aEtleSA9IChvYmosIGtleSkgPT4gb2JqW2tleV07XG5leHBvcnQge1xuICBnZXRXaXRoS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0b21hc1xcUHJvamVjdHNcXGNyZWF0aXZlXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcdXRpbHNcXEJ1ZmZlckdlb21ldHJ5VXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBWZWN0b3IzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBnZXRXaXRoS2V5IH0gZnJvbSBcIi4uL3R5cGVzL2hlbHBlcnMuanNcIjtcbmNvbnN0IG1lcmdlQnVmZmVyR2VvbWV0cmllcyA9IChnZW9tZXRyaWVzLCB1c2VHcm91cHMpID0+IHtcbiAgY29uc3QgaXNJbmRleGVkID0gZ2VvbWV0cmllc1swXS5pbmRleCAhPT0gbnVsbDtcbiAgY29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0uYXR0cmlidXRlcykpO1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLm1vcnBoQXR0cmlidXRlcykpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbMF0ubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20sIGkpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcbiAgICBpZiAoaXNJbmRleGVkICE9PSAoZ2VvbS5pbmRleCAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGF0dHJpYnV0ZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gTWFrZSBzdXJlIGFsbCBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlICE9PSBnZW9tLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghbW9ycGhBdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gIC5tb3JwaEF0dHJpYnV0ZXMgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApXG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSA9IG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhIHx8IFtdO1xuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhLnB1c2goZ2VvbS51c2VyRGF0YSk7XG4gICAgaWYgKHVzZUdyb3Vwcykge1xuICAgICAgbGV0IGNvdW50O1xuICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmluZGV4LmNvdW50O1xuICAgICAgfSBlbHNlIGlmIChnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIFRoZSBnZW9tZXRyeSBtdXN0IGhhdmUgZWl0aGVyIGFuIGluZGV4IG9yIGEgcG9zaXRpb24gYXR0cmlidXRlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5hZGRHcm91cChvZmZzZXQsIGNvdW50LCBpKTtcbiAgICAgIG9mZnNldCArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNJbmRleGVkKSB7XG4gICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBtZXJnZWRJbmRleCA9IFtdO1xuICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZW9tLmluZGV4O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKytqKSB7XG4gICAgICAgIG1lcmdlZEluZGV4LnB1c2goaW5kZXguZ2V0WChqKSArIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGluZGV4T2Zmc2V0ICs9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICB9KTtcbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRJbmRleChtZXJnZWRJbmRleCk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmICghbWVyZ2VkQXR0cmlidXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBhdHRyaWJ1dGUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bMF0ubGVuZ3RoO1xuICAgIGlmIChudW1Nb3JwaFRhcmdldHMgPT09IDApXG4gICAgICBicmVhaztcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7ICsraSkge1xuICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKG1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXVtpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhtb3JwaEF0dHJpYnV0ZXNUb01lcmdlKTtcbiAgICAgIGlmICghbWVyZ2VkTW9ycGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBtb3JwaEF0dHJpYnV0ZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKG1lcmdlZE1vcnBoQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZEdlb21ldHJ5O1xufTtcbmNvbnN0IG1lcmdlQnVmZmVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgaXRlbVNpemUgPSB2b2lkIDA7XG4gIGxldCBub3JtYWxpemVkID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKSB7XG4gICAgICBUeXBlZEFycmF5ID0gYXR0ci5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHIuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLmFycmF5IG11c3QgYmUgb2YgY29uc2lzdGVudCBhcnJheSB0eXBlcyBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbVNpemUgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcbiAgICBpZiAoaXRlbVNpemUgIT09IGF0dHIuaXRlbVNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLml0ZW1TaXplIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZCA9PT0gdm9pZCAwKVxuICAgICAgbm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gYXR0ci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgfSk7XG4gIGlmIChUeXBlZEFycmF5ICYmIGl0ZW1TaXplKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBhcnJheS5zZXQoYXR0ci5hcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG59O1xuY29uc3QgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApXG4gICAgICBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGVCdWZmZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBjYW5ub3QgYmUgaW50ZXJsZWF2ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0cmlidXRlLmFycmF5Lmxlbmd0aDtcbiAgICBzdHJpZGUgKz0gYXR0cmlidXRlLml0ZW1TaXplO1xuICB9XG4gIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKSwgc3RyaWRlKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgY29uc3Qgc2V0dGVycyA9IFtcInNldFhcIiwgXCJzZXRZXCIsIFwic2V0WlwiLCBcInNldFdcIl07XG4gIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgIGNvbnN0IGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuICAgIGNvbnN0IGliYSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlcy5wdXNoKGliYSk7XG4gICAgb2Zmc2V0ICs9IGl0ZW1TaXplO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldFdpdGhLZXkoaWJhLCBzZXR0ZXJzW2tdKTtcbiAgICAgICAgY29uc3QgZ2V0ID0gZ2V0V2l0aEtleShhdHRyaWJ1dGUsIGdldHRlcnNba10pO1xuICAgICAgICBzZXQoYywgZ2V0KGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVzVXNlZChnZW9tZXRyeSkge1xuICBsZXQgbWVtID0gMDtcbiAgZm9yIChsZXQgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBtZW0gKz0gYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKiBhdHRyLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBtZW0gKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgKiBpbmRpY2VzLml0ZW1TaXplICogaW5kaWNlcy5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG4gIHJldHVybiBtZW07XG59XG5mdW5jdGlvbiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5LCB0b2xlcmFuY2UgPSAxZS00KSB7XG4gIHRvbGVyYW5jZSA9IE1hdGgubWF4KHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04pO1xuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gIGNvbnN0IHZlcnRleENvdW50ID0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgOiBwb3NpdGlvbnMuY291bnQ7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpO1xuICBjb25zdCBhdHRyQXJyYXlzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cnNBcnJheXMgPSB7fTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgYXR0ckFycmF5c1tuYW1lXSA9IFtdO1xuICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICBtb3JwaEF0dHJzQXJyYXlzW25hbWVdID0gbmV3IEFycmF5KG1vcnBoQXR0ci5sZW5ndGgpLmZpbGwoMCkubWFwKCgpID0+IFtdKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5sb2cxMCgxIC8gdG9sZXJhbmNlKTtcbiAgY29uc3Qgc2hpZnRNdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxTaGlmdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBoYXNoICs9IGAke35+KGF0dHJpYnV0ZVtnZXR0ZXJzW2tdXShpbmRleCkgKiBzaGlmdE11bHRpcGxpZXIpfSxgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzaCBpbiBoYXNoVG9JbmRleCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGhhc2hUb0luZGV4W2hhc2hdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgIGNvbnN0IG5ld2FycmF5ID0gYXR0ckFycmF5c1tuYW1lXTtcbiAgICAgICAgY29uc3QgbmV3TW9ycGhBcnJheXMgPSBtb3JwaEF0dHJzQXJyYXlzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1trXTtcbiAgICAgICAgICBuZXdhcnJheS5wdXNoKGF0dHJpYnV0ZVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0ci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICAgIG5ld01vcnBoQXJyYXlzW21dLnB1c2gobW9ycGhBdHRyW21dW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoVG9JbmRleFtoYXNoXSA9IG5leHRJbmRleDtcbiAgICAgIG5ld0luZGljZXMucHVzaChuZXh0SW5kZXgpO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgb2xkQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKGF0dHJBcnJheXNbbmFtZV0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCBvbGRBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXN1bHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgaWYgKG5hbWUgaW4gbW9ycGhBdHRyc0FycmF5cykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJzQXJyYXlzW25hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdO1xuICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IG9sZE1vcnBoQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKG1vcnBoQXR0cnNBcnJheXNbbmFtZV1bal0pO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyMiwgb2xkTW9ycGhBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZE1vcnBoQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgICAgICByZXN1bHQubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdID0gbW9ycGhBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoZ2VvbWV0cnksIGRyYXdNb2RlKSB7XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVzRHJhd01vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogR2VvbWV0cnkgYWxyZWFkeSBkZWZpbmVkIGFzIHRyaWFuZ2xlcy5cIik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlKSB7XG4gICAgbGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgICBpZiAocG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgICAgIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKDApKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbmRpY2VzLmxlbmd0aCAvIDMgIT09IG51bWJlck9mVHJpYW5nbGVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgbmV3R2VvbWV0cnkuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gICAgbmV3R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcbiAgICByZXR1cm4gbmV3R2VvbWV0cnk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgZHJhd01vZGUpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzKG9iamVjdCkge1xuICBpZiAob2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgQnVmZmVyR2VvbWV0cnkuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IF92QSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShvYmplY3QyLCBtYXRlcmlhbDIsIGF0dHJpYnV0ZSwgbW9ycGhBdHRyaWJ1dGUsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlMiwgYTIsIGIyLCBjMiwgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheSkge1xuICAgIF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYTIpO1xuICAgIF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYjIpO1xuICAgIF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYzIpO1xuICAgIGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdDIubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICAgIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG1hdGVyaWFsMi5tb3JwaFRhcmdldHMgJiYgbW9ycGhBdHRyaWJ1dGUgJiYgbW9ycGhJbmZsdWVuY2VzXG4gICAgKSB7XG4gICAgICBfbW9ycGhBLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEIuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQy5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGlsMiA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaTIgPCBpbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW2kyXTtcbiAgICAgICAgY29uc3QgbW9ycGggPSBtb3JwaEF0dHJpYnV0ZVtpMl07XG4gICAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBhMik7XG4gICAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBiMik7XG4gICAgICAgIF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBjMik7XG4gICAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZTIpIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQywgaW5mbHVlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQy5zdWIoX3ZDKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3ZBLmFkZChfbW9ycGhBKTtcbiAgICAgIF92Qi5hZGQoX21vcnBoQik7XG4gICAgICBfdkMuYWRkKF9tb3JwaEMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Mi5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYTIsIF92QSk7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYjIsIF92Qik7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYzIsIF92Qyk7XG4gICAgfVxuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMF0gPSBfdkEueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDFdID0gX3ZBLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAyXSA9IF92QS56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMF0gPSBfdkIueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDFdID0gX3ZCLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAyXSA9IF92Qi56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMF0gPSBfdkMueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDFdID0gX3ZDLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAyXSA9IF92Qy56O1xuICB9XG4gIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICBjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcbiAgbGV0IGEsIGIsIGM7XG4gIGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gIGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gIGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcbiAgbGV0IGksIGosIGlsLCBqbDtcbiAgbGV0IGdyb3VwLCBncm91cE1hdGVyaWFsO1xuICBsZXQgc3RhcnQsIGVuZDtcbiAgY29uc3QgbW9kaWZpZWRQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxBdHRyaWJ1dGUuY291bnQgKiBub3JtYWxBdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBpbmRleC5nZXRYKGopO1xuICAgICAgICAgIGIgPSBpbmRleC5nZXRYKGogKyAxKTtcbiAgICAgICAgICBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpbmRleC5nZXRYKGkpO1xuICAgICAgICBiID0gaW5kZXguZ2V0WChpICsgMSk7XG4gICAgICAgIGMgPSBpbmRleC5nZXRYKGkgKyAyKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGo7XG4gICAgICAgICAgYiA9IGogKyAxO1xuICAgICAgICAgIGMgPSBqICsgMjtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGk7XG4gICAgICAgIGIgPSBpICsgMTtcbiAgICAgICAgYyA9IGkgKyAyO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZFBvc2l0aW9uLCAzKTtcbiAgY29uc3QgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkTm9ybWFsLCAzKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG1vcnBoZWROb3JtYWxBdHRyaWJ1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoZ2VvbWV0cnksIGNyZWFzZUFuZ2xlID0gTWF0aC5QSSAvIDMpIHtcbiAgY29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoY3JlYXNlQW5nbGUpO1xuICBjb25zdCBoYXNoTXVsdGlwbGllciA9ICgxICsgMWUtMTApICogMTAwO1xuICBjb25zdCB2ZXJ0cyA9IFtuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpXTtcbiAgY29uc3QgdGVtcFZlYzEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0yID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gaGFzaFZlcnRleCh2KSB7XG4gICAgY29uc3QgeCA9IH5+KHYueCAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB5ID0gfn4odi55ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHogPSB+fih2LnogKiBoYXNoTXVsdGlwbGllcik7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cbiAgY29uc3QgcmVzdWx0R2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpIDogZ2VvbWV0cnk7XG4gIGNvbnN0IHBvc0F0dHIgPSByZXN1bHRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgaWYgKCEoaGFzaCBpbiB2ZXJ0ZXhNYXApKSB7XG4gICAgICAgIHZlcnRleE1hcFtoYXNoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmVydGV4TWFwW2hhc2hdLnB1c2gobm9ybWFsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0F0dHIuY291bnQgKiAzKTtcbiAgY29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5vcm1hbEFycmF5LCAzLCBmYWxzZSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICB0ZW1wTm9ybS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBjb25zdCBvdGhlck5vcm1hbHMgPSB2ZXJ0ZXhNYXBbaGFzaF07XG4gICAgICB0ZW1wTm9ybTIuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJOb3JtID0gb3RoZXJOb3JtYWxzW2tdO1xuICAgICAgICBpZiAodGVtcE5vcm0uZG90KG90aGVyTm9ybSkgPiBjcmVhc2VEb3QpIHtcbiAgICAgICAgICB0ZW1wTm9ybTIuYWRkKG90aGVyTm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBOb3JtMi5ub3JtYWxpemUoKTtcbiAgICAgIG5vcm1BdHRyLnNldFhZWihpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnopO1xuICAgIH1cbiAgfVxuICByZXN1bHRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbm9ybUF0dHIpO1xuICByZXR1cm4gcmVzdWx0R2VvbWV0cnk7XG59XG5leHBvcnQge1xuICBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMsXG4gIGVzdGltYXRlQnl0ZXNVc2VkLFxuICBpbnRlcmxlYXZlQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckdlb21ldHJpZXMsXG4gIG1lcmdlVmVydGljZXMsXG4gIHRvQ3JlYXNlZE5vcm1hbHMsXG4gIHRvVHJpYW5nbGVzRHJhd01vZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJHZW9tZXRyeVV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nfunction retarget(target, source, options = {}) {\n  const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || { bone };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].position\",\n            boneData.pos.times,\n            boneData.pos.values\n          )\n        );\n      }\n      convertedTracks.push(\n        new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\n          \".bones[\" + boneData.bone.name + \"].quaternion\",\n          boneData.quat.times,\n          boneData.quat.values\n        )\n      );\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */ new Map();\n  const cloneLookup = /* @__PURE__ */ new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function(node) {\n    if (!node.isSkinnedMesh)\n      return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name)\n      return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = { retarget, retargetClip, clone };\n\n//# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosOENBQThDO0FBQzlDLGtCQUFrQiwwQ0FBTyxlQUFlLDZDQUFVLGdCQUFnQiwwQ0FBTyx5QkFBeUIsMENBQU8seUJBQXlCLDBDQUFPLHVCQUF1QiwwQ0FBTztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLGlEQUFjO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUd0QjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRvbWFzXFxQcm9qZWN0c1xcY3JlYXRpdmVcXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFx1dGlsc1xcU2tlbGV0b25VdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBNYXRyaXg0LCBBbmltYXRpb25NaXhlciwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIEFuaW1hdGlvbkNsaXAsIFNrZWxldG9uSGVscGVyIH0gZnJvbSBcInRocmVlXCI7XG5mdW5jdGlvbiByZXRhcmdldCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBvcyA9IG5ldyBWZWN0b3IzKCksIHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLCBzY2FsZSA9IG5ldyBWZWN0b3IzKCksIGJpbmRCb25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKSwgcmVsYXRpdmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLCBnbG9iYWxNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICBvcHRpb25zLnByZXNlcnZlTWF0cml4ID0gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA6IHRydWU7XG4gIG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiA9IG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uIDogdHJ1ZTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uID0gb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gOiBmYWxzZTtcbiAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggOiBmYWxzZTtcbiAgb3B0aW9ucy5oaXAgPSBvcHRpb25zLmhpcCAhPT0gdm9pZCAwID8gb3B0aW9ucy5oaXAgOiBcImhpcFwiO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCB7fTtcbiAgY29uc3Qgc291cmNlQm9uZXMgPSBzb3VyY2UuaXNPYmplY3QzRCA/IHNvdXJjZS5za2VsZXRvbi5ib25lcyA6IGdldEJvbmVzKHNvdXJjZSksIGJvbmVzID0gdGFyZ2V0LmlzT2JqZWN0M0QgPyB0YXJnZXQuc2tlbGV0b24uYm9uZXMgOiBnZXRCb25lcyh0YXJnZXQpO1xuICBsZXQgYmluZEJvbmVzLCBib25lLCBuYW1lLCBib25lVG8sIGJvbmVzUG9zaXRpb247XG4gIGlmICh0YXJnZXQuaXNPYmplY3QzRCkge1xuICAgIHRhcmdldC5za2VsZXRvbi5wb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSB0cnVlO1xuICAgIG9wdGlvbnMucHJlc2VydmVNYXRyaXggPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uKSB7XG4gICAgYm9uZXNQb3NpdGlvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvbmVzUG9zaXRpb24ucHVzaChib25lc1tpXS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVNYXRyaXgpIHtcbiAgICB0YXJnZXQudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB0YXJnZXQubWF0cml4V29ybGQuaWRlbnRpdHkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdGFyZ2V0LmNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5vZmZzZXRzKSB7XG4gICAgYmluZEJvbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXRzW25hbWVdKSB7XG4gICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KG9wdGlvbnMub2Zmc2V0c1tuYW1lXSk7XG4gICAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuICAgICAgICBib25lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICB9XG4gICAgICBiaW5kQm9uZXMucHVzaChib25lLm1hdHJpeFdvcmxkLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgIGJvbmVUbyA9IGdldEJvbmVCeU5hbWUobmFtZSwgc291cmNlQm9uZXMpO1xuICAgIGdsb2JhbE1hdHJpeC5jb3B5KGJvbmUubWF0cml4V29ybGQpO1xuICAgIGlmIChib25lVG8pIHtcbiAgICAgIGJvbmVUby51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgaWYgKG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4KSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkodGFyZ2V0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgcmVsYXRpdmVNYXRyaXgubXVsdGlwbHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLnNldEZyb21NYXRyaXhTY2FsZShyZWxhdGl2ZU1hdHJpeCk7XG4gICAgICByZWxhdGl2ZU1hdHJpeC5zY2FsZShzY2FsZS5zZXQoMSAvIHNjYWxlLngsIDEgLyBzY2FsZS55LCAxIC8gc2NhbGUueikpO1xuICAgICAgZ2xvYmFsTWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXQuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHJlbGF0aXZlTWF0cml4KSk7XG4gICAgICBpZiAodGFyZ2V0LmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY29uc3QgYm9uZUluZGV4ID0gYm9uZXMuaW5kZXhPZihib25lKSwgd0JpbmRNYXRyaXggPSBiaW5kQm9uZXMgPyBiaW5kQm9uZXNbYm9uZUluZGV4XSA6IGJpbmRCb25lTWF0cml4LmNvcHkodGFyZ2V0LnNrZWxldG9uLmJvbmVJbnZlcnNlc1tib25lSW5kZXhdKS5pbnZlcnQoKTtcbiAgICAgICAgZ2xvYmFsTWF0cml4Lm11bHRpcGx5KHdCaW5kTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbE1hdHJpeC5jb3B5UG9zaXRpb24ocmVsYXRpdmVNYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG4gICAgICBib25lLm1hdHJpeC5jb3B5KGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KGdsb2JhbE1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvbmUubWF0cml4LmNvcHkoZ2xvYmFsTWF0cml4KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiAmJiBuYW1lID09PSBvcHRpb25zLmhpcCkge1xuICAgICAgYm9uZS5tYXRyaXguc2V0UG9zaXRpb24ocG9zLnNldCgwLCBib25lLnBvc2l0aW9uLnksIDApKTtcbiAgICB9XG4gICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG4gICAgYm9uZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlUG9zaXRpb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBib25lID0gYm9uZXNbaV07XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICAgIGlmIChuYW1lICE9PSBvcHRpb25zLmhpcCkge1xuICAgICAgICBib25lLnBvc2l0aW9uLmNvcHkoYm9uZXNQb3NpdGlvbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlTWF0cml4KSB7XG4gICAgdGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXRhcmdldENsaXAodGFyZ2V0LCBzb3VyY2UsIGNsaXAsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA9IG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA6IGZhbHNlO1xuICBvcHRpb25zLmZwcyA9IG9wdGlvbnMuZnBzICE9PSB2b2lkIDAgPyBvcHRpb25zLmZwcyA6IDMwO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCBbXTtcbiAgaWYgKCFzb3VyY2UuaXNPYmplY3QzRCkge1xuICAgIHNvdXJjZSA9IGdldEhlbHBlckZyb21Ta2VsZXRvbihzb3VyY2UpO1xuICB9XG4gIGNvbnN0IG51bUZyYW1lcyA9IE1hdGgucm91bmQoY2xpcC5kdXJhdGlvbiAqIChvcHRpb25zLmZwcyAvIDFlMykgKiAxZTMpLCBkZWx0YSA9IDEgLyBvcHRpb25zLmZwcywgY29udmVydGVkVHJhY2tzID0gW10sIG1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHNvdXJjZSksIGJvbmVzID0gZ2V0Qm9uZXModGFyZ2V0LnNrZWxldG9uKSwgYm9uZURhdGFzID0gW107XG4gIGxldCBwb3NpdGlvbk9mZnNldCwgYm9uZSwgYm9uZVRvLCBib25lRGF0YSwgbmFtZTtcbiAgbWl4ZXIuY2xpcEFjdGlvbihjbGlwKS5wbGF5KCk7XG4gIG1peGVyLnVwZGF0ZSgwKTtcbiAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRnJhbWVzOyArK2kpIHtcbiAgICBjb25zdCB0aW1lID0gaSAqIGRlbHRhO1xuICAgIHJldGFyZ2V0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lc1tqXS5uYW1lXSB8fCBib25lc1tqXS5uYW1lO1xuICAgICAgYm9uZVRvID0gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBzb3VyY2Uuc2tlbGV0b24pO1xuICAgICAgaWYgKGJvbmVUbykge1xuICAgICAgICBib25lID0gYm9uZXNbal07XG4gICAgICAgIGJvbmVEYXRhID0gYm9uZURhdGFzW2pdID0gYm9uZURhdGFzW2pdIHx8IHsgYm9uZSB9O1xuICAgICAgICBpZiAob3B0aW9ucy5oaXAgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWJvbmVEYXRhLnBvcykge1xuICAgICAgICAgICAgYm9uZURhdGEucG9zID0ge1xuICAgICAgICAgICAgICB0aW1lczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMpLFxuICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzICogMylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBib25lLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib25lLnBvc2l0aW9uLnN1Yihwb3NpdGlvbk9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVEYXRhLnBvcy50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgICAgYm9uZS5wb3NpdGlvbi50b0FycmF5KGJvbmVEYXRhLnBvcy52YWx1ZXMsIGkgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvbmVEYXRhLnF1YXQpIHtcbiAgICAgICAgICBib25lRGF0YS5xdWF0ID0ge1xuICAgICAgICAgICAgdGltZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzKSxcbiAgICAgICAgICAgIHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMgKiA0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYm9uZURhdGEucXVhdC50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgIGJvbmUucXVhdGVybmlvbi50b0FycmF5KGJvbmVEYXRhLnF1YXQudmFsdWVzLCBpICogNCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1peGVyLnVwZGF0ZShkZWx0YSk7XG4gICAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lRGF0YXMubGVuZ3RoOyArK2kpIHtcbiAgICBib25lRGF0YSA9IGJvbmVEYXRhc1tpXTtcbiAgICBpZiAoYm9uZURhdGEpIHtcbiAgICAgIGlmIChib25lRGF0YS5wb3MpIHtcbiAgICAgICAgY29udmVydGVkVHJhY2tzLnB1c2goXG4gICAgICAgICAgbmV3IFZlY3RvcktleWZyYW1lVHJhY2soXG4gICAgICAgICAgICBcIi5ib25lc1tcIiArIGJvbmVEYXRhLmJvbmUubmFtZSArIFwiXS5wb3NpdGlvblwiLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnRpbWVzLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnZhbHVlc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnZlcnRlZFRyYWNrcy5wdXNoKFxuICAgICAgICBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soXG4gICAgICAgICAgXCIuYm9uZXNbXCIgKyBib25lRGF0YS5ib25lLm5hbWUgKyBcIl0ucXVhdGVybmlvblwiLFxuICAgICAgICAgIGJvbmVEYXRhLnF1YXQudGltZXMsXG4gICAgICAgICAgYm9uZURhdGEucXVhdC52YWx1ZXNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbWl4ZXIudW5jYWNoZUFjdGlvbihjbGlwKTtcbiAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGNsaXAubmFtZSwgLTEsIGNvbnZlcnRlZFRyYWNrcyk7XG59XG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgY29uc3Qgc291cmNlTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xvbmVMb29rdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjbG9uZTIgPSBzb3VyY2UuY2xvbmUoKTtcbiAgcGFyYWxsZWxUcmF2ZXJzZShzb3VyY2UsIGNsb25lMiwgZnVuY3Rpb24oc291cmNlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIHNvdXJjZUxvb2t1cC5zZXQoY2xvbmVkTm9kZSwgc291cmNlTm9kZSk7XG4gICAgY2xvbmVMb29rdXAuc2V0KHNvdXJjZU5vZGUsIGNsb25lZE5vZGUpO1xuICB9KTtcbiAgY2xvbmUyLnRyYXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNTa2lubmVkTWVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjbG9uZWRNZXNoID0gbm9kZTtcbiAgICBjb25zdCBzb3VyY2VNZXNoID0gc291cmNlTG9va3VwLmdldChub2RlKTtcbiAgICBjb25zdCBzb3VyY2VCb25lcyA9IHNvdXJjZU1lc2guc2tlbGV0b24uYm9uZXM7XG4gICAgY2xvbmVkTWVzaC5za2VsZXRvbiA9IHNvdXJjZU1lc2guc2tlbGV0b24uY2xvbmUoKTtcbiAgICBjbG9uZWRNZXNoLmJpbmRNYXRyaXguY29weShzb3VyY2VNZXNoLmJpbmRNYXRyaXgpO1xuICAgIGNsb25lZE1lc2guc2tlbGV0b24uYm9uZXMgPSBzb3VyY2VCb25lcy5tYXAoZnVuY3Rpb24oYm9uZSkge1xuICAgICAgcmV0dXJuIGNsb25lTG9va3VwLmdldChib25lKTtcbiAgICB9KTtcbiAgICBjbG9uZWRNZXNoLmJpbmQoY2xvbmVkTWVzaC5za2VsZXRvbiwgY2xvbmVkTWVzaC5iaW5kTWF0cml4KTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTI7XG59XG5mdW5jdGlvbiBnZXRCb25lQnlOYW1lKG5hbWUsIHNrZWxldG9uKSB7XG4gIGZvciAobGV0IGkgPSAwLCBib25lcyA9IGdldEJvbmVzKHNrZWxldG9uKTsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IGJvbmVzW2ldLm5hbWUpXG4gICAgICByZXR1cm4gYm9uZXNbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEJvbmVzKHNrZWxldG9uKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNrZWxldG9uKSA/IHNrZWxldG9uIDogc2tlbGV0b24uYm9uZXM7XG59XG5mdW5jdGlvbiBnZXRIZWxwZXJGcm9tU2tlbGV0b24oc2tlbGV0b24pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IFNrZWxldG9uSGVscGVyKHNrZWxldG9uLmJvbmVzWzBdKTtcbiAgc291cmNlLnNrZWxldG9uID0gc2tlbGV0b247XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBwYXJhbGxlbFRyYXZlcnNlKGEsIGIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKGEsIGIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJhbGxlbFRyYXZlcnNlKGEuY2hpbGRyZW5baV0sIGIuY2hpbGRyZW5baV0sIGNhbGxiYWNrKTtcbiAgfVxufVxuY29uc3QgU2tlbGV0b25VdGlscyA9IHsgcmV0YXJnZXQsIHJldGFyZ2V0Q2xpcCwgY2xvbmUgfTtcbmV4cG9ydCB7XG4gIFNrZWxldG9uVXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ta2VsZXRvblV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;