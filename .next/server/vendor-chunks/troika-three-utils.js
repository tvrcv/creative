"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: () => (/* binding */ BezierMesh),\n/* harmony export */   createDerivedMaterial: () => (/* binding */ createDerivedMaterial),\n/* harmony export */   expandShaderIncludes: () => (/* binding */ expandShaderIncludes),\n/* harmony export */   getShaderUniformTypes: () => (/* binding */ getShaderUniformTypes),\n/* harmony export */   getShadersForMaterial: () => (/* binding */ getShadersForMaterial),\n/* harmony export */   invertMatrix4: () => (/* binding */ invertMatrix4),\n/* harmony export */   voidMainRegExp: () => (/* binding */ voidMainRegExp)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object=} options.defines - Custom `defines` for the material\n * @param {Object=} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object=} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String=} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String=} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String=} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String=} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String=} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function({fragmentShader: string, vertexShader:string}):\n *        {fragmentShader: string, vertexShader:string}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean=} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    type: {\n      get: () => baseMaterial.type,\n      set: (value) => {baseMaterial.type = value;}\n    },\n\n    isDerivedFrom: {\n      writable: true,\n      configurable: true,\n      value: function (testMaterial) {\n        const base = this.baseMaterial;\n        return testMaterial === base || (base.isDerivedMaterial && base.isDerivedFrom(testMaterial)) || false\n      }\n    },\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_1__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_1__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_1__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07O0FBRTlNO0FBQ0EscURBQXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUyxrRUFBa0Usa0JBQWtCO0FBQ3hHLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFD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QUM3Qix3QkFBd0IsMENBQU87QUFDL0Isd0JBQXdCLDBDQUFPO0FBQy9CLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0oiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdG9tYXNcXFByb2plY3RzXFxjcmVhdGl2ZVxcbm9kZV9tb2R1bGVzXFx0cm9pa2EtdGhyZWUtdXRpbHNcXGRpc3RcXHRyb2lrYS10aHJlZS11dGlscy5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyQ2h1bmssIFVuaWZvcm1zVXRpbHMsIE1lc2hEZXB0aE1hdGVyaWFsLCBSR0JBRGVwdGhQYWNraW5nLCBNZXNoRGlzdGFuY2VNYXRlcmlhbCwgU2hhZGVyTGliLCBNYXRyaXg0LCBWZWN0b3IzLCBNZXNoLCBDeWxpbmRlckdlb21ldHJ5LCBWZWN0b3IyLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBleHBhbmRzIGFsbCBgI2luY2x1ZGUgPHh5ej5gIHN0YXRlbWVudHMgd2l0aGluIHN0cmluZyBvZiBzaGFkZXIgY29kZS5cbiAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlIGNvZGUgdG8gZXZhbHVhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICovXG5mdW5jdGlvbiBleHBhbmRTaGFkZXJJbmNsdWRlcyggc291cmNlICkge1xuICBjb25zdCBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcbiAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgIGxldCBjaHVuayA9IFNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgIHJldHVybiBjaHVuayA/IGV4cGFuZFNoYWRlckluY2x1ZGVzKGNodW5rKSA6IG1hdGNoXG4gIH1cbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkaXJlY3QgY29weSBvZiBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEIGZyb20gVGhyZWUuanMsIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCB0aHJlZVxuICogdmVyc2lvbnMgYmVmb3JlIDAuMTEzLjAgYXMgaXQgd2FzIGNoYW5nZWQgZnJvbSBNYXRoIHRvIE1hdGhVdGlscyBpbiB0aGF0IHZlcnNpb24uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGQ4YjVhYTNiMjcwYzE3MDk2YjkwOTQ1Y2QyZDZkMWIxM2FhZWM1My9zcmMvbWF0aC9NYXRoVXRpbHMuanMjTDE2XG4gKi9cblxuY29uc3QgX2x1dCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG4gIGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMiAmIDB4M2YgfCAweDgwXSArIF9sdXRbZDIgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMiA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMiA+PiAyNCAmIDB4ZmZdICtcbiAgICBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuICAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG4gIHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKClcblxufVxuXG4vLyBMb2NhbCBhc3NpZ24gcG9seWZpbGwgdG8gYXZvaWQgaW1wb3J0aW5nIHRyb2lrYS1jb3JlXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKC8qdGFyZ2V0LCAuLi5zb3VyY2VzKi8pIHtcbiAgbGV0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn07XG5cblxuY29uc3QgZXBvY2ggPSBEYXRlLm5vdygpO1xuY29uc3QgQ09OU1RSVUNUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgU0hBREVSX1VQR1JBREVfQ0FDSEUgPSBuZXcgTWFwKCk7XG5cbi8vIE1hdGVyaWFsIGlkcyBtdXN0IGJlIGludGVnZXJzLCBidXQgd2UgY2FuJ3QgYWNjZXNzIHRoZSBpbmNyZW1lbnQgZnJvbSBUaHJlZSdzIGBNYXRlcmlhbGAgbW9kdWxlLFxuLy8gc28gbGV0J3MgY2hvb3NlIGEgc3VmZmljaWVudGx5IGxhcmdlIHN0YXJ0aW5nIHZhbHVlIHRoYXQgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgY29sbGlkZS5cbmxldCBtYXRlcmlhbEluc3RhbmNlSWQgPSAxZTEwO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAqIHNoYWRlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBpbmplY3QgY3VzdG9tIHNoYWRlciBsb2dpYyBhbmQgdHJhbnNmb3JtcyBpbnRvIHRoZVxuICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBiYXNlTWF0ZXJpYWwgLSB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgdG8gZGVyaXZlIGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICogICAgICAgIGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZCB2aWEgdGhlIHJlc3VsdGluZyBtYXRlcmlhbCdzIGB1bmlmb3Jtc2AgcHJvcGVydHksIGp1c3QgbGlrZVxuICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZz19IG9wdGlvbnMuZnJhZ21lbnREZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgZnJhZ21lbnQgc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGB2b2lkIG1haW5gIGZ1bmN0aW9uLCBidXQgYmVmb3JlIGFueVxuICogICAgICAgIG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgYW5kIGJlZm9yZSB0aGVcbiAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICogQHBhcmFtIHtmdW5jdGlvbih7ZnJhZ21lbnRTaGFkZXI6IHN0cmluZywgdmVydGV4U2hhZGVyOnN0cmluZ30pOlxuICogICAgICAgIHtmcmFnbWVudFNoYWRlcjogc3RyaW5nLCB2ZXJ0ZXhTaGFkZXI6c3RyaW5nfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25zLmNoYWluZWQgLSBTZXQgdG8gYHRydWVgIHRvIHByb3RvdHlwZS1jaGFpbiB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byB0aGUgYmFzZVxuICogICAgICAgIG1hdGVyaWFsLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb3B5aW5nIGl0LiBUaGlzIGFsbG93cyB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0b1xuICogICAgICAgIGF1dG9tYXRpY2FsbHkgcGljayB1cCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGJhc2UgbWF0ZXJpYWwgYW5kIGl0cyBwcm9wZXJ0aWVzLiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAqICAgICAgICB3aGVyZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBpcyBoaWRkZW4gZnJvbSB0aGUgdXNlciBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFsbG93aW5nIHRoZW1cbiAqICAgICAgICB0byB3b3JrIHdpdGggdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGxpa2Ugbm9ybWFsLiBCdXQgaXQgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIG5vdFxuICogICAgICAgIGhhbmRsZWQgY2FyZWZ1bGx5LlxuICpcbiAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICpcbiAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAqIHRhcmdldCBtZXNoIGlzIGV4cGVjdGVkIHRvIGNhc3Qgc2hhZG93cywgdGhlbiB5b3UgY2FuIGFzc2lnbiB0aGVzZSB0byB0aGUgbWVzaCdzIGBjdXN0b21EZXB0aE1hdGVyaWFsYFxuICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gKiB3aWxsIGFsc28gc2V0IGEgY3VzdG9tIGAjZGVmaW5lIElTX0RFUFRIX01BVEVSSUFMYCBvciBgI2RlZmluZSBJU19ESVNUQU5DRV9NQVRFUklBTGAgdGhhdCB5b3UgY2FuIGxvb2tcbiAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgLy8gR2VuZXJhdGUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIGNvbnRlbnQgb2YgdGhlc2UgYG9wdGlvbnNgLiBXZSdsbCB1c2UgdGhpc1xuICAvLyB0aHJvdWdob3V0IGZvciBjYWNoaW5nIGFuZCBmb3IgZ2VuZXJhdGluZyB0aGUgdXBncmFkZWQgc2hhZGVyIGNvZGUuIFRoaXMgaW5jcmVhc2VzXG4gIC8vIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIHJlc3VsdGluZyBzaGFkZXJzIHdpbGwgbGluZSB1cCBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMgc29cbiAgLy8gdGhlaXIgR0wgcHJvZ3JhbXMgY2FuIGJlIHNoYXJlZCBhbmQgY2FjaGVkLlxuICBjb25zdCBvcHRpb25zS2V5ID0gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlTWF0ZXJpYWwgdXNpbmcgdGhpc1xuICAvLyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyByZXVzZSB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgc29tZSBhbGxvY2F0aW9ucy5cbiAgbGV0IGN0b3JzQnlEZXJpdmF0aW9uID0gQ09OU1RSVUNUT1JfQ0FDSEUuZ2V0KGJhc2VNYXRlcmlhbCk7XG4gIGlmICghY3RvcnNCeURlcml2YXRpb24pIHtcbiAgICBDT05TVFJVQ1RPUl9DQUNIRS5zZXQoYmFzZU1hdGVyaWFsLCAoY3RvcnNCeURlcml2YXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gIH1cbiAgaWYgKGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSgpXG4gIH1cblxuICBjb25zdCBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBgX29uQmVmb3JlQ29tcGlsZSR7b3B0aW9uc0tleX1gO1xuXG4gIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gIC8vIHRoZSByZW5kZXJlciBzd2l0Y2hlcyB0byB0aGlzIG1hdGVyaWFsJ3MgcHJvZ3JhbVxuICBjb25zdCBvbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoc2hhZGVySW5mbywgcmVuZGVyZXIpIHtcbiAgICBiYXNlTWF0ZXJpYWwub25CZWZvcmVDb21waWxlLmNhbGwodGhpcywgc2hhZGVySW5mbywgcmVuZGVyZXIpO1xuXG4gICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0IGJ5IGluY29taW5nIHNvdXJjZSBjb2RlXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgKyAnfCcgKyBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgIGxldCB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV07XG4gICAgaWYgKCF1cGdyYWRlZFNoYWRlcnMpIHtcbiAgICAgIGNvbnN0IHVwZ3JhZGVkID0gdXBncmFkZVNoYWRlcnModGhpcywgc2hhZGVySW5mbywgb3B0aW9ucywgb3B0aW9uc0tleSk7XG4gICAgICB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV0gPSB1cGdyYWRlZDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdXBncmFkZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgaW50byB0aGUgcHJvZ3JhbVxuICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLnZlcnRleFNoYWRlcjtcbiAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuICAgIGFzc2lnbihzaGFkZXJJbmZvLnVuaWZvcm1zLCB0aGlzLnVuaWZvcm1zKTtcblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgc2hhZGVySW5mby51bmlmb3Jtc1tvcHRpb25zLnRpbWVVbmlmb3JtXSA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKHNoYWRlckluZm8pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBEZXJpdmVkTWF0ZXJpYWwgPSBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGRlcml2ZShvcHRpb25zLmNoYWluZWQgPyBiYXNlTWF0ZXJpYWwgOiBiYXNlTWF0ZXJpYWwuY2xvbmUoKSlcbiAgfTtcblxuICBjb25zdCBkZXJpdmUgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgLy8gUHJvdG90eXBlIGNoYWluIHRvIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgY29uc3QgZGVyaXZlZCA9IE9iamVjdC5jcmVhdGUoYmFzZSwgZGVzY3JpcHRvcik7XG5cbiAgICAvLyBTdG9yZSB0aGUgYmFzZU1hdGVyaWFsIGZvciByZWZlcmVuY2U7IHRoaXMgaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBldmVuIHdoZW4gY2xvbmluZ1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnYmFzZU1hdGVyaWFsJywgeyB2YWx1ZTogYmFzZU1hdGVyaWFsIH0pO1xuXG4gICAgLy8gTmVlZHMgaXRzIG93biBpZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJbnN0YW5jZUlkKysgfSk7XG4gICAgZGVyaXZlZC51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICBkZXJpdmVkLnVuaWZvcm1zID0gYXNzaWduKHt9LCBiYXNlLnVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICBkZXJpdmVkLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2UuZGVmaW5lcywgb3B0aW9ucy5kZWZpbmVzKTtcbiAgICBkZXJpdmVkLmRlZmluZXNbYFRST0lLQV9ERVJJVkVEX01BVEVSSUFMXyR7b3B0aW9uc0tleX1gXSA9ICcnOyAvL2ZvcmNlIGEgcHJvZ3JhbSBjaGFuZ2UgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGRlcml2ZWQuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgYmFzZS5leHRlbnNpb25zLCBvcHRpb25zLmV4dGVuc2lvbnMpO1xuXG4gICAgLy8gRG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgZGVyaXZlZC5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlcml2ZWRcbiAgfTtcblxuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IERlcml2ZWRNYXRlcmlhbH0sXG4gICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICB0eXBlOiB7XG4gICAgICBnZXQ6ICgpID0+IGJhc2VNYXRlcmlhbC50eXBlLFxuICAgICAgc2V0OiAodmFsdWUpID0+IHtiYXNlTWF0ZXJpYWwudHlwZSA9IHZhbHVlO31cbiAgICB9LFxuXG4gICAgaXNEZXJpdmVkRnJvbToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHRlc3RNYXRlcmlhbCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5iYXNlTWF0ZXJpYWw7XG4gICAgICAgIHJldHVybiB0ZXN0TWF0ZXJpYWwgPT09IGJhc2UgfHwgKGJhc2UuaXNEZXJpdmVkTWF0ZXJpYWwgJiYgYmFzZS5pc0Rlcml2ZWRGcm9tKHRlc3RNYXRlcmlhbCkpIHx8IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgfSxcbiAgICAgIHNldChmbikge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIFVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmU6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG59XG5cblxuZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gIGxldCB7XG4gICAgdmVydGV4RGVmcyxcbiAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgdmVydGV4TWFpbk91dHJvLFxuICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICBmcmFnbWVudERlZnMsXG4gICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICBjdXN0b21SZXdyaXRlcixcbiAgICB0aW1lVW5pZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICB9XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xjb2xvcnNwYWNlfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICApO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICApO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICB9XG5cbiAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgfVxuXG4gIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgIH0pO1xuXG4gICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gIHJldHVybiB7XG4gICAgdmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgKTtcbiAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gIH1cbiAgcmV0dXJuIHNoYWRlckNvZGVcbn1cblxuXG5mdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxufVxuXG5sZXQgX2lkQ3RyID0gMDtcbmNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICB9XG4gIHJldHVybiBpZFxufVxuXG4vLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG5jb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG59O1xuXG4vKipcbiAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xufVxuXG4vKipcbiAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gKi9cbmZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgTWF0cml4NCgpKSB7XG4gIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgfVxuICByZXR1cm4gdGd0TWF0cml4XG59XG5cbi8qXG5JbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG5kaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4qL1xuXG5jb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG5jb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG5jb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbi8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4vLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbi8vIGBcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICBiYXNlTWF0ZXJpYWwsXG4gICAge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgIH1cbiAgKVxufVxuXG5sZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiBEb3VibGVTaWRlfSk7XG5cblxuLyoqXG4gKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICogLSBgcG9pbnRBYFxuICogLSBgY29udHJvbEFgXG4gKiAtIGBjb250cm9sQmBcbiAqIC0gYHBvaW50QmBcbiAqXG4gKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAqXG4gKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gKiB0aGlja2VyIHR1YmVzLlxuICpcbiAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAqL1xuY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIE1lc2gge1xuICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICApXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICApO1xuXG4gICAgdGhpcy5wb2ludEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucG9pbnRCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgVmVjdG9yMigpO1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gIH1cblxuICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXJNZXNoLCBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIGV4cGFuZFNoYWRlckluY2x1ZGVzLCBnZXRTaGFkZXJVbmlmb3JtVHlwZXMsIGdldFNoYWRlcnNGb3JNYXRlcmlhbCwgaW52ZXJ0TWF0cml4NCwgdm9pZE1haW5SZWdFeHAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n");

/***/ })

};
;